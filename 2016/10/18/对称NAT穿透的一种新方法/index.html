<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 对称NAT穿透的一种新方法 · xd_xd's blog</title><meta name="description" content="对称NAT穿透的一种新方法 - xd_xd"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/jquery.goup.js"></script><script src="/js/goup.js"></script><link rel="search" type="application/opensearchdescription+xml" href="http://xdxd.love/atom.xml" title="xd_xd's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/hkalexling" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/archives" target="_self" class="nav-list-link">ARCHIVES</a></li><li class="nav-list-item"><a href="/friends" target="_self" class="nav-list-link">FRIENDS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">对称NAT穿透的一种新方法</h1><div class="post-info">Oct 18, 2016</div><div class="post-content"><h2 id="前言">前言</h2><p>这种方法从安全的角度来说是利用了目前路由器实现对称NAT的方法中存在端口可以预测的漏洞，利用这个漏洞来实现打洞。加上一次发送大量的包，来增加命中的概率。</p>
<h2 id="参考资料">参考资料</h2><p>整理翻译自<a href="https://www.goto.info.waseda.ac.jp/~wei/file/wei-apan-v10.pdf" target="_blank" rel="external">A New Method for Symmetric NAT Traversal in UDP and TCP</a><br><a href="http://www.cnblogs.com/my_life/articles/1908552.html" target="_blank" rel="external">NAT的四种类型及类型检测</a></p>
<h2 id="关键字">关键字</h2><p>NAT穿透，对称NAT，UDP,P2P，状态包预测，TCP，P2P打洞</p>
<h2 id="4中NAT类型">4中NAT类型</h2><p>用语定义</p>
<p>1.内部Tuple：指内部主机的私有地址和端口号所构成的二元组，即内部主机所发送报文的源地址、端口所构成的二元组<br>2.外部Tuple：指内部Tuple经过NAT的源地址/端口转换之后，所获得的外部地址、端口所构成的二元组，即外部主机收到经NAT转换之后的报文时，它所看到的该报文的源地址（通常是NAT设备的地址）和源端口<br>3.目标Tuple：指外部主机的地址、端口所构成的二元组，即内部主机所发送报文的目标地址、端口所构成的二元组</p>
<p>详细释义</p>
<ol>
<li>Full Cone NAT：所有来自同一 个内部Tuple X的请求均被NAT转换至同一个外部Tuple Y，而不管这些请求是不是属于同一个应用或者是多个应用的。除此之外，当X-Y的转换关系建立之后，任意外部主机均可随时将Y中的地址和端口作为目标地址 和目标端口，向内部主机发送UDP报文，由于对外部请求的来源无任何限制，因此这种方式虽然足够简单，但却不那么安全.</li>
</ol>
<p><img src="/images/nat1.png" alt=""></p>
<ol>
<li>Restricted Cone NAT： 它是Full Cone的受限版本：所有来自同一个内部Tuple X的请求均被NAT转换至同一个外部Tuple Y，这与Full Cone相同，但不同的是，只有当内部主机曾经发送过报文给外部主机（假设其IP地址为Z）后，外部主机才能以Y中的信息作为目标地址和目标端口，向内部 主机发送UDP请求报文，这意味着，NAT设备只向内转发（目标地址/端口转换）那些来自于当前已知的外部主机的UDP报文，从而保障了外部请求来源的安 全性</li>
</ol>
<p><img src="/images/nat2.png" alt=""></p>
<ol>
<li>Port Restricted Cone NAT：它是Restricted Cone NAT的进一步受限版。只有当内部主机曾经发送过报文给外部主机（假设其IP地址为Z且端口为P）之后，外部主机才能以Y中的信息作为目标地址和目标端 口，向内部主机发送UDP报文，同时，其请求报文的源端口必须为P，这一要求进一步强化了对外部报文请求来源的限制，从而较Restrictd Cone更具安全性</li>
</ol>
<p><img src="/images/nat3.png" alt=""></p>
<ol>
<li>Symmetric NAT：这是一种比所有Cone NAT都要更为灵活的转换方式：在Cone NAT中，内部主机的内部Tuple与外部Tuple的转换映射关系是独立于内部主机所发出的UDP报文中的目标地址及端口的，即与目标Tuple无关； 在Symmetric NAT中，目标Tuple则成为了NAT设备建立转换关系的一个重要考量：只有来自于同一个内部Tuple 、且针对同一目标Tuple的请求才被NAT转换至同一个外部Tuple，否则的话，NAT将为之分配一个新的外部Tuple；打个比方，当内部主机以相 同的内部Tuple对2个不同的目标Tuple发送UDP报文时，此时NAT将会为内部主机分配两个不同的外部Tuple，并且建立起两个不同的内、外部 Tuple转换关系。与此同时，只有接收到了内部主机所发送的数据包的外部主机才能向内部主机返回UDP报文，这里对外部返回报文来源的限制是与Port Restricted Cone一致的。不难看出，如果说Full Cone是要求最宽松NAT UDP转换方式，那么，Symmetric NAT则是要求最严格的NAT方式，其不仅体现在转换关系的建立上，而且还体现在对外部报文来源的限制方面。</li>
</ol>
<p><img src="/images/nat4.png" alt=""></p>
<h2 id="已经存在的穿透方案">已经存在的穿透方案</h2><p>UPNP，STUN，Teredo等都无法支持对称NAT(第4类NAT)穿透。</p>
<h2 id="新方法">新方法</h2><p>新方法的UDP打洞基于端口预测和限制TTL的值。也适用于其他的NAT类型。<br>新方法一共有3个阶段。</p>
<p><img src="/images/nat5.png" alt=""></p>
<h3 id="第一阶段">第一阶段</h3><p>假设两个通讯的终端分别为echo client和echo server。</p>
<p>F1：echo client跟S1通讯，然后S1获得其经过NAT a的端口号。<br>F2：S1返回获得的端口号给echo client<br>F3：echo client给S2发一个包。包括上次S1返回的nat之后的端口号。S2记录下相关的NAT端口信息。<br><img src="/images/nat6.png" alt=""></p>
<h3 id="第二阶段">第二阶段</h3><p>第二阶段是echo server跟S1和S2通信。流程跟echo client类似。</p>
<p><img src="/images/nat7.png" alt=""></p>
<h3 id="第三阶段">第三阶段</h3><p>经过之前的通讯，服务器可以获得echo client和echo server两次nat的端口号。比如echo client第一次nat端口为5361，第二次nat端口为5362，那么有理由猜测，第三次的端口为5363.经过测试发现端口的变化多是有一定的规律，递增，递减，跳跃等。</p>
<p>F7: 基于前面两个阶段的通信，可以预测打洞的端口和打洞的模式。发送给echo server.<br>F8: 基于预测的端口，echo server发送大量的包。这些包包括一个固定的目的端口和低的TTL值。<br>F9: 同理，服务器将预测的端口发给echo client，跟F7类似。<br>F10: 基于预测的端口，echo client发送大量固定端口的数据包到预测的端口。之后，echo client 转换到接受模式。</p>
<p>如果预测的端口刚好被大量的包都命中。那么就可以建立通信。</p>
<p><img src="/images/nat8.png" alt=""></p>
<h2 id="新方法的优势">新方法的优势</h2><h2 id="结论">结论</h2><p><img src="/images/nat9.png" alt=""></p>
<p>这种方法从安全的角度来说是利用了目前路由器实现对称NAT的方法中存在端口可以预测的漏洞，利用这个漏洞来实现打洞。加上一次发送大量的包，来增加命中的概率。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/10/19/discuz最新版20160601-SSRF漏洞分析/" class="prev">上一篇</a><a href="/2016/10/17/unicode同形字引起的安全问题/" class="next">下一篇</a></div><div class="copyright"><p>© 2016 <a href="http://xdxd.love">xd_xd</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/hkalexling/Yuno-Apollo" target="_blank">Yuno-Apollo</a>.</p></div></footer></div><script src="https://cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>