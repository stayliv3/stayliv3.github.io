<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> CRC32算法碰撞测试 · xd_xd's blog</title><meta name="description" content="CRC32算法碰撞测试 - xd_xd"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://xdxd.love/atom.xml" title="xd_xd's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/u/5256150165?is_all=1" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/stayliv3" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">CRC32算法碰撞测试</h1><div class="post-info">Jan 14, 2016</div><div class="post-content"><h1 id="CRC32算法概述">CRC32算法概述</h1><p>CRC全称Cyclic Redundancy Check，又叫循环冗余校验。CRC32跟md5，sha1一样都是哈希算法的一种。crc32的优势是速度快，它被设计的目的是用来检测数据在网络传输过程中可能出现的随机错误。它跟md5和sha1有本质的区别就是它不是一种加密hash算法或者叫not cryptographically secure或者not cryptographic hashing。加密哈希算法的特征比如空间极大，碰撞概率极低，对于给定的哈希值难以找到另一个哈希值相同的字符串等crc32都不具备。</p>
<h1 id="CRC32算法原理">CRC32算法原理</h1><p>前面说到crc32的一些特性，这个要从crc32的原理开始分析。crc32的数学原理看起来还是有点复杂的,我也理解不透彻。简单一点理解就是把需要进行校验的数据选定一个除数进行一次除法运算，称为模2除法，跟通常二进制除法规则不同，得到的余数作为循环冗余码。数据接收端接收到数据之后进行同样的运算，即可判断数据在传输过程中是否出现了变化。当然具体的计算方式会复杂的多。这里说的不当的地方或者有更好的表达方式欢迎讨论。</p>
<h1 id="CRC32算法碰撞和破解">CRC32算法碰撞和破解</h1><p>crc32碰撞的概率非常高，根据一些测试结果<a href="http://blog.csdn.net/yunhua_lee/article/details/42775039" target="_blank" rel="external">CRC32算法冲突概率测试和分析</a>,对于随机数据的碰撞概率测试1820W数据，冲突数量是38638个。根据crc32的算法可以直接逆向找到相同crc32的字符串。<a href="https://github.com/theonlypwner/crc32" target="_blank" rel="external">脚本地址</a></p>
<p><img src="/images/crc321.png" alt=""></p>
<p>对于给定的字符串进行padding暴力破解在短时间内是一定可以获得相同crc32结果的。测试脚本：<a href="https://github.com/stayliv3/blog_material/blob/master/crc-collision/crc-collision.py" target="_blank" rel="external">crc-collision</a><br>下面两个字符串是有相同的CRC32值。</p>
<pre><code>import binascii
print binascii.<span class="function"><span class="title">crc32</span><span class="params">(<span class="string">'{"auth_url": "https://www.evil.example"}'</span> + <span class="string">' '</span>*<span class="number">2303357834</span>)</span></span>
print binascii.<span class="function"><span class="title">crc32</span><span class="params">(<span class="string">'{"auth_url": "https://www.google.com"}'</span>)</span></span>
</code></pre><p><img src="/images/crc322.png" alt=""></p>
<h1 id="CRC32算法的使用场景">CRC32算法的使用场景</h1><p>CRC32的设计初衷是用来检测底层网络传输数据时由于网络问题导致的数据出错。所以多用在底层网络设备中。应用层也有一些使用场景。但是不能用来做加密hash即sha256函数做的事情，比如用来做签名。crc32是无法保证数据完整性的。它只能用来检测异常不能用来对抗恶意的行为。最近在对一个认证系统做审计的时候发现使用了crc32做数据签名。所以有了对crc32碰撞的测试。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/01/18/mysql表名大小写敏感问题/" class="prev">上一篇</a><a href="/2016/01/13/飞塔FortiGate-SSH后门事件/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://xdxd.love">xd_xd</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>