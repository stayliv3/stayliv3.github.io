<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 一个任意文件读取漏洞记录 · xd_xd's blog</title><meta name="description" content="一个任意文件读取漏洞记录 - xd_xd"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/jquery.goup.js"></script><script src="/js/goup.js"></script><link rel="search" type="application/opensearchdescription+xml" href="http://xdxd.love/atom.xml" title="xd_xd's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/hkalexling" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/archives" target="_self" class="nav-list-link">ARCHIVES</a></li><li class="nav-list-item"><a href="/friends" target="_self" class="nav-list-link">FRIENDS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">一个任意文件读取漏洞记录</h1><div class="post-info">May 23, 2016</div><div class="post-content"><h1 id="黑盒测试">黑盒测试</h1><p>黑盒测试发现某个接口存在任意文件读取的漏洞。<br><img src="/images/wenjianduqu1.gif" alt=""><br>首选判断是文件读取还是文件包含，因为file_get_content(“/etc/passwd”)和include(“/etc/passwd”)黑盒来看的表现可能一样。而文件包含是可以getshell的，文件读取就只能读取文件。可以通过尝试读取相对路径的脚本文件，比如<code>/read.php?file=read.php</code>的方式，如果可以读取到文件源码，说明是文件读取，如果不能读取到文件源码说明是文件包含。</p>
<h1 id="文件读取">文件读取</h1><p>服务器上有价值的文件主要可以分为3类。通用的系统/应用配置文件，个性化的文件以及web应用的源码文件。而想要读取到一个文件只需要知道这个文件的绝对路径或者相对路径就可以了。</p>
<p>把web应用的源码单独出来是觉得应用源码可以很方便的通过相对路径获取到，不需要费劲得到源码的绝对路径。系统的通用配置文件比如</p>
<pre><code><span class="regexp">/etc/</span>passwd
<span class="regexp">/etc/my</span>.cnf
<span class="regexp">/etc/</span>shadow
<span class="regexp">/etc/</span>sysconfig<span class="regexp">/network-scripts/i</span>fcfg-eth0   ip地址
<span class="regexp">/etc/</span>hosts                                  通常配置了一些内网域名
</code></pre><p>等等可以通过字典的方式来猜解。</p>
<p>这个案例通过passwd中获得的用户来获取到了这个用户的bash_history，从bash_history获取到了一些压缩包的地址。从而读取到了个性化的文件,一些压缩包的文件。<br><img src="/images/wenjianduqu2.png" alt=""><br><img src="/images/wenjianduqu3.png" alt=""></p>
<p>通过mysql的配置文件得知了数据的存储目录。通过直接读取数据库文件可以获取到数据库内的信息。</p>
<p><img src="/images/wenjianduqu4.png" alt=""></p>
<p>在说到文件包含利用的时候，会讲到有个小技巧，某些情况下可以包含proc下的文件。文件读取的情况下当然可以可以读取proc目录下的文件来获得更多系统的信息。</p>
<p><img src="/images/wenjianduqu5.png" alt=""></p>
<pre><code>/<span class="keyword">proc</span>/sched_debug  提供cpu上正在运行的进程信息，可以获得进程的pid号，可以配合后面需要pid的利用
/<span class="keyword">proc</span>/mounts 挂载的文件系统列表
/<span class="keyword">proc</span>/net/arp  arp表，可以获得内网其他机器的地址
/<span class="keyword">proc</span>/net/route 路由表信息
/<span class="keyword">proc</span>/net/tcp <span class="keyword">and</span> /<span class="keyword">proc</span>/net/udp  活动连接的信息
/<span class="keyword">proc</span>/net/fib_trie 路由缓存
/<span class="keyword">proc</span>/version  内核版本
/<span class="keyword">proc</span>/[<span class="type">PID</span>]/cmdline 可能包含有用的路径信息
/<span class="keyword">proc</span>/[<span class="type">PID</span>]/environ 程序运行的环境变量信息，可以用来包含getshell
/<span class="keyword">proc</span>/[<span class="type">PID</span>]/cwd     当前进程的工作目录
/<span class="keyword">proc</span>/[<span class="type">PID</span>]/fd/[<span class="comment">#]  访问file descriptors，某写情况可以读取到进程正在使用的文件，比如access.log</span>
</code></pre><p>fuzz字典：</p>
<pre><code>/<span class="keyword">proc</span>/self/cmdline
/<span class="keyword">proc</span>/self/stat
/<span class="keyword">proc</span>/self/status
/<span class="keyword">proc</span>/self/environ
/<span class="keyword">proc</span>/verison
/<span class="keyword">proc</span>/cmdline
/<span class="keyword">proc</span>/self/cwd
/<span class="keyword">proc</span>/self/fd/<span class="number">0</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">1</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">2</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">3</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">4</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">5</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">6</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">7</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">8</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">9</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">10</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">11</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">12</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">13</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">14</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">15</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">16</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">17</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">18</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">19</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">20</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">21</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">22</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">23</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">24</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">25</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">26</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">27</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">28</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">29</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">30</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">31</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">32</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">33</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">34</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">35</span>
/<span class="keyword">proc</span>/sched_debug
/<span class="keyword">proc</span>/mounts
/<span class="keyword">proc</span>/net/arp
/<span class="keyword">proc</span>/net/route
/<span class="keyword">proc</span>/net/tcp
/<span class="keyword">proc</span>/net/udp
/<span class="keyword">proc</span>/net/fib_trie
/<span class="keyword">proc</span>/version
</code></pre><h1 id="漏洞分析">漏洞分析</h1><p>读取到应用代码，对漏洞原因进行分析。</p>
<p>通过入口初始化文件读取到配置文件。</p>
<pre><code><span class="comment">/* 初始化设置 END */</span>
<span class="comment">//--------------------------------------------------</span>
<span class="keyword">require</span> (ROOT_PATH <span class="built_in">. </span>ADMIN_PATH <span class="built_in">. </span><span class="string">'/includes/config.php'</span>);
<span class="class"><span class="keyword">define</span></span>(<span class="string">'CLS_PATH'</span>, ROOT_PATH <span class="built_in">. </span>ADMIN_PATH <span class="built_in">. </span><span class="string">'/'</span>);
include ROOT_PATH <span class="built_in">. </span>ADMIN_PATH <span class="built_in">. </span><span class="string">'/includes/base/autoload.class.php'</span>;
autoloader<span class="tag">::init</span>();
<span class="comment">/* 初始化memcached */</span>
<span class="comment">//$cache = new base_memcached();</span>
</code></pre><p>配置文件中自然有数据库账号，这个暂且不说。先看autoload.class.php。autoload实现自动加载类的功能。通过其实现方式拼接出存在漏洞的action类文件路径。</p>
<pre><code>/**
 * 固定路径的class 类文件 以.class.php 结尾
 */
private <span class="keyword">function</span> base_class(<span class="variable">$className</span>) {
    // echo <span class="string">"1 $className&lt;br /&gt;"</span>;
    <span class="variable">$path</span> = array();
    <span class="variable">$pathDir</span> = array();
    <span class="variable">$path</span> = explode(<span class="string">'_'</span>, <span class="variable">$className</span>);
    <span class="variable">$arrCount</span> = count(<span class="variable">$path</span>) - <span class="number">1</span>;
    <span class="variable">$pathDir</span> = implode(<span class="string">"/"</span>, array_slice(<span class="variable">$path</span>, <span class="number">0</span>, <span class="variable">$arrCount</span>));
    // set_include_path(get_include_path() . PATH_SEPARATOR . <span class="string">'/includes/'</span> . <span class="variable">$pathDir</span> . <span class="string">"/"</span>);
    set_include_path(CLS_PATH . <span class="string">"/includes/"</span> . <span class="variable">$pathDir</span>);
    spl_autoload_extensions(<span class="string">'.class.php'</span>);
    spl_autoload(<span class="variable">$path</span>[<span class="variable">$arrCount</span>]);
}
</code></pre><p>读到关键函数的源码：</p>
<pre><code>class models_index {
    public function newsList(<span class="variable">$url</span> = <span class="string">''</span>) {
        <span class="variable">$list</span> = @file_get_contents(<span class="variable">$this</span> -&gt; host.<span class="variable">$url</span>);
        return <span class="variable">$list</span>? <span class="variable">$list</span> : <span class="variable">$this-</span>&gt;getErr(<span class="string">'出错了，没有找到该页面！'</span>);
    public function detail(<span class="variable">$url</span>) {
        <span class="variable">$content</span> = @file_get_contents(<span class="variable">$url</span>);
        return <span class="variable">$content</span>? <span class="variable">$content</span> : <span class="variable">$this-</span>&gt;getErr(<span class="string">'404'</span>,<span class="string">'出错了，没有找到该页面！'</span>);
    }
</code></pre><p>detail 方法获取到了url参数之后直接file_get_contents输出。最典型的任意文件读取漏洞。</p>
<h1 id="修复方案">修复方案</h1><p>白名单用户的输入就可以了。</p>
<h1 id="参考资料">参考资料</h1><p><a href="http://zone.wooyun.org/content/27434" target="_blank" rel="external">http://zone.wooyun.org/content/27434</a><br><a href="https://blog.netspi.com/directory-traversal-file-inclusion-proc-file-system/" target="_blank" rel="external">https://blog.netspi.com/directory-traversal-file-inclusion-proc-file-system/</a></p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/06/03/confluence任意文件读取漏洞分析/" class="prev">上一篇</a><a href="/2016/05/03/2016-CCTF之萝莉之旅/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://xdxd.love">xd_xd</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/hkalexling/Yuno-Apollo" target="_blank">Yuno-Apollo</a>.</p></div></footer></div><script src="https://cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>