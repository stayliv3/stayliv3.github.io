<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> ecshop前台任意用户登录漏洞分析记录 · xd_xd's blog</title><meta name="description" content="ecshop前台任意用户登录漏洞分析记录 - xd_xd"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/jquery.goup.js"></script><script src="/js/goup.js"></script><link rel="search" type="application/opensearchdescription+xml" href="http://xdxd.love/atom.xml" title="xd_xd's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/stayliv3" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/archives" target="_self" class="nav-list-link">ARCHIVES</a></li><li class="nav-list-item"><a href="/friends" target="_self" class="nav-list-link">FRIENDS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">ecshop前台任意用户登录漏洞分析记录</h1><div class="post-info">Oct 29, 2014</div><div class="post-content"><p>ecshop前台任意用户登录漏洞分析记录</p>
<p>漏洞详情参考：<a href="http://www.wooyun.org/bugs/wooyun-2014-063655" target="_blank" rel="external">http://www.wooyun.org/bugs/wooyun-2014-063655</a></p>
<p>这里比较坑的是ecshop的架构设计不是很好。不同页面的登录使用了不同的登录逻辑，虽然都是复制粘贴的，但是没有复制全，导致存在问题。</p>
<p>根据乌云的漏洞详情，看到是由于采用了check_user函数，这个函数有个这样一段逻辑：</p>
<pre><code><span class="keyword">if</span> (<span class="variable">$password</span> === null)
        {
            <span class="variable">$sql</span> = <span class="string">"SELECT "</span> . <span class="variable">$this-</span>&gt;field_id .
                   <span class="string">" FROM "</span> . <span class="variable">$this-</span>&gt;table(<span class="variable">$this-</span>&gt;user_table).
                   <span class="string">" WHERE "</span> . <span class="variable">$this-</span>&gt;field_name . <span class="string">"='"</span> . <span class="variable">$post</span>_username . <span class="string">"'"</span>;

            return <span class="variable">$this-</span>&gt;db-&gt;getOne(<span class="variable">$sql</span>);
</code></pre><p>如果$password===null,直接返回查询对应用户名的结果。既验证通过了。导致提交的时候去掉password变量，$password没有赋值，$password===null判断为真。</p>
<p>而官方的修复方式是验证之前加了一个判断：</p>
<pre><code><span class="variable">$_POST</span>[<span class="string">'password'</span>]=isset(<span class="variable">$_POST</span>[<span class="string">'password'</span>]) ? <span class="keyword">trim</span>(<span class="variable">$_POST</span>[<span class="string">'password'</span>]) : <span class="string">''</span>;
</code></pre><p>如果$_POST[‘password’]没设置，让$_POST[‘password’]的值为空字符串’’。这个逻辑个人感觉略坑。既然是验证登录，而没有发送密码直接返回错误信息不就可以了么。干嘛还要进入后续的逻辑。</p>
<p>当然这里的修复是没有问题的。但是如果</p>
<pre><code><span class="keyword">if</span> (<span class="variable">$password</span> === null)
            {
                <span class="variable">$sql</span> = <span class="string">"SELECT "</span> . <span class="variable">$this-</span>&gt;field_id .
                       <span class="string">" FROM "</span> . <span class="variable">$this-</span>&gt;table(<span class="variable">$this-</span>&gt;user_table).
                       <span class="string">" WHERE "</span> . <span class="variable">$this-</span>&gt;field_name . <span class="string">"='"</span> . <span class="variable">$post</span>_username . <span class="string">"'"</span>;
</code></pre><p>变成 </p>
<pre><code><span class="keyword">if</span> (<span class="variable">$password</span> == null)
            {
                <span class="variable">$sql</span> = <span class="string">"SELECT "</span> . <span class="variable">$this-</span>&gt;field_id .
                       <span class="string">" FROM "</span> . <span class="variable">$this-</span>&gt;table(<span class="variable">$this-</span>&gt;user_table).
                       <span class="string">" WHERE "</span> . <span class="variable">$this-</span>&gt;field_name . <span class="string">"='"</span> . <span class="variable">$post</span>_username . <span class="string">"'"</span>;             
</code></pre><p>===变成==就会存在问题了。因为在php里，==判断只判断值，并且会先进行强制性懂得类型转换。转换成统一数据类型进行比较。所以’’==null 这个判断是成立的。如果判断逻辑写成==，那么就可以继续任意帐号登录了。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2014/10/31/mysqlfeature/" class="prev">上一篇</a><a href="/2014/10/27/mysql布尔类型和php布尔类型的区别/" class="next">下一篇</a></div><div class="copyright"><p>© 2016 <a href="http://xdxd.love">xd_xd</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/hkalexling/Yuno-Apollo" target="_blank">Yuno-Apollo</a>.</p></div></footer></div><script src="https://cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>