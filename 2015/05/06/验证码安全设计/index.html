<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 验证码安全设计 · xd_xd's blog</title><meta name="description" content="验证码安全设计 - xd_xd"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/jquery.goup.js"></script><script src="/js/goup.js"></script><link rel="search" type="application/opensearchdescription+xml" href="http://xdxd.love/atom.xml" title="xd_xd's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/hkalexling" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/archives" target="_self" class="nav-list-link">ARCHIVES</a></li><li class="nav-list-item"><a href="/friends" target="_self" class="nav-list-link">FRIENDS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">验证码安全设计</h1><div class="post-info">May 6, 2015</div><div class="post-content"><p>这里讨论一下验证码设计过程中的那些坑。主要是设计中存在缺陷导致验证码失效的情况，不包括OCR识别。网上已经可以找到一些总结验证码容易出现问题的地方，但都是一些零散的点。这里希望从设计流程的层面解读一下，不仅仅是指出容易出现的问题，更想探究一下如何更好的设计可以避免这些问题。水平有限，不恰当的地方欢迎指出。</p>
<p>#验证码的目的</p>
<p>CAPTCHA，全称全自动区分计算机和人类的图灵测试(Completely Automated Public Turing test to tell Computers and Humans Apart)，是一种典型的挑战-应答测试，目的是用来区分人类和机器的。更详细参考<a href="http://zh.wikipedia.org/wiki/%E9%AA%8C%E8%AF%81%E7%A0%81" target="_blank" rel="external">维基百科</a>。在WEB安全领域，为了避免某些接口或功能被机器滥用，通常通过验证码的方式来过滤机器的请求。<br><img src="/images/yanzhengma1.png" alt="验证码示例"></p>
<p>#验证码流程</p>
<p>很多网站第一次登录就有验证码，而第一次登录即使是机器行为，也达不到滥用的标准。反而增加了所有用户的成本，降低了体验。更好的设计应该是最初是没有验证码的，当检测到异常的时候，出现验证码。所以整个流程应该是这样的。</p>
<p><img src="/images/yanzhengma2.png" alt="验证码流程"></p>
<p>##触发验证码策略</p>
<p>目前所有的验证码绕过的问题，应该都算设计上没有考虑好。先看第一个关键的一步，何时触发验证码策略。既然验证码的目的是识别人和机器。那么在给目标用户展示验证码的时候就会遇到一个很核心的问题，如何识别这个用户。因为只有这个用户行为有些异常，如何区分这个用户和其他用户？在登录这个场景来说，比如sessionID，比如IP，比如用户名，哪个更合适呢。大家都知道sessionID是可以伪造的。所以用IP来区分用户更加合适，虽然这会导致使用同一个IP出口的用户也出现验证码。这里以新浪微博手机版登录测试。第一次登录没有验证码，多次登录出现验证码。但是此时删除cookie。就又可以不使用验证码登录了。当然这里实际上对IP也进行了检测，所以没有办法进行暴力破解。</p>
<p><img src="/images/yanzhengma3.png" alt=""><br><img src="/images/yanzhengma4.png" alt=""><br>使用cookie等用户可控的参数作为验证码触发策略案例参考<a href="http://wooyun.org/bugs/wooyun-2015-0108637" target="_blank" rel="external">天天果园某接口撞库泄露用户登录凭据(验证码绕过)</a>。<br>触发验证码阶段需要使用IP对用户进行区分，这里一个常见的缺陷就是使用了用户可控的输入作为来源IP，比如X-Forwarded-For等。参考案例：<a href="http://wooyun.org/bugs/wooyun-2015-0108980" target="_blank" rel="external">优酷主站某接口撞库</a>。这里比较经典的案例还有discuz的暴力破解问题，参考<a href="http://blog.wangzhan.360.cn/?p=135" target="_blank" rel="external">DZ自动爆破工具原理分析</a>。discuz使用了$_SERVER[‘HTTP_CLIENT_IP’]作为IP来源，而这个变量是用户可控的。</p>
<p><strong>触发验证码策略阶段存在的主要缺陷是用来识别用户的凭据是用户端可控可伪造的。用户可以伪造一个新的用户身份从而绕过验证码触发的策略。</strong><br>具体的体现就是使用sessionID识别用户，或者虽然采用了IP识别用户，但是使用了Client-IP等用户可控的变量作为来源。<strong>正确的方案应该是使用$_SERVER[‘REMOTE_ADDR’]php作为识别用户的依据，当访问异常时进行验证码验证，此后一段时间内，来自该IP的请求都标记为需要验证码的请求，需要通过验证码验证才处理请求。</strong></p>
<p>##生成跟当前用户绑定的验证码</p>
<p>这个过程也是十分容易出现问题的。当然这个验证码是需要在服务端生成的。类似于<a href="http://www.wooyun.org/bugs/wooyun-2014-082411" target="_blank" rel="external">南开大学信息门户网站设计不当可以爆破用户密码</a>这种在本地用js生成验证码，用js验证的设计连最基本的不要在客户端做认证的原则都违背了。在早期的一些小网站上可能存在，但也应该比较少见了。这里就忽略这种设计了。</p>
<p><strong>产生的验证码是有一定的要求的，需要客户端无法预测，无法暴力破解，不能从其他的方式得知，保证只能通过从验证码图片上识别才能获得验证码。</strong>常见的没有遵守这几点的缺陷有<a href="http://www.wooyun.org/bugs/wooyun-2012-06634" target="_blank" rel="external">索尼验证码实现缺陷</a>,用html模拟验证码的样式，看起来像是图片验证码，实际上是html，可以直接获得明文。程序员的这个思路也是醉了，显然没有理解为什么要做验证码。或者把验证码直接返回给了客户端，也有的编码一下返回给客户端，都是不行的。比如<a href="http://www.wooyun.org/bugs/wooyun-2014-086797" target="_blank" rel="external">吉祥航空任意客票遍历</a>。也有的验证码答案的空间太小，比如<a href="http://www.wooyun.org/bugs/wooyun-2013-025245" target="_blank" rel="external">139邮箱图验证码绕过漏洞</a>，只有abcd四种可能，随便猜一个的正确率都有25%了。4位字母数字验证码，共1679616个可能，可以认为是无法暴力破解的。</p>
<p><img src="/images/yanzhengma5.png" alt="电信验证码"></p>
<p>这里验证码绑定用户，一般都是通过session绑定。虽然识别用户是否需要验证码通过IP来判断，但是IP毕竟无法保证只有一个用户使用。也有一些应用设计一个验证码ID的参数，随机生成一个验证码ID参数跟验证码绑定，返回验证码ID给客户端，客户端提交验证码ID和验证码来验证码。原理跟绑定sessionID是类似的。</p>
<p>##验证验证码</p>
<p>这个阶段出现的问题相对较少。验证本来就是做一下比较很简单的事情，但是程序员在实现的时候也可能出现各种坑。比如<a href="http://www.wooyun.org/bugs/wooyun-2013-025065" target="_blank" rel="external">ecshop绕过验证码暴利破解2</a>,当验证码字段为空时，服务端就不进行比较直接进入下一步了。<a href="http://www.wooyun.org/bugs/wooyun-2012-05095" target="_blank" rel="external">百度空间用户登录绕过验证码验证</a>使用0000可以正确验证任意验证码。</p>
<p><img src="/images/yanzhengma6.png" alt="验证码"></p>
<p>##验证完成之后销毁验证码</p>
<p><strong>这里也是一个经常出现问题的地方。很多验证码设计中都没有在服务端主动销毁验证码的机制，而是依赖客户端刷新来覆盖旧的验证码。导致一个验证码可以重复使用。</strong>从验证码的作用上来说，一次正确的验证码输入只能保证这一次请求被处理，下一次请求依然需要重新输入验证码。案例<a href="http://www.wooyun.org/bugs/wooyun-2010-046547" target="_blank" rel="external">乌云集市验证码机制绕过</a>。当然验证失败，也需要销毁验证码，让客户端刷新验证码。因为既然用户识别这个验证码失败，说明用户可能识别这个验证码有一些问题，所以换一个也是更好的体验。</p>
<p>##内部接口暴露导致可以控制后端逻辑</p>
<p>此外还有一种常见的设计问题。在一些设计比较充分的系统，验证码的相关业务可能提供了比较多的接口，比如可以控制这个请求是否需要验证码。生成复杂度多少的验证码之类。这种接口本来应该是系统内部调用的，如果暴露给了最终用户，就导致用户可以控制后端逻辑，从而绕过验证码。案例<a href="http://www.wooyun.org/bugs/wooyun-2014-071289" target="_blank" rel="external">阿里巴巴某员工登录接口验证码绕过</a>,<a href="http://www.wooyun.org/bugs/wooyun-2012-014563" target="_blank" rel="external">凡客某处验证码绕过漏洞</a>。阿里这个验证码接口传递的数据中有个字段叫needcheckcode=true，把true改成false，服务端就不进行验证了。</p>
<p><img src="/images/yanzhengma7.png" alt="阿里验证码"></p>
<p>通常来说，触发验证码的策略，生成跟用户绑定的验证码，验证完成之后是否销毁验证码都是很容易出现问题的地方。但只要仔细的过一遍这些可能出现的问题，是可以设计出一个可靠的验证码系统的。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2015/05/11/awvs批量扫描系统/" class="prev">上一篇</a><a href="/2015/04/27/xkungfoo2015记录/" class="next">下一篇</a></div><div class="copyright"><p>© 2016 <a href="http://xdxd.love">xd_xd</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/hkalexling/Yuno-Apollo" target="_blank">Yuno-Apollo</a>.</p></div></footer></div><script src="https://cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>